
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model RAW_MATERIALS
 * 
 */
export type RAW_MATERIALS = $Result.DefaultSelection<Prisma.$RAW_MATERIALSPayload>
/**
 * Model SHOPIFY_VARIANTS
 * 
 */
export type SHOPIFY_VARIANTS = $Result.DefaultSelection<Prisma.$SHOPIFY_VARIANTSPayload>
/**
 * Model VARIANT_RAW_MATERIALS_TRACKER
 * 
 */
export type VARIANT_RAW_MATERIALS_TRACKER = $Result.DefaultSelection<Prisma.$VARIANT_RAW_MATERIALS_TRACKERPayload>
/**
 * Model CATEGORIES
 * 
 */
export type CATEGORIES = $Result.DefaultSelection<Prisma.$CATEGORIESPayload>
/**
 * Model SHOPIFY_PRODUCTS
 * 
 */
export type SHOPIFY_PRODUCTS = $Result.DefaultSelection<Prisma.$SHOPIFY_PRODUCTSPayload>
/**
 * Model RM_TRANSACTIONS
 * 
 */
export type RM_TRANSACTIONS = $Result.DefaultSelection<Prisma.$RM_TRANSACTIONSPayload>
/**
 * Model RM_QC
 * 
 */
export type RM_QC = $Result.DefaultSelection<Prisma.$RM_QCPayload>
/**
 * Model RM_WASTAGE_LOGS
 * 
 */
export type RM_WASTAGE_LOGS = $Result.DefaultSelection<Prisma.$RM_WASTAGE_LOGSPayload>
/**
 * Model Employee
 * 
 */
export type Employee = $Result.DefaultSelection<Prisma.$EmployeePayload>
/**
 * Model WIP
 * 
 */
export type WIP = $Result.DefaultSelection<Prisma.$WIPPayload>
/**
 * Model WIP_PRODUCTS
 * 
 */
export type WIP_PRODUCTS = $Result.DefaultSelection<Prisma.$WIP_PRODUCTSPayload>
/**
 * Model WIPRawMaterial
 * 
 */
export type WIPRawMaterial = $Result.DefaultSelection<Prisma.$WIPRawMaterialPayload>
/**
 * Model FG
 * 
 */
export type FG = $Result.DefaultSelection<Prisma.$FGPayload>
/**
 * Model FG_PRODUCTS
 * 
 */
export type FG_PRODUCTS = $Result.DefaultSelection<Prisma.$FG_PRODUCTSPayload>
/**
 * Model WIP_TRANSACTIONS
 * 
 */
export type WIP_TRANSACTIONS = $Result.DefaultSelection<Prisma.$WIP_TRANSACTIONSPayload>
/**
 * Model FG_TRANSACTIONS
 * 
 */
export type FG_TRANSACTIONS = $Result.DefaultSelection<Prisma.$FG_TRANSACTIONSPayload>
/**
 * Model WIP_QC
 * 
 */
export type WIP_QC = $Result.DefaultSelection<Prisma.$WIP_QCPayload>
/**
 * Model FG_QC
 * 
 */
export type FG_QC = $Result.DefaultSelection<Prisma.$FG_QCPayload>
/**
 * Model WIP_WASTAGE_LOGS
 * 
 */
export type WIP_WASTAGE_LOGS = $Result.DefaultSelection<Prisma.$WIP_WASTAGE_LOGSPayload>
/**
 * Model FG_WASTAGE_LOGS
 * 
 */
export type FG_WASTAGE_LOGS = $Result.DefaultSelection<Prisma.$FG_WASTAGE_LOGSPayload>
/**
 * Model AuditLogs
 * 
 */
export type AuditLogs = $Result.DefaultSelection<Prisma.$AuditLogsPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const TransactionType: {
  IN: 'IN',
  OUT: 'OUT',
  CREDITED: 'CREDITED',
  DEBITED: 'DEBITED'
};

export type TransactionType = (typeof TransactionType)[keyof typeof TransactionType]


export const QualityStatus: {
  GOOD: 'GOOD',
  AVERAGE: 'AVERAGE',
  POOR: 'POOR'
};

export type QualityStatus = (typeof QualityStatus)[keyof typeof QualityStatus]


export const Status: {
  IN_PROGRESS: 'IN_PROGRESS',
  COMPLETED: 'COMPLETED',
  FAILED: 'FAILED'
};

export type Status = (typeof Status)[keyof typeof Status]


export const Roles: {
  ADMIN: 'ADMIN',
  EMPLOYEE: 'EMPLOYEE'
};

export type Roles = (typeof Roles)[keyof typeof Roles]


export const Actions: {
  INSERT: 'INSERT',
  UPDATE: 'UPDATE',
  DELETE: 'DELETE'
};

export type Actions = (typeof Actions)[keyof typeof Actions]

}

export type TransactionType = $Enums.TransactionType

export const TransactionType: typeof $Enums.TransactionType

export type QualityStatus = $Enums.QualityStatus

export const QualityStatus: typeof $Enums.QualityStatus

export type Status = $Enums.Status

export const Status: typeof $Enums.Status

export type Roles = $Enums.Roles

export const Roles: typeof $Enums.Roles

export type Actions = $Enums.Actions

export const Actions: typeof $Enums.Actions

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more RAW_MATERIALS
 * const rAW_MATERIALS = await prisma.rAW_MATERIALS.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more RAW_MATERIALS
   * const rAW_MATERIALS = await prisma.rAW_MATERIALS.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb, ExtArgs, $Utils.Call<Prisma.TypeMapCb, {
    extArgs: ExtArgs
  }>, ClientOptions>

      /**
   * `prisma.rAW_MATERIALS`: Exposes CRUD operations for the **RAW_MATERIALS** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RAW_MATERIALS
    * const rAW_MATERIALS = await prisma.rAW_MATERIALS.findMany()
    * ```
    */
  get rAW_MATERIALS(): Prisma.RAW_MATERIALSDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.sHOPIFY_VARIANTS`: Exposes CRUD operations for the **SHOPIFY_VARIANTS** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SHOPIFY_VARIANTS
    * const sHOPIFY_VARIANTS = await prisma.sHOPIFY_VARIANTS.findMany()
    * ```
    */
  get sHOPIFY_VARIANTS(): Prisma.SHOPIFY_VARIANTSDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.vARIANT_RAW_MATERIALS_TRACKER`: Exposes CRUD operations for the **VARIANT_RAW_MATERIALS_TRACKER** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more VARIANT_RAW_MATERIALS_TRACKERS
    * const vARIANT_RAW_MATERIALS_TRACKERS = await prisma.vARIANT_RAW_MATERIALS_TRACKER.findMany()
    * ```
    */
  get vARIANT_RAW_MATERIALS_TRACKER(): Prisma.VARIANT_RAW_MATERIALS_TRACKERDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.cATEGORIES`: Exposes CRUD operations for the **CATEGORIES** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CATEGORIES
    * const cATEGORIES = await prisma.cATEGORIES.findMany()
    * ```
    */
  get cATEGORIES(): Prisma.CATEGORIESDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.sHOPIFY_PRODUCTS`: Exposes CRUD operations for the **SHOPIFY_PRODUCTS** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SHOPIFY_PRODUCTS
    * const sHOPIFY_PRODUCTS = await prisma.sHOPIFY_PRODUCTS.findMany()
    * ```
    */
  get sHOPIFY_PRODUCTS(): Prisma.SHOPIFY_PRODUCTSDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.rM_TRANSACTIONS`: Exposes CRUD operations for the **RM_TRANSACTIONS** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RM_TRANSACTIONS
    * const rM_TRANSACTIONS = await prisma.rM_TRANSACTIONS.findMany()
    * ```
    */
  get rM_TRANSACTIONS(): Prisma.RM_TRANSACTIONSDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.rM_QC`: Exposes CRUD operations for the **RM_QC** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RM_QCS
    * const rM_QCS = await prisma.rM_QC.findMany()
    * ```
    */
  get rM_QC(): Prisma.RM_QCDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.rM_WASTAGE_LOGS`: Exposes CRUD operations for the **RM_WASTAGE_LOGS** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RM_WASTAGE_LOGS
    * const rM_WASTAGE_LOGS = await prisma.rM_WASTAGE_LOGS.findMany()
    * ```
    */
  get rM_WASTAGE_LOGS(): Prisma.RM_WASTAGE_LOGSDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.employee`: Exposes CRUD operations for the **Employee** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Employees
    * const employees = await prisma.employee.findMany()
    * ```
    */
  get employee(): Prisma.EmployeeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.wIP`: Exposes CRUD operations for the **WIP** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more WIPS
    * const wIPS = await prisma.wIP.findMany()
    * ```
    */
  get wIP(): Prisma.WIPDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.wIP_PRODUCTS`: Exposes CRUD operations for the **WIP_PRODUCTS** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more WIP_PRODUCTS
    * const wIP_PRODUCTS = await prisma.wIP_PRODUCTS.findMany()
    * ```
    */
  get wIP_PRODUCTS(): Prisma.WIP_PRODUCTSDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.wIPRawMaterial`: Exposes CRUD operations for the **WIPRawMaterial** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more WIPRawMaterials
    * const wIPRawMaterials = await prisma.wIPRawMaterial.findMany()
    * ```
    */
  get wIPRawMaterial(): Prisma.WIPRawMaterialDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.fG`: Exposes CRUD operations for the **FG** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FGS
    * const fGS = await prisma.fG.findMany()
    * ```
    */
  get fG(): Prisma.FGDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.fG_PRODUCTS`: Exposes CRUD operations for the **FG_PRODUCTS** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FG_PRODUCTS
    * const fG_PRODUCTS = await prisma.fG_PRODUCTS.findMany()
    * ```
    */
  get fG_PRODUCTS(): Prisma.FG_PRODUCTSDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.wIP_TRANSACTIONS`: Exposes CRUD operations for the **WIP_TRANSACTIONS** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more WIP_TRANSACTIONS
    * const wIP_TRANSACTIONS = await prisma.wIP_TRANSACTIONS.findMany()
    * ```
    */
  get wIP_TRANSACTIONS(): Prisma.WIP_TRANSACTIONSDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.fG_TRANSACTIONS`: Exposes CRUD operations for the **FG_TRANSACTIONS** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FG_TRANSACTIONS
    * const fG_TRANSACTIONS = await prisma.fG_TRANSACTIONS.findMany()
    * ```
    */
  get fG_TRANSACTIONS(): Prisma.FG_TRANSACTIONSDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.wIP_QC`: Exposes CRUD operations for the **WIP_QC** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more WIP_QCS
    * const wIP_QCS = await prisma.wIP_QC.findMany()
    * ```
    */
  get wIP_QC(): Prisma.WIP_QCDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.fG_QC`: Exposes CRUD operations for the **FG_QC** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FG_QCS
    * const fG_QCS = await prisma.fG_QC.findMany()
    * ```
    */
  get fG_QC(): Prisma.FG_QCDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.wIP_WASTAGE_LOGS`: Exposes CRUD operations for the **WIP_WASTAGE_LOGS** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more WIP_WASTAGE_LOGS
    * const wIP_WASTAGE_LOGS = await prisma.wIP_WASTAGE_LOGS.findMany()
    * ```
    */
  get wIP_WASTAGE_LOGS(): Prisma.WIP_WASTAGE_LOGSDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.fG_WASTAGE_LOGS`: Exposes CRUD operations for the **FG_WASTAGE_LOGS** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FG_WASTAGE_LOGS
    * const fG_WASTAGE_LOGS = await prisma.fG_WASTAGE_LOGS.findMany()
    * ```
    */
  get fG_WASTAGE_LOGS(): Prisma.FG_WASTAGE_LOGSDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.auditLogs`: Exposes CRUD operations for the **AuditLogs** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AuditLogs
    * const auditLogs = await prisma.auditLogs.findMany()
    * ```
    */
  get auditLogs(): Prisma.AuditLogsDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.2.1
   * Query Engine version: 4123509d24aa4dede1e864b46351bf2790323b69
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    RAW_MATERIALS: 'RAW_MATERIALS',
    SHOPIFY_VARIANTS: 'SHOPIFY_VARIANTS',
    VARIANT_RAW_MATERIALS_TRACKER: 'VARIANT_RAW_MATERIALS_TRACKER',
    CATEGORIES: 'CATEGORIES',
    SHOPIFY_PRODUCTS: 'SHOPIFY_PRODUCTS',
    RM_TRANSACTIONS: 'RM_TRANSACTIONS',
    RM_QC: 'RM_QC',
    RM_WASTAGE_LOGS: 'RM_WASTAGE_LOGS',
    Employee: 'Employee',
    WIP: 'WIP',
    WIP_PRODUCTS: 'WIP_PRODUCTS',
    WIPRawMaterial: 'WIPRawMaterial',
    FG: 'FG',
    FG_PRODUCTS: 'FG_PRODUCTS',
    WIP_TRANSACTIONS: 'WIP_TRANSACTIONS',
    FG_TRANSACTIONS: 'FG_TRANSACTIONS',
    WIP_QC: 'WIP_QC',
    FG_QC: 'FG_QC',
    WIP_WASTAGE_LOGS: 'WIP_WASTAGE_LOGS',
    FG_WASTAGE_LOGS: 'FG_WASTAGE_LOGS',
    AuditLogs: 'AuditLogs'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs, clientOptions: PrismaClientOptions }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], this['params']['clientOptions']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> = {
    meta: {
      modelProps: "rAW_MATERIALS" | "sHOPIFY_VARIANTS" | "vARIANT_RAW_MATERIALS_TRACKER" | "cATEGORIES" | "sHOPIFY_PRODUCTS" | "rM_TRANSACTIONS" | "rM_QC" | "rM_WASTAGE_LOGS" | "employee" | "wIP" | "wIP_PRODUCTS" | "wIPRawMaterial" | "fG" | "fG_PRODUCTS" | "wIP_TRANSACTIONS" | "fG_TRANSACTIONS" | "wIP_QC" | "fG_QC" | "wIP_WASTAGE_LOGS" | "fG_WASTAGE_LOGS" | "auditLogs"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      RAW_MATERIALS: {
        payload: Prisma.$RAW_MATERIALSPayload<ExtArgs>
        fields: Prisma.RAW_MATERIALSFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RAW_MATERIALSFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RAW_MATERIALSPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RAW_MATERIALSFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RAW_MATERIALSPayload>
          }
          findFirst: {
            args: Prisma.RAW_MATERIALSFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RAW_MATERIALSPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RAW_MATERIALSFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RAW_MATERIALSPayload>
          }
          findMany: {
            args: Prisma.RAW_MATERIALSFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RAW_MATERIALSPayload>[]
          }
          create: {
            args: Prisma.RAW_MATERIALSCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RAW_MATERIALSPayload>
          }
          createMany: {
            args: Prisma.RAW_MATERIALSCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.RAW_MATERIALSDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RAW_MATERIALSPayload>
          }
          update: {
            args: Prisma.RAW_MATERIALSUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RAW_MATERIALSPayload>
          }
          deleteMany: {
            args: Prisma.RAW_MATERIALSDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RAW_MATERIALSUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.RAW_MATERIALSUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RAW_MATERIALSPayload>
          }
          aggregate: {
            args: Prisma.RAW_MATERIALSAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRAW_MATERIALS>
          }
          groupBy: {
            args: Prisma.RAW_MATERIALSGroupByArgs<ExtArgs>
            result: $Utils.Optional<RAW_MATERIALSGroupByOutputType>[]
          }
          count: {
            args: Prisma.RAW_MATERIALSCountArgs<ExtArgs>
            result: $Utils.Optional<RAW_MATERIALSCountAggregateOutputType> | number
          }
        }
      }
      SHOPIFY_VARIANTS: {
        payload: Prisma.$SHOPIFY_VARIANTSPayload<ExtArgs>
        fields: Prisma.SHOPIFY_VARIANTSFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SHOPIFY_VARIANTSFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SHOPIFY_VARIANTSPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SHOPIFY_VARIANTSFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SHOPIFY_VARIANTSPayload>
          }
          findFirst: {
            args: Prisma.SHOPIFY_VARIANTSFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SHOPIFY_VARIANTSPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SHOPIFY_VARIANTSFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SHOPIFY_VARIANTSPayload>
          }
          findMany: {
            args: Prisma.SHOPIFY_VARIANTSFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SHOPIFY_VARIANTSPayload>[]
          }
          create: {
            args: Prisma.SHOPIFY_VARIANTSCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SHOPIFY_VARIANTSPayload>
          }
          createMany: {
            args: Prisma.SHOPIFY_VARIANTSCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.SHOPIFY_VARIANTSDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SHOPIFY_VARIANTSPayload>
          }
          update: {
            args: Prisma.SHOPIFY_VARIANTSUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SHOPIFY_VARIANTSPayload>
          }
          deleteMany: {
            args: Prisma.SHOPIFY_VARIANTSDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SHOPIFY_VARIANTSUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SHOPIFY_VARIANTSUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SHOPIFY_VARIANTSPayload>
          }
          aggregate: {
            args: Prisma.SHOPIFY_VARIANTSAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSHOPIFY_VARIANTS>
          }
          groupBy: {
            args: Prisma.SHOPIFY_VARIANTSGroupByArgs<ExtArgs>
            result: $Utils.Optional<SHOPIFY_VARIANTSGroupByOutputType>[]
          }
          count: {
            args: Prisma.SHOPIFY_VARIANTSCountArgs<ExtArgs>
            result: $Utils.Optional<SHOPIFY_VARIANTSCountAggregateOutputType> | number
          }
        }
      }
      VARIANT_RAW_MATERIALS_TRACKER: {
        payload: Prisma.$VARIANT_RAW_MATERIALS_TRACKERPayload<ExtArgs>
        fields: Prisma.VARIANT_RAW_MATERIALS_TRACKERFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VARIANT_RAW_MATERIALS_TRACKERFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VARIANT_RAW_MATERIALS_TRACKERPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VARIANT_RAW_MATERIALS_TRACKERFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VARIANT_RAW_MATERIALS_TRACKERPayload>
          }
          findFirst: {
            args: Prisma.VARIANT_RAW_MATERIALS_TRACKERFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VARIANT_RAW_MATERIALS_TRACKERPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VARIANT_RAW_MATERIALS_TRACKERFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VARIANT_RAW_MATERIALS_TRACKERPayload>
          }
          findMany: {
            args: Prisma.VARIANT_RAW_MATERIALS_TRACKERFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VARIANT_RAW_MATERIALS_TRACKERPayload>[]
          }
          create: {
            args: Prisma.VARIANT_RAW_MATERIALS_TRACKERCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VARIANT_RAW_MATERIALS_TRACKERPayload>
          }
          createMany: {
            args: Prisma.VARIANT_RAW_MATERIALS_TRACKERCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.VARIANT_RAW_MATERIALS_TRACKERDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VARIANT_RAW_MATERIALS_TRACKERPayload>
          }
          update: {
            args: Prisma.VARIANT_RAW_MATERIALS_TRACKERUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VARIANT_RAW_MATERIALS_TRACKERPayload>
          }
          deleteMany: {
            args: Prisma.VARIANT_RAW_MATERIALS_TRACKERDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VARIANT_RAW_MATERIALS_TRACKERUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.VARIANT_RAW_MATERIALS_TRACKERUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VARIANT_RAW_MATERIALS_TRACKERPayload>
          }
          aggregate: {
            args: Prisma.VARIANT_RAW_MATERIALS_TRACKERAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVARIANT_RAW_MATERIALS_TRACKER>
          }
          groupBy: {
            args: Prisma.VARIANT_RAW_MATERIALS_TRACKERGroupByArgs<ExtArgs>
            result: $Utils.Optional<VARIANT_RAW_MATERIALS_TRACKERGroupByOutputType>[]
          }
          count: {
            args: Prisma.VARIANT_RAW_MATERIALS_TRACKERCountArgs<ExtArgs>
            result: $Utils.Optional<VARIANT_RAW_MATERIALS_TRACKERCountAggregateOutputType> | number
          }
        }
      }
      CATEGORIES: {
        payload: Prisma.$CATEGORIESPayload<ExtArgs>
        fields: Prisma.CATEGORIESFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CATEGORIESFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CATEGORIESPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CATEGORIESFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CATEGORIESPayload>
          }
          findFirst: {
            args: Prisma.CATEGORIESFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CATEGORIESPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CATEGORIESFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CATEGORIESPayload>
          }
          findMany: {
            args: Prisma.CATEGORIESFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CATEGORIESPayload>[]
          }
          create: {
            args: Prisma.CATEGORIESCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CATEGORIESPayload>
          }
          createMany: {
            args: Prisma.CATEGORIESCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.CATEGORIESDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CATEGORIESPayload>
          }
          update: {
            args: Prisma.CATEGORIESUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CATEGORIESPayload>
          }
          deleteMany: {
            args: Prisma.CATEGORIESDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CATEGORIESUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CATEGORIESUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CATEGORIESPayload>
          }
          aggregate: {
            args: Prisma.CATEGORIESAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCATEGORIES>
          }
          groupBy: {
            args: Prisma.CATEGORIESGroupByArgs<ExtArgs>
            result: $Utils.Optional<CATEGORIESGroupByOutputType>[]
          }
          count: {
            args: Prisma.CATEGORIESCountArgs<ExtArgs>
            result: $Utils.Optional<CATEGORIESCountAggregateOutputType> | number
          }
        }
      }
      SHOPIFY_PRODUCTS: {
        payload: Prisma.$SHOPIFY_PRODUCTSPayload<ExtArgs>
        fields: Prisma.SHOPIFY_PRODUCTSFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SHOPIFY_PRODUCTSFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SHOPIFY_PRODUCTSPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SHOPIFY_PRODUCTSFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SHOPIFY_PRODUCTSPayload>
          }
          findFirst: {
            args: Prisma.SHOPIFY_PRODUCTSFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SHOPIFY_PRODUCTSPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SHOPIFY_PRODUCTSFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SHOPIFY_PRODUCTSPayload>
          }
          findMany: {
            args: Prisma.SHOPIFY_PRODUCTSFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SHOPIFY_PRODUCTSPayload>[]
          }
          create: {
            args: Prisma.SHOPIFY_PRODUCTSCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SHOPIFY_PRODUCTSPayload>
          }
          createMany: {
            args: Prisma.SHOPIFY_PRODUCTSCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.SHOPIFY_PRODUCTSDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SHOPIFY_PRODUCTSPayload>
          }
          update: {
            args: Prisma.SHOPIFY_PRODUCTSUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SHOPIFY_PRODUCTSPayload>
          }
          deleteMany: {
            args: Prisma.SHOPIFY_PRODUCTSDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SHOPIFY_PRODUCTSUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SHOPIFY_PRODUCTSUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SHOPIFY_PRODUCTSPayload>
          }
          aggregate: {
            args: Prisma.SHOPIFY_PRODUCTSAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSHOPIFY_PRODUCTS>
          }
          groupBy: {
            args: Prisma.SHOPIFY_PRODUCTSGroupByArgs<ExtArgs>
            result: $Utils.Optional<SHOPIFY_PRODUCTSGroupByOutputType>[]
          }
          count: {
            args: Prisma.SHOPIFY_PRODUCTSCountArgs<ExtArgs>
            result: $Utils.Optional<SHOPIFY_PRODUCTSCountAggregateOutputType> | number
          }
        }
      }
      RM_TRANSACTIONS: {
        payload: Prisma.$RM_TRANSACTIONSPayload<ExtArgs>
        fields: Prisma.RM_TRANSACTIONSFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RM_TRANSACTIONSFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RM_TRANSACTIONSPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RM_TRANSACTIONSFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RM_TRANSACTIONSPayload>
          }
          findFirst: {
            args: Prisma.RM_TRANSACTIONSFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RM_TRANSACTIONSPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RM_TRANSACTIONSFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RM_TRANSACTIONSPayload>
          }
          findMany: {
            args: Prisma.RM_TRANSACTIONSFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RM_TRANSACTIONSPayload>[]
          }
          create: {
            args: Prisma.RM_TRANSACTIONSCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RM_TRANSACTIONSPayload>
          }
          createMany: {
            args: Prisma.RM_TRANSACTIONSCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.RM_TRANSACTIONSDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RM_TRANSACTIONSPayload>
          }
          update: {
            args: Prisma.RM_TRANSACTIONSUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RM_TRANSACTIONSPayload>
          }
          deleteMany: {
            args: Prisma.RM_TRANSACTIONSDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RM_TRANSACTIONSUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.RM_TRANSACTIONSUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RM_TRANSACTIONSPayload>
          }
          aggregate: {
            args: Prisma.RM_TRANSACTIONSAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRM_TRANSACTIONS>
          }
          groupBy: {
            args: Prisma.RM_TRANSACTIONSGroupByArgs<ExtArgs>
            result: $Utils.Optional<RM_TRANSACTIONSGroupByOutputType>[]
          }
          count: {
            args: Prisma.RM_TRANSACTIONSCountArgs<ExtArgs>
            result: $Utils.Optional<RM_TRANSACTIONSCountAggregateOutputType> | number
          }
        }
      }
      RM_QC: {
        payload: Prisma.$RM_QCPayload<ExtArgs>
        fields: Prisma.RM_QCFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RM_QCFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RM_QCPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RM_QCFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RM_QCPayload>
          }
          findFirst: {
            args: Prisma.RM_QCFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RM_QCPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RM_QCFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RM_QCPayload>
          }
          findMany: {
            args: Prisma.RM_QCFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RM_QCPayload>[]
          }
          create: {
            args: Prisma.RM_QCCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RM_QCPayload>
          }
          createMany: {
            args: Prisma.RM_QCCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.RM_QCDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RM_QCPayload>
          }
          update: {
            args: Prisma.RM_QCUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RM_QCPayload>
          }
          deleteMany: {
            args: Prisma.RM_QCDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RM_QCUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.RM_QCUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RM_QCPayload>
          }
          aggregate: {
            args: Prisma.RM_QCAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRM_QC>
          }
          groupBy: {
            args: Prisma.RM_QCGroupByArgs<ExtArgs>
            result: $Utils.Optional<RM_QCGroupByOutputType>[]
          }
          count: {
            args: Prisma.RM_QCCountArgs<ExtArgs>
            result: $Utils.Optional<RM_QCCountAggregateOutputType> | number
          }
        }
      }
      RM_WASTAGE_LOGS: {
        payload: Prisma.$RM_WASTAGE_LOGSPayload<ExtArgs>
        fields: Prisma.RM_WASTAGE_LOGSFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RM_WASTAGE_LOGSFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RM_WASTAGE_LOGSPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RM_WASTAGE_LOGSFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RM_WASTAGE_LOGSPayload>
          }
          findFirst: {
            args: Prisma.RM_WASTAGE_LOGSFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RM_WASTAGE_LOGSPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RM_WASTAGE_LOGSFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RM_WASTAGE_LOGSPayload>
          }
          findMany: {
            args: Prisma.RM_WASTAGE_LOGSFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RM_WASTAGE_LOGSPayload>[]
          }
          create: {
            args: Prisma.RM_WASTAGE_LOGSCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RM_WASTAGE_LOGSPayload>
          }
          createMany: {
            args: Prisma.RM_WASTAGE_LOGSCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.RM_WASTAGE_LOGSDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RM_WASTAGE_LOGSPayload>
          }
          update: {
            args: Prisma.RM_WASTAGE_LOGSUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RM_WASTAGE_LOGSPayload>
          }
          deleteMany: {
            args: Prisma.RM_WASTAGE_LOGSDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RM_WASTAGE_LOGSUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.RM_WASTAGE_LOGSUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RM_WASTAGE_LOGSPayload>
          }
          aggregate: {
            args: Prisma.RM_WASTAGE_LOGSAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRM_WASTAGE_LOGS>
          }
          groupBy: {
            args: Prisma.RM_WASTAGE_LOGSGroupByArgs<ExtArgs>
            result: $Utils.Optional<RM_WASTAGE_LOGSGroupByOutputType>[]
          }
          count: {
            args: Prisma.RM_WASTAGE_LOGSCountArgs<ExtArgs>
            result: $Utils.Optional<RM_WASTAGE_LOGSCountAggregateOutputType> | number
          }
        }
      }
      Employee: {
        payload: Prisma.$EmployeePayload<ExtArgs>
        fields: Prisma.EmployeeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EmployeeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EmployeeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeePayload>
          }
          findFirst: {
            args: Prisma.EmployeeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EmployeeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeePayload>
          }
          findMany: {
            args: Prisma.EmployeeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeePayload>[]
          }
          create: {
            args: Prisma.EmployeeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeePayload>
          }
          createMany: {
            args: Prisma.EmployeeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.EmployeeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeePayload>
          }
          update: {
            args: Prisma.EmployeeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeePayload>
          }
          deleteMany: {
            args: Prisma.EmployeeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EmployeeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.EmployeeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeePayload>
          }
          aggregate: {
            args: Prisma.EmployeeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEmployee>
          }
          groupBy: {
            args: Prisma.EmployeeGroupByArgs<ExtArgs>
            result: $Utils.Optional<EmployeeGroupByOutputType>[]
          }
          count: {
            args: Prisma.EmployeeCountArgs<ExtArgs>
            result: $Utils.Optional<EmployeeCountAggregateOutputType> | number
          }
        }
      }
      WIP: {
        payload: Prisma.$WIPPayload<ExtArgs>
        fields: Prisma.WIPFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WIPFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WIPPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WIPFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WIPPayload>
          }
          findFirst: {
            args: Prisma.WIPFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WIPPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WIPFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WIPPayload>
          }
          findMany: {
            args: Prisma.WIPFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WIPPayload>[]
          }
          create: {
            args: Prisma.WIPCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WIPPayload>
          }
          createMany: {
            args: Prisma.WIPCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.WIPDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WIPPayload>
          }
          update: {
            args: Prisma.WIPUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WIPPayload>
          }
          deleteMany: {
            args: Prisma.WIPDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WIPUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.WIPUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WIPPayload>
          }
          aggregate: {
            args: Prisma.WIPAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWIP>
          }
          groupBy: {
            args: Prisma.WIPGroupByArgs<ExtArgs>
            result: $Utils.Optional<WIPGroupByOutputType>[]
          }
          count: {
            args: Prisma.WIPCountArgs<ExtArgs>
            result: $Utils.Optional<WIPCountAggregateOutputType> | number
          }
        }
      }
      WIP_PRODUCTS: {
        payload: Prisma.$WIP_PRODUCTSPayload<ExtArgs>
        fields: Prisma.WIP_PRODUCTSFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WIP_PRODUCTSFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WIP_PRODUCTSPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WIP_PRODUCTSFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WIP_PRODUCTSPayload>
          }
          findFirst: {
            args: Prisma.WIP_PRODUCTSFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WIP_PRODUCTSPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WIP_PRODUCTSFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WIP_PRODUCTSPayload>
          }
          findMany: {
            args: Prisma.WIP_PRODUCTSFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WIP_PRODUCTSPayload>[]
          }
          create: {
            args: Prisma.WIP_PRODUCTSCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WIP_PRODUCTSPayload>
          }
          createMany: {
            args: Prisma.WIP_PRODUCTSCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.WIP_PRODUCTSDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WIP_PRODUCTSPayload>
          }
          update: {
            args: Prisma.WIP_PRODUCTSUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WIP_PRODUCTSPayload>
          }
          deleteMany: {
            args: Prisma.WIP_PRODUCTSDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WIP_PRODUCTSUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.WIP_PRODUCTSUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WIP_PRODUCTSPayload>
          }
          aggregate: {
            args: Prisma.WIP_PRODUCTSAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWIP_PRODUCTS>
          }
          groupBy: {
            args: Prisma.WIP_PRODUCTSGroupByArgs<ExtArgs>
            result: $Utils.Optional<WIP_PRODUCTSGroupByOutputType>[]
          }
          count: {
            args: Prisma.WIP_PRODUCTSCountArgs<ExtArgs>
            result: $Utils.Optional<WIP_PRODUCTSCountAggregateOutputType> | number
          }
        }
      }
      WIPRawMaterial: {
        payload: Prisma.$WIPRawMaterialPayload<ExtArgs>
        fields: Prisma.WIPRawMaterialFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WIPRawMaterialFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WIPRawMaterialPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WIPRawMaterialFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WIPRawMaterialPayload>
          }
          findFirst: {
            args: Prisma.WIPRawMaterialFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WIPRawMaterialPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WIPRawMaterialFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WIPRawMaterialPayload>
          }
          findMany: {
            args: Prisma.WIPRawMaterialFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WIPRawMaterialPayload>[]
          }
          create: {
            args: Prisma.WIPRawMaterialCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WIPRawMaterialPayload>
          }
          createMany: {
            args: Prisma.WIPRawMaterialCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.WIPRawMaterialDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WIPRawMaterialPayload>
          }
          update: {
            args: Prisma.WIPRawMaterialUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WIPRawMaterialPayload>
          }
          deleteMany: {
            args: Prisma.WIPRawMaterialDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WIPRawMaterialUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.WIPRawMaterialUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WIPRawMaterialPayload>
          }
          aggregate: {
            args: Prisma.WIPRawMaterialAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWIPRawMaterial>
          }
          groupBy: {
            args: Prisma.WIPRawMaterialGroupByArgs<ExtArgs>
            result: $Utils.Optional<WIPRawMaterialGroupByOutputType>[]
          }
          count: {
            args: Prisma.WIPRawMaterialCountArgs<ExtArgs>
            result: $Utils.Optional<WIPRawMaterialCountAggregateOutputType> | number
          }
        }
      }
      FG: {
        payload: Prisma.$FGPayload<ExtArgs>
        fields: Prisma.FGFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FGFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FGPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FGFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FGPayload>
          }
          findFirst: {
            args: Prisma.FGFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FGPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FGFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FGPayload>
          }
          findMany: {
            args: Prisma.FGFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FGPayload>[]
          }
          create: {
            args: Prisma.FGCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FGPayload>
          }
          createMany: {
            args: Prisma.FGCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.FGDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FGPayload>
          }
          update: {
            args: Prisma.FGUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FGPayload>
          }
          deleteMany: {
            args: Prisma.FGDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FGUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.FGUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FGPayload>
          }
          aggregate: {
            args: Prisma.FGAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFG>
          }
          groupBy: {
            args: Prisma.FGGroupByArgs<ExtArgs>
            result: $Utils.Optional<FGGroupByOutputType>[]
          }
          count: {
            args: Prisma.FGCountArgs<ExtArgs>
            result: $Utils.Optional<FGCountAggregateOutputType> | number
          }
        }
      }
      FG_PRODUCTS: {
        payload: Prisma.$FG_PRODUCTSPayload<ExtArgs>
        fields: Prisma.FG_PRODUCTSFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FG_PRODUCTSFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FG_PRODUCTSPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FG_PRODUCTSFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FG_PRODUCTSPayload>
          }
          findFirst: {
            args: Prisma.FG_PRODUCTSFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FG_PRODUCTSPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FG_PRODUCTSFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FG_PRODUCTSPayload>
          }
          findMany: {
            args: Prisma.FG_PRODUCTSFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FG_PRODUCTSPayload>[]
          }
          create: {
            args: Prisma.FG_PRODUCTSCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FG_PRODUCTSPayload>
          }
          createMany: {
            args: Prisma.FG_PRODUCTSCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.FG_PRODUCTSDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FG_PRODUCTSPayload>
          }
          update: {
            args: Prisma.FG_PRODUCTSUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FG_PRODUCTSPayload>
          }
          deleteMany: {
            args: Prisma.FG_PRODUCTSDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FG_PRODUCTSUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.FG_PRODUCTSUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FG_PRODUCTSPayload>
          }
          aggregate: {
            args: Prisma.FG_PRODUCTSAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFG_PRODUCTS>
          }
          groupBy: {
            args: Prisma.FG_PRODUCTSGroupByArgs<ExtArgs>
            result: $Utils.Optional<FG_PRODUCTSGroupByOutputType>[]
          }
          count: {
            args: Prisma.FG_PRODUCTSCountArgs<ExtArgs>
            result: $Utils.Optional<FG_PRODUCTSCountAggregateOutputType> | number
          }
        }
      }
      WIP_TRANSACTIONS: {
        payload: Prisma.$WIP_TRANSACTIONSPayload<ExtArgs>
        fields: Prisma.WIP_TRANSACTIONSFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WIP_TRANSACTIONSFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WIP_TRANSACTIONSPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WIP_TRANSACTIONSFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WIP_TRANSACTIONSPayload>
          }
          findFirst: {
            args: Prisma.WIP_TRANSACTIONSFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WIP_TRANSACTIONSPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WIP_TRANSACTIONSFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WIP_TRANSACTIONSPayload>
          }
          findMany: {
            args: Prisma.WIP_TRANSACTIONSFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WIP_TRANSACTIONSPayload>[]
          }
          create: {
            args: Prisma.WIP_TRANSACTIONSCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WIP_TRANSACTIONSPayload>
          }
          createMany: {
            args: Prisma.WIP_TRANSACTIONSCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.WIP_TRANSACTIONSDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WIP_TRANSACTIONSPayload>
          }
          update: {
            args: Prisma.WIP_TRANSACTIONSUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WIP_TRANSACTIONSPayload>
          }
          deleteMany: {
            args: Prisma.WIP_TRANSACTIONSDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WIP_TRANSACTIONSUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.WIP_TRANSACTIONSUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WIP_TRANSACTIONSPayload>
          }
          aggregate: {
            args: Prisma.WIP_TRANSACTIONSAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWIP_TRANSACTIONS>
          }
          groupBy: {
            args: Prisma.WIP_TRANSACTIONSGroupByArgs<ExtArgs>
            result: $Utils.Optional<WIP_TRANSACTIONSGroupByOutputType>[]
          }
          count: {
            args: Prisma.WIP_TRANSACTIONSCountArgs<ExtArgs>
            result: $Utils.Optional<WIP_TRANSACTIONSCountAggregateOutputType> | number
          }
        }
      }
      FG_TRANSACTIONS: {
        payload: Prisma.$FG_TRANSACTIONSPayload<ExtArgs>
        fields: Prisma.FG_TRANSACTIONSFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FG_TRANSACTIONSFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FG_TRANSACTIONSPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FG_TRANSACTIONSFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FG_TRANSACTIONSPayload>
          }
          findFirst: {
            args: Prisma.FG_TRANSACTIONSFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FG_TRANSACTIONSPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FG_TRANSACTIONSFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FG_TRANSACTIONSPayload>
          }
          findMany: {
            args: Prisma.FG_TRANSACTIONSFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FG_TRANSACTIONSPayload>[]
          }
          create: {
            args: Prisma.FG_TRANSACTIONSCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FG_TRANSACTIONSPayload>
          }
          createMany: {
            args: Prisma.FG_TRANSACTIONSCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.FG_TRANSACTIONSDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FG_TRANSACTIONSPayload>
          }
          update: {
            args: Prisma.FG_TRANSACTIONSUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FG_TRANSACTIONSPayload>
          }
          deleteMany: {
            args: Prisma.FG_TRANSACTIONSDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FG_TRANSACTIONSUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.FG_TRANSACTIONSUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FG_TRANSACTIONSPayload>
          }
          aggregate: {
            args: Prisma.FG_TRANSACTIONSAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFG_TRANSACTIONS>
          }
          groupBy: {
            args: Prisma.FG_TRANSACTIONSGroupByArgs<ExtArgs>
            result: $Utils.Optional<FG_TRANSACTIONSGroupByOutputType>[]
          }
          count: {
            args: Prisma.FG_TRANSACTIONSCountArgs<ExtArgs>
            result: $Utils.Optional<FG_TRANSACTIONSCountAggregateOutputType> | number
          }
        }
      }
      WIP_QC: {
        payload: Prisma.$WIP_QCPayload<ExtArgs>
        fields: Prisma.WIP_QCFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WIP_QCFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WIP_QCPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WIP_QCFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WIP_QCPayload>
          }
          findFirst: {
            args: Prisma.WIP_QCFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WIP_QCPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WIP_QCFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WIP_QCPayload>
          }
          findMany: {
            args: Prisma.WIP_QCFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WIP_QCPayload>[]
          }
          create: {
            args: Prisma.WIP_QCCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WIP_QCPayload>
          }
          createMany: {
            args: Prisma.WIP_QCCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.WIP_QCDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WIP_QCPayload>
          }
          update: {
            args: Prisma.WIP_QCUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WIP_QCPayload>
          }
          deleteMany: {
            args: Prisma.WIP_QCDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WIP_QCUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.WIP_QCUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WIP_QCPayload>
          }
          aggregate: {
            args: Prisma.WIP_QCAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWIP_QC>
          }
          groupBy: {
            args: Prisma.WIP_QCGroupByArgs<ExtArgs>
            result: $Utils.Optional<WIP_QCGroupByOutputType>[]
          }
          count: {
            args: Prisma.WIP_QCCountArgs<ExtArgs>
            result: $Utils.Optional<WIP_QCCountAggregateOutputType> | number
          }
        }
      }
      FG_QC: {
        payload: Prisma.$FG_QCPayload<ExtArgs>
        fields: Prisma.FG_QCFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FG_QCFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FG_QCPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FG_QCFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FG_QCPayload>
          }
          findFirst: {
            args: Prisma.FG_QCFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FG_QCPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FG_QCFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FG_QCPayload>
          }
          findMany: {
            args: Prisma.FG_QCFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FG_QCPayload>[]
          }
          create: {
            args: Prisma.FG_QCCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FG_QCPayload>
          }
          createMany: {
            args: Prisma.FG_QCCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.FG_QCDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FG_QCPayload>
          }
          update: {
            args: Prisma.FG_QCUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FG_QCPayload>
          }
          deleteMany: {
            args: Prisma.FG_QCDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FG_QCUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.FG_QCUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FG_QCPayload>
          }
          aggregate: {
            args: Prisma.FG_QCAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFG_QC>
          }
          groupBy: {
            args: Prisma.FG_QCGroupByArgs<ExtArgs>
            result: $Utils.Optional<FG_QCGroupByOutputType>[]
          }
          count: {
            args: Prisma.FG_QCCountArgs<ExtArgs>
            result: $Utils.Optional<FG_QCCountAggregateOutputType> | number
          }
        }
      }
      WIP_WASTAGE_LOGS: {
        payload: Prisma.$WIP_WASTAGE_LOGSPayload<ExtArgs>
        fields: Prisma.WIP_WASTAGE_LOGSFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WIP_WASTAGE_LOGSFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WIP_WASTAGE_LOGSPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WIP_WASTAGE_LOGSFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WIP_WASTAGE_LOGSPayload>
          }
          findFirst: {
            args: Prisma.WIP_WASTAGE_LOGSFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WIP_WASTAGE_LOGSPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WIP_WASTAGE_LOGSFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WIP_WASTAGE_LOGSPayload>
          }
          findMany: {
            args: Prisma.WIP_WASTAGE_LOGSFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WIP_WASTAGE_LOGSPayload>[]
          }
          create: {
            args: Prisma.WIP_WASTAGE_LOGSCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WIP_WASTAGE_LOGSPayload>
          }
          createMany: {
            args: Prisma.WIP_WASTAGE_LOGSCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.WIP_WASTAGE_LOGSDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WIP_WASTAGE_LOGSPayload>
          }
          update: {
            args: Prisma.WIP_WASTAGE_LOGSUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WIP_WASTAGE_LOGSPayload>
          }
          deleteMany: {
            args: Prisma.WIP_WASTAGE_LOGSDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WIP_WASTAGE_LOGSUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.WIP_WASTAGE_LOGSUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WIP_WASTAGE_LOGSPayload>
          }
          aggregate: {
            args: Prisma.WIP_WASTAGE_LOGSAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWIP_WASTAGE_LOGS>
          }
          groupBy: {
            args: Prisma.WIP_WASTAGE_LOGSGroupByArgs<ExtArgs>
            result: $Utils.Optional<WIP_WASTAGE_LOGSGroupByOutputType>[]
          }
          count: {
            args: Prisma.WIP_WASTAGE_LOGSCountArgs<ExtArgs>
            result: $Utils.Optional<WIP_WASTAGE_LOGSCountAggregateOutputType> | number
          }
        }
      }
      FG_WASTAGE_LOGS: {
        payload: Prisma.$FG_WASTAGE_LOGSPayload<ExtArgs>
        fields: Prisma.FG_WASTAGE_LOGSFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FG_WASTAGE_LOGSFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FG_WASTAGE_LOGSPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FG_WASTAGE_LOGSFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FG_WASTAGE_LOGSPayload>
          }
          findFirst: {
            args: Prisma.FG_WASTAGE_LOGSFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FG_WASTAGE_LOGSPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FG_WASTAGE_LOGSFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FG_WASTAGE_LOGSPayload>
          }
          findMany: {
            args: Prisma.FG_WASTAGE_LOGSFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FG_WASTAGE_LOGSPayload>[]
          }
          create: {
            args: Prisma.FG_WASTAGE_LOGSCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FG_WASTAGE_LOGSPayload>
          }
          createMany: {
            args: Prisma.FG_WASTAGE_LOGSCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.FG_WASTAGE_LOGSDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FG_WASTAGE_LOGSPayload>
          }
          update: {
            args: Prisma.FG_WASTAGE_LOGSUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FG_WASTAGE_LOGSPayload>
          }
          deleteMany: {
            args: Prisma.FG_WASTAGE_LOGSDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FG_WASTAGE_LOGSUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.FG_WASTAGE_LOGSUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FG_WASTAGE_LOGSPayload>
          }
          aggregate: {
            args: Prisma.FG_WASTAGE_LOGSAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFG_WASTAGE_LOGS>
          }
          groupBy: {
            args: Prisma.FG_WASTAGE_LOGSGroupByArgs<ExtArgs>
            result: $Utils.Optional<FG_WASTAGE_LOGSGroupByOutputType>[]
          }
          count: {
            args: Prisma.FG_WASTAGE_LOGSCountArgs<ExtArgs>
            result: $Utils.Optional<FG_WASTAGE_LOGSCountAggregateOutputType> | number
          }
        }
      }
      AuditLogs: {
        payload: Prisma.$AuditLogsPayload<ExtArgs>
        fields: Prisma.AuditLogsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AuditLogsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AuditLogsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogsPayload>
          }
          findFirst: {
            args: Prisma.AuditLogsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AuditLogsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogsPayload>
          }
          findMany: {
            args: Prisma.AuditLogsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogsPayload>[]
          }
          create: {
            args: Prisma.AuditLogsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogsPayload>
          }
          createMany: {
            args: Prisma.AuditLogsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.AuditLogsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogsPayload>
          }
          update: {
            args: Prisma.AuditLogsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogsPayload>
          }
          deleteMany: {
            args: Prisma.AuditLogsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AuditLogsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AuditLogsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogsPayload>
          }
          aggregate: {
            args: Prisma.AuditLogsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAuditLogs>
          }
          groupBy: {
            args: Prisma.AuditLogsGroupByArgs<ExtArgs>
            result: $Utils.Optional<AuditLogsGroupByOutputType>[]
          }
          count: {
            args: Prisma.AuditLogsCountArgs<ExtArgs>
            result: $Utils.Optional<AuditLogsCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    rAW_MATERIALS?: RAW_MATERIALSOmit
    sHOPIFY_VARIANTS?: SHOPIFY_VARIANTSOmit
    vARIANT_RAW_MATERIALS_TRACKER?: VARIANT_RAW_MATERIALS_TRACKEROmit
    cATEGORIES?: CATEGORIESOmit
    sHOPIFY_PRODUCTS?: SHOPIFY_PRODUCTSOmit
    rM_TRANSACTIONS?: RM_TRANSACTIONSOmit
    rM_QC?: RM_QCOmit
    rM_WASTAGE_LOGS?: RM_WASTAGE_LOGSOmit
    employee?: EmployeeOmit
    wIP?: WIPOmit
    wIP_PRODUCTS?: WIP_PRODUCTSOmit
    wIPRawMaterial?: WIPRawMaterialOmit
    fG?: FGOmit
    fG_PRODUCTS?: FG_PRODUCTSOmit
    wIP_TRANSACTIONS?: WIP_TRANSACTIONSOmit
    fG_TRANSACTIONS?: FG_TRANSACTIONSOmit
    wIP_QC?: WIP_QCOmit
    fG_QC?: FG_QCOmit
    wIP_WASTAGE_LOGS?: WIP_WASTAGE_LOGSOmit
    fG_WASTAGE_LOGS?: FG_WASTAGE_LOGSOmit
    auditLogs?: AuditLogsOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type RAW_MATERIALSCountOutputType
   */

  export type RAW_MATERIALSCountOutputType = {
    VariantMaterials: number
    RMTransactions: number
    RMQualityChecks: number
    RMWastageLogs: number
    WIPMaterials: number
  }

  export type RAW_MATERIALSCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    VariantMaterials?: boolean | RAW_MATERIALSCountOutputTypeCountVariantMaterialsArgs
    RMTransactions?: boolean | RAW_MATERIALSCountOutputTypeCountRMTransactionsArgs
    RMQualityChecks?: boolean | RAW_MATERIALSCountOutputTypeCountRMQualityChecksArgs
    RMWastageLogs?: boolean | RAW_MATERIALSCountOutputTypeCountRMWastageLogsArgs
    WIPMaterials?: boolean | RAW_MATERIALSCountOutputTypeCountWIPMaterialsArgs
  }

  // Custom InputTypes
  /**
   * RAW_MATERIALSCountOutputType without action
   */
  export type RAW_MATERIALSCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RAW_MATERIALSCountOutputType
     */
    select?: RAW_MATERIALSCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * RAW_MATERIALSCountOutputType without action
   */
  export type RAW_MATERIALSCountOutputTypeCountVariantMaterialsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VARIANT_RAW_MATERIALS_TRACKERWhereInput
  }

  /**
   * RAW_MATERIALSCountOutputType without action
   */
  export type RAW_MATERIALSCountOutputTypeCountRMTransactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RM_TRANSACTIONSWhereInput
  }

  /**
   * RAW_MATERIALSCountOutputType without action
   */
  export type RAW_MATERIALSCountOutputTypeCountRMQualityChecksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RM_QCWhereInput
  }

  /**
   * RAW_MATERIALSCountOutputType without action
   */
  export type RAW_MATERIALSCountOutputTypeCountRMWastageLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RM_WASTAGE_LOGSWhereInput
  }

  /**
   * RAW_MATERIALSCountOutputType without action
   */
  export type RAW_MATERIALSCountOutputTypeCountWIPMaterialsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WIPRawMaterialWhereInput
  }


  /**
   * Count Type SHOPIFY_VARIANTSCountOutputType
   */

  export type SHOPIFY_VARIANTSCountOutputType = {
    VariantMaterials: number
  }

  export type SHOPIFY_VARIANTSCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    VariantMaterials?: boolean | SHOPIFY_VARIANTSCountOutputTypeCountVariantMaterialsArgs
  }

  // Custom InputTypes
  /**
   * SHOPIFY_VARIANTSCountOutputType without action
   */
  export type SHOPIFY_VARIANTSCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SHOPIFY_VARIANTSCountOutputType
     */
    select?: SHOPIFY_VARIANTSCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SHOPIFY_VARIANTSCountOutputType without action
   */
  export type SHOPIFY_VARIANTSCountOutputTypeCountVariantMaterialsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VARIANT_RAW_MATERIALS_TRACKERWhereInput
  }


  /**
   * Count Type CATEGORIESCountOutputType
   */

  export type CATEGORIESCountOutputType = {
    ShopifyProducts: number
  }

  export type CATEGORIESCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ShopifyProducts?: boolean | CATEGORIESCountOutputTypeCountShopifyProductsArgs
  }

  // Custom InputTypes
  /**
   * CATEGORIESCountOutputType without action
   */
  export type CATEGORIESCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CATEGORIESCountOutputType
     */
    select?: CATEGORIESCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CATEGORIESCountOutputType without action
   */
  export type CATEGORIESCountOutputTypeCountShopifyProductsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SHOPIFY_PRODUCTSWhereInput
  }


  /**
   * Count Type SHOPIFY_PRODUCTSCountOutputType
   */

  export type SHOPIFY_PRODUCTSCountOutputType = {
    ShopifyVariants: number
    WIPProducts: number
  }

  export type SHOPIFY_PRODUCTSCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ShopifyVariants?: boolean | SHOPIFY_PRODUCTSCountOutputTypeCountShopifyVariantsArgs
    WIPProducts?: boolean | SHOPIFY_PRODUCTSCountOutputTypeCountWIPProductsArgs
  }

  // Custom InputTypes
  /**
   * SHOPIFY_PRODUCTSCountOutputType without action
   */
  export type SHOPIFY_PRODUCTSCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SHOPIFY_PRODUCTSCountOutputType
     */
    select?: SHOPIFY_PRODUCTSCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SHOPIFY_PRODUCTSCountOutputType without action
   */
  export type SHOPIFY_PRODUCTSCountOutputTypeCountShopifyVariantsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SHOPIFY_VARIANTSWhereInput
  }

  /**
   * SHOPIFY_PRODUCTSCountOutputType without action
   */
  export type SHOPIFY_PRODUCTSCountOutputTypeCountWIPProductsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WIP_PRODUCTSWhereInput
  }


  /**
   * Count Type RM_TRANSACTIONSCountOutputType
   */

  export type RM_TRANSACTIONSCountOutputType = {
    RMQualityChecks: number
    RMWastageLogs: number
  }

  export type RM_TRANSACTIONSCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    RMQualityChecks?: boolean | RM_TRANSACTIONSCountOutputTypeCountRMQualityChecksArgs
    RMWastageLogs?: boolean | RM_TRANSACTIONSCountOutputTypeCountRMWastageLogsArgs
  }

  // Custom InputTypes
  /**
   * RM_TRANSACTIONSCountOutputType without action
   */
  export type RM_TRANSACTIONSCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RM_TRANSACTIONSCountOutputType
     */
    select?: RM_TRANSACTIONSCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * RM_TRANSACTIONSCountOutputType without action
   */
  export type RM_TRANSACTIONSCountOutputTypeCountRMQualityChecksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RM_QCWhereInput
  }

  /**
   * RM_TRANSACTIONSCountOutputType without action
   */
  export type RM_TRANSACTIONSCountOutputTypeCountRMWastageLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RM_WASTAGE_LOGSWhereInput
  }


  /**
   * Count Type EmployeeCountOutputType
   */

  export type EmployeeCountOutputType = {
    RM_QC: number
    RM_QC2: number
    RMTransactions: number
    WIPTransactions: number
    FGTransactions: number
    AuditLogs: number
  }

  export type EmployeeCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    RM_QC?: boolean | EmployeeCountOutputTypeCountRM_QCArgs
    RM_QC2?: boolean | EmployeeCountOutputTypeCountRM_QC2Args
    RMTransactions?: boolean | EmployeeCountOutputTypeCountRMTransactionsArgs
    WIPTransactions?: boolean | EmployeeCountOutputTypeCountWIPTransactionsArgs
    FGTransactions?: boolean | EmployeeCountOutputTypeCountFGTransactionsArgs
    AuditLogs?: boolean | EmployeeCountOutputTypeCountAuditLogsArgs
  }

  // Custom InputTypes
  /**
   * EmployeeCountOutputType without action
   */
  export type EmployeeCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeCountOutputType
     */
    select?: EmployeeCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * EmployeeCountOutputType without action
   */
  export type EmployeeCountOutputTypeCountRM_QCArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RM_QCWhereInput
  }

  /**
   * EmployeeCountOutputType without action
   */
  export type EmployeeCountOutputTypeCountRM_QC2Args<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RM_QCWhereInput
  }

  /**
   * EmployeeCountOutputType without action
   */
  export type EmployeeCountOutputTypeCountRMTransactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RM_TRANSACTIONSWhereInput
  }

  /**
   * EmployeeCountOutputType without action
   */
  export type EmployeeCountOutputTypeCountWIPTransactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WIP_TRANSACTIONSWhereInput
  }

  /**
   * EmployeeCountOutputType without action
   */
  export type EmployeeCountOutputTypeCountFGTransactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FG_TRANSACTIONSWhereInput
  }

  /**
   * EmployeeCountOutputType without action
   */
  export type EmployeeCountOutputTypeCountAuditLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuditLogsWhereInput
  }


  /**
   * Count Type WIPCountOutputType
   */

  export type WIPCountOutputType = {
    WIPTransactions: number
    WIPQCs: number
    WIPWastageLogs: number
    wipProducts: number
    WIPMaterials: number
  }

  export type WIPCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    WIPTransactions?: boolean | WIPCountOutputTypeCountWIPTransactionsArgs
    WIPQCs?: boolean | WIPCountOutputTypeCountWIPQCsArgs
    WIPWastageLogs?: boolean | WIPCountOutputTypeCountWIPWastageLogsArgs
    wipProducts?: boolean | WIPCountOutputTypeCountWipProductsArgs
    WIPMaterials?: boolean | WIPCountOutputTypeCountWIPMaterialsArgs
  }

  // Custom InputTypes
  /**
   * WIPCountOutputType without action
   */
  export type WIPCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WIPCountOutputType
     */
    select?: WIPCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * WIPCountOutputType without action
   */
  export type WIPCountOutputTypeCountWIPTransactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WIP_TRANSACTIONSWhereInput
  }

  /**
   * WIPCountOutputType without action
   */
  export type WIPCountOutputTypeCountWIPQCsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WIP_QCWhereInput
  }

  /**
   * WIPCountOutputType without action
   */
  export type WIPCountOutputTypeCountWIPWastageLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WIP_WASTAGE_LOGSWhereInput
  }

  /**
   * WIPCountOutputType without action
   */
  export type WIPCountOutputTypeCountWipProductsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WIP_PRODUCTSWhereInput
  }

  /**
   * WIPCountOutputType without action
   */
  export type WIPCountOutputTypeCountWIPMaterialsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WIPRawMaterialWhereInput
  }


  /**
   * Count Type FGCountOutputType
   */

  export type FGCountOutputType = {
    FGTransactions: number
    FGQCs: number
    FGWastageLogs: number
    fgProducts: number
  }

  export type FGCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    FGTransactions?: boolean | FGCountOutputTypeCountFGTransactionsArgs
    FGQCs?: boolean | FGCountOutputTypeCountFGQCsArgs
    FGWastageLogs?: boolean | FGCountOutputTypeCountFGWastageLogsArgs
    fgProducts?: boolean | FGCountOutputTypeCountFgProductsArgs
  }

  // Custom InputTypes
  /**
   * FGCountOutputType without action
   */
  export type FGCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FGCountOutputType
     */
    select?: FGCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * FGCountOutputType without action
   */
  export type FGCountOutputTypeCountFGTransactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FG_TRANSACTIONSWhereInput
  }

  /**
   * FGCountOutputType without action
   */
  export type FGCountOutputTypeCountFGQCsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FG_QCWhereInput
  }

  /**
   * FGCountOutputType without action
   */
  export type FGCountOutputTypeCountFGWastageLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FG_WASTAGE_LOGSWhereInput
  }

  /**
   * FGCountOutputType without action
   */
  export type FGCountOutputTypeCountFgProductsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FG_PRODUCTSWhereInput
  }


  /**
   * Count Type WIP_TRANSACTIONSCountOutputType
   */

  export type WIP_TRANSACTIONSCountOutputType = {
    wipQC: number
    wipWasteLogs: number
  }

  export type WIP_TRANSACTIONSCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    wipQC?: boolean | WIP_TRANSACTIONSCountOutputTypeCountWipQCArgs
    wipWasteLogs?: boolean | WIP_TRANSACTIONSCountOutputTypeCountWipWasteLogsArgs
  }

  // Custom InputTypes
  /**
   * WIP_TRANSACTIONSCountOutputType without action
   */
  export type WIP_TRANSACTIONSCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WIP_TRANSACTIONSCountOutputType
     */
    select?: WIP_TRANSACTIONSCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * WIP_TRANSACTIONSCountOutputType without action
   */
  export type WIP_TRANSACTIONSCountOutputTypeCountWipQCArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WIP_QCWhereInput
  }

  /**
   * WIP_TRANSACTIONSCountOutputType without action
   */
  export type WIP_TRANSACTIONSCountOutputTypeCountWipWasteLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WIP_WASTAGE_LOGSWhereInput
  }


  /**
   * Count Type FG_TRANSACTIONSCountOutputType
   */

  export type FG_TRANSACTIONSCountOutputType = {
    fgQC: number
    fgWasteLogs: number
  }

  export type FG_TRANSACTIONSCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    fgQC?: boolean | FG_TRANSACTIONSCountOutputTypeCountFgQCArgs
    fgWasteLogs?: boolean | FG_TRANSACTIONSCountOutputTypeCountFgWasteLogsArgs
  }

  // Custom InputTypes
  /**
   * FG_TRANSACTIONSCountOutputType without action
   */
  export type FG_TRANSACTIONSCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FG_TRANSACTIONSCountOutputType
     */
    select?: FG_TRANSACTIONSCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * FG_TRANSACTIONSCountOutputType without action
   */
  export type FG_TRANSACTIONSCountOutputTypeCountFgQCArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FG_QCWhereInput
  }

  /**
   * FG_TRANSACTIONSCountOutputType without action
   */
  export type FG_TRANSACTIONSCountOutputTypeCountFgWasteLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FG_WASTAGE_LOGSWhereInput
  }


  /**
   * Models
   */

  /**
   * Model RAW_MATERIALS
   */

  export type AggregateRAW_MATERIALS = {
    _count: RAW_MATERIALSCountAggregateOutputType | null
    _avg: RAW_MATERIALSAvgAggregateOutputType | null
    _sum: RAW_MATERIALSSumAggregateOutputType | null
    _min: RAW_MATERIALSMinAggregateOutputType | null
    _max: RAW_MATERIALSMaxAggregateOutputType | null
  }

  export type RAW_MATERIALSAvgAggregateOutputType = {
    id: number | null
    quantity: number | null
    price: Decimal | null
  }

  export type RAW_MATERIALSSumAggregateOutputType = {
    id: bigint | null
    quantity: number | null
    price: Decimal | null
  }

  export type RAW_MATERIALSMinAggregateOutputType = {
    id: bigint | null
    name: string | null
    SKU: string | null
    quantity: number | null
    price: Decimal | null
    image: string | null
    description: string | null
    expiry_date: Date | null
    quality_status: $Enums.QualityStatus | null
    storage_location: string | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type RAW_MATERIALSMaxAggregateOutputType = {
    id: bigint | null
    name: string | null
    SKU: string | null
    quantity: number | null
    price: Decimal | null
    image: string | null
    description: string | null
    expiry_date: Date | null
    quality_status: $Enums.QualityStatus | null
    storage_location: string | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type RAW_MATERIALSCountAggregateOutputType = {
    id: number
    name: number
    SKU: number
    quantity: number
    price: number
    image: number
    description: number
    expiry_date: number
    quality_status: number
    storage_location: number
    createdAt: number
    updatedAt: number
    deletedAt: number
    _all: number
  }


  export type RAW_MATERIALSAvgAggregateInputType = {
    id?: true
    quantity?: true
    price?: true
  }

  export type RAW_MATERIALSSumAggregateInputType = {
    id?: true
    quantity?: true
    price?: true
  }

  export type RAW_MATERIALSMinAggregateInputType = {
    id?: true
    name?: true
    SKU?: true
    quantity?: true
    price?: true
    image?: true
    description?: true
    expiry_date?: true
    quality_status?: true
    storage_location?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type RAW_MATERIALSMaxAggregateInputType = {
    id?: true
    name?: true
    SKU?: true
    quantity?: true
    price?: true
    image?: true
    description?: true
    expiry_date?: true
    quality_status?: true
    storage_location?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type RAW_MATERIALSCountAggregateInputType = {
    id?: true
    name?: true
    SKU?: true
    quantity?: true
    price?: true
    image?: true
    description?: true
    expiry_date?: true
    quality_status?: true
    storage_location?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
    _all?: true
  }

  export type RAW_MATERIALSAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RAW_MATERIALS to aggregate.
     */
    where?: RAW_MATERIALSWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RAW_MATERIALS to fetch.
     */
    orderBy?: RAW_MATERIALSOrderByWithRelationInput | RAW_MATERIALSOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RAW_MATERIALSWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RAW_MATERIALS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RAW_MATERIALS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RAW_MATERIALS
    **/
    _count?: true | RAW_MATERIALSCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RAW_MATERIALSAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RAW_MATERIALSSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RAW_MATERIALSMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RAW_MATERIALSMaxAggregateInputType
  }

  export type GetRAW_MATERIALSAggregateType<T extends RAW_MATERIALSAggregateArgs> = {
        [P in keyof T & keyof AggregateRAW_MATERIALS]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRAW_MATERIALS[P]>
      : GetScalarType<T[P], AggregateRAW_MATERIALS[P]>
  }




  export type RAW_MATERIALSGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RAW_MATERIALSWhereInput
    orderBy?: RAW_MATERIALSOrderByWithAggregationInput | RAW_MATERIALSOrderByWithAggregationInput[]
    by: RAW_MATERIALSScalarFieldEnum[] | RAW_MATERIALSScalarFieldEnum
    having?: RAW_MATERIALSScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RAW_MATERIALSCountAggregateInputType | true
    _avg?: RAW_MATERIALSAvgAggregateInputType
    _sum?: RAW_MATERIALSSumAggregateInputType
    _min?: RAW_MATERIALSMinAggregateInputType
    _max?: RAW_MATERIALSMaxAggregateInputType
  }

  export type RAW_MATERIALSGroupByOutputType = {
    id: bigint
    name: string
    SKU: string
    quantity: number
    price: Decimal
    image: string | null
    description: string | null
    expiry_date: Date
    quality_status: $Enums.QualityStatus
    storage_location: string
    createdAt: Date
    updatedAt: Date
    deletedAt: Date | null
    _count: RAW_MATERIALSCountAggregateOutputType | null
    _avg: RAW_MATERIALSAvgAggregateOutputType | null
    _sum: RAW_MATERIALSSumAggregateOutputType | null
    _min: RAW_MATERIALSMinAggregateOutputType | null
    _max: RAW_MATERIALSMaxAggregateOutputType | null
  }

  type GetRAW_MATERIALSGroupByPayload<T extends RAW_MATERIALSGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RAW_MATERIALSGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RAW_MATERIALSGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RAW_MATERIALSGroupByOutputType[P]>
            : GetScalarType<T[P], RAW_MATERIALSGroupByOutputType[P]>
        }
      >
    >


  export type RAW_MATERIALSSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    SKU?: boolean
    quantity?: boolean
    price?: boolean
    image?: boolean
    description?: boolean
    expiry_date?: boolean
    quality_status?: boolean
    storage_location?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    VariantMaterials?: boolean | RAW_MATERIALS$VariantMaterialsArgs<ExtArgs>
    RMTransactions?: boolean | RAW_MATERIALS$RMTransactionsArgs<ExtArgs>
    RMQualityChecks?: boolean | RAW_MATERIALS$RMQualityChecksArgs<ExtArgs>
    RMWastageLogs?: boolean | RAW_MATERIALS$RMWastageLogsArgs<ExtArgs>
    WIPMaterials?: boolean | RAW_MATERIALS$WIPMaterialsArgs<ExtArgs>
    _count?: boolean | RAW_MATERIALSCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["rAW_MATERIALS"]>



  export type RAW_MATERIALSSelectScalar = {
    id?: boolean
    name?: boolean
    SKU?: boolean
    quantity?: boolean
    price?: boolean
    image?: boolean
    description?: boolean
    expiry_date?: boolean
    quality_status?: boolean
    storage_location?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
  }

  export type RAW_MATERIALSOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "SKU" | "quantity" | "price" | "image" | "description" | "expiry_date" | "quality_status" | "storage_location" | "createdAt" | "updatedAt" | "deletedAt", ExtArgs["result"]["rAW_MATERIALS"]>
  export type RAW_MATERIALSInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    VariantMaterials?: boolean | RAW_MATERIALS$VariantMaterialsArgs<ExtArgs>
    RMTransactions?: boolean | RAW_MATERIALS$RMTransactionsArgs<ExtArgs>
    RMQualityChecks?: boolean | RAW_MATERIALS$RMQualityChecksArgs<ExtArgs>
    RMWastageLogs?: boolean | RAW_MATERIALS$RMWastageLogsArgs<ExtArgs>
    WIPMaterials?: boolean | RAW_MATERIALS$WIPMaterialsArgs<ExtArgs>
    _count?: boolean | RAW_MATERIALSCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $RAW_MATERIALSPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RAW_MATERIALS"
    objects: {
      VariantMaterials: Prisma.$VARIANT_RAW_MATERIALS_TRACKERPayload<ExtArgs>[]
      RMTransactions: Prisma.$RM_TRANSACTIONSPayload<ExtArgs>[]
      RMQualityChecks: Prisma.$RM_QCPayload<ExtArgs>[]
      RMWastageLogs: Prisma.$RM_WASTAGE_LOGSPayload<ExtArgs>[]
      WIPMaterials: Prisma.$WIPRawMaterialPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: bigint
      name: string
      SKU: string
      quantity: number
      price: Prisma.Decimal
      image: string | null
      description: string | null
      expiry_date: Date
      quality_status: $Enums.QualityStatus
      storage_location: string
      createdAt: Date
      updatedAt: Date
      deletedAt: Date | null
    }, ExtArgs["result"]["rAW_MATERIALS"]>
    composites: {}
  }

  type RAW_MATERIALSGetPayload<S extends boolean | null | undefined | RAW_MATERIALSDefaultArgs> = $Result.GetResult<Prisma.$RAW_MATERIALSPayload, S>

  type RAW_MATERIALSCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RAW_MATERIALSFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RAW_MATERIALSCountAggregateInputType | true
    }

  export interface RAW_MATERIALSDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RAW_MATERIALS'], meta: { name: 'RAW_MATERIALS' } }
    /**
     * Find zero or one RAW_MATERIALS that matches the filter.
     * @param {RAW_MATERIALSFindUniqueArgs} args - Arguments to find a RAW_MATERIALS
     * @example
     * // Get one RAW_MATERIALS
     * const rAW_MATERIALS = await prisma.rAW_MATERIALS.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RAW_MATERIALSFindUniqueArgs>(args: SelectSubset<T, RAW_MATERIALSFindUniqueArgs<ExtArgs>>): Prisma__RAW_MATERIALSClient<$Result.GetResult<Prisma.$RAW_MATERIALSPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one RAW_MATERIALS that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RAW_MATERIALSFindUniqueOrThrowArgs} args - Arguments to find a RAW_MATERIALS
     * @example
     * // Get one RAW_MATERIALS
     * const rAW_MATERIALS = await prisma.rAW_MATERIALS.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RAW_MATERIALSFindUniqueOrThrowArgs>(args: SelectSubset<T, RAW_MATERIALSFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RAW_MATERIALSClient<$Result.GetResult<Prisma.$RAW_MATERIALSPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first RAW_MATERIALS that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RAW_MATERIALSFindFirstArgs} args - Arguments to find a RAW_MATERIALS
     * @example
     * // Get one RAW_MATERIALS
     * const rAW_MATERIALS = await prisma.rAW_MATERIALS.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RAW_MATERIALSFindFirstArgs>(args?: SelectSubset<T, RAW_MATERIALSFindFirstArgs<ExtArgs>>): Prisma__RAW_MATERIALSClient<$Result.GetResult<Prisma.$RAW_MATERIALSPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first RAW_MATERIALS that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RAW_MATERIALSFindFirstOrThrowArgs} args - Arguments to find a RAW_MATERIALS
     * @example
     * // Get one RAW_MATERIALS
     * const rAW_MATERIALS = await prisma.rAW_MATERIALS.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RAW_MATERIALSFindFirstOrThrowArgs>(args?: SelectSubset<T, RAW_MATERIALSFindFirstOrThrowArgs<ExtArgs>>): Prisma__RAW_MATERIALSClient<$Result.GetResult<Prisma.$RAW_MATERIALSPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more RAW_MATERIALS that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RAW_MATERIALSFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RAW_MATERIALS
     * const rAW_MATERIALS = await prisma.rAW_MATERIALS.findMany()
     * 
     * // Get first 10 RAW_MATERIALS
     * const rAW_MATERIALS = await prisma.rAW_MATERIALS.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const rAW_MATERIALSWithIdOnly = await prisma.rAW_MATERIALS.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RAW_MATERIALSFindManyArgs>(args?: SelectSubset<T, RAW_MATERIALSFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RAW_MATERIALSPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a RAW_MATERIALS.
     * @param {RAW_MATERIALSCreateArgs} args - Arguments to create a RAW_MATERIALS.
     * @example
     * // Create one RAW_MATERIALS
     * const RAW_MATERIALS = await prisma.rAW_MATERIALS.create({
     *   data: {
     *     // ... data to create a RAW_MATERIALS
     *   }
     * })
     * 
     */
    create<T extends RAW_MATERIALSCreateArgs>(args: SelectSubset<T, RAW_MATERIALSCreateArgs<ExtArgs>>): Prisma__RAW_MATERIALSClient<$Result.GetResult<Prisma.$RAW_MATERIALSPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many RAW_MATERIALS.
     * @param {RAW_MATERIALSCreateManyArgs} args - Arguments to create many RAW_MATERIALS.
     * @example
     * // Create many RAW_MATERIALS
     * const rAW_MATERIALS = await prisma.rAW_MATERIALS.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RAW_MATERIALSCreateManyArgs>(args?: SelectSubset<T, RAW_MATERIALSCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a RAW_MATERIALS.
     * @param {RAW_MATERIALSDeleteArgs} args - Arguments to delete one RAW_MATERIALS.
     * @example
     * // Delete one RAW_MATERIALS
     * const RAW_MATERIALS = await prisma.rAW_MATERIALS.delete({
     *   where: {
     *     // ... filter to delete one RAW_MATERIALS
     *   }
     * })
     * 
     */
    delete<T extends RAW_MATERIALSDeleteArgs>(args: SelectSubset<T, RAW_MATERIALSDeleteArgs<ExtArgs>>): Prisma__RAW_MATERIALSClient<$Result.GetResult<Prisma.$RAW_MATERIALSPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one RAW_MATERIALS.
     * @param {RAW_MATERIALSUpdateArgs} args - Arguments to update one RAW_MATERIALS.
     * @example
     * // Update one RAW_MATERIALS
     * const rAW_MATERIALS = await prisma.rAW_MATERIALS.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RAW_MATERIALSUpdateArgs>(args: SelectSubset<T, RAW_MATERIALSUpdateArgs<ExtArgs>>): Prisma__RAW_MATERIALSClient<$Result.GetResult<Prisma.$RAW_MATERIALSPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more RAW_MATERIALS.
     * @param {RAW_MATERIALSDeleteManyArgs} args - Arguments to filter RAW_MATERIALS to delete.
     * @example
     * // Delete a few RAW_MATERIALS
     * const { count } = await prisma.rAW_MATERIALS.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RAW_MATERIALSDeleteManyArgs>(args?: SelectSubset<T, RAW_MATERIALSDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RAW_MATERIALS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RAW_MATERIALSUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RAW_MATERIALS
     * const rAW_MATERIALS = await prisma.rAW_MATERIALS.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RAW_MATERIALSUpdateManyArgs>(args: SelectSubset<T, RAW_MATERIALSUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one RAW_MATERIALS.
     * @param {RAW_MATERIALSUpsertArgs} args - Arguments to update or create a RAW_MATERIALS.
     * @example
     * // Update or create a RAW_MATERIALS
     * const rAW_MATERIALS = await prisma.rAW_MATERIALS.upsert({
     *   create: {
     *     // ... data to create a RAW_MATERIALS
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RAW_MATERIALS we want to update
     *   }
     * })
     */
    upsert<T extends RAW_MATERIALSUpsertArgs>(args: SelectSubset<T, RAW_MATERIALSUpsertArgs<ExtArgs>>): Prisma__RAW_MATERIALSClient<$Result.GetResult<Prisma.$RAW_MATERIALSPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of RAW_MATERIALS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RAW_MATERIALSCountArgs} args - Arguments to filter RAW_MATERIALS to count.
     * @example
     * // Count the number of RAW_MATERIALS
     * const count = await prisma.rAW_MATERIALS.count({
     *   where: {
     *     // ... the filter for the RAW_MATERIALS we want to count
     *   }
     * })
    **/
    count<T extends RAW_MATERIALSCountArgs>(
      args?: Subset<T, RAW_MATERIALSCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RAW_MATERIALSCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RAW_MATERIALS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RAW_MATERIALSAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RAW_MATERIALSAggregateArgs>(args: Subset<T, RAW_MATERIALSAggregateArgs>): Prisma.PrismaPromise<GetRAW_MATERIALSAggregateType<T>>

    /**
     * Group by RAW_MATERIALS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RAW_MATERIALSGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RAW_MATERIALSGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RAW_MATERIALSGroupByArgs['orderBy'] }
        : { orderBy?: RAW_MATERIALSGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RAW_MATERIALSGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRAW_MATERIALSGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RAW_MATERIALS model
   */
  readonly fields: RAW_MATERIALSFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RAW_MATERIALS.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RAW_MATERIALSClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    VariantMaterials<T extends RAW_MATERIALS$VariantMaterialsArgs<ExtArgs> = {}>(args?: Subset<T, RAW_MATERIALS$VariantMaterialsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VARIANT_RAW_MATERIALS_TRACKERPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    RMTransactions<T extends RAW_MATERIALS$RMTransactionsArgs<ExtArgs> = {}>(args?: Subset<T, RAW_MATERIALS$RMTransactionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RM_TRANSACTIONSPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    RMQualityChecks<T extends RAW_MATERIALS$RMQualityChecksArgs<ExtArgs> = {}>(args?: Subset<T, RAW_MATERIALS$RMQualityChecksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RM_QCPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    RMWastageLogs<T extends RAW_MATERIALS$RMWastageLogsArgs<ExtArgs> = {}>(args?: Subset<T, RAW_MATERIALS$RMWastageLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RM_WASTAGE_LOGSPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    WIPMaterials<T extends RAW_MATERIALS$WIPMaterialsArgs<ExtArgs> = {}>(args?: Subset<T, RAW_MATERIALS$WIPMaterialsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WIPRawMaterialPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RAW_MATERIALS model
   */ 
  interface RAW_MATERIALSFieldRefs {
    readonly id: FieldRef<"RAW_MATERIALS", 'BigInt'>
    readonly name: FieldRef<"RAW_MATERIALS", 'String'>
    readonly SKU: FieldRef<"RAW_MATERIALS", 'String'>
    readonly quantity: FieldRef<"RAW_MATERIALS", 'Int'>
    readonly price: FieldRef<"RAW_MATERIALS", 'Decimal'>
    readonly image: FieldRef<"RAW_MATERIALS", 'String'>
    readonly description: FieldRef<"RAW_MATERIALS", 'String'>
    readonly expiry_date: FieldRef<"RAW_MATERIALS", 'DateTime'>
    readonly quality_status: FieldRef<"RAW_MATERIALS", 'QualityStatus'>
    readonly storage_location: FieldRef<"RAW_MATERIALS", 'String'>
    readonly createdAt: FieldRef<"RAW_MATERIALS", 'DateTime'>
    readonly updatedAt: FieldRef<"RAW_MATERIALS", 'DateTime'>
    readonly deletedAt: FieldRef<"RAW_MATERIALS", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * RAW_MATERIALS findUnique
   */
  export type RAW_MATERIALSFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RAW_MATERIALS
     */
    select?: RAW_MATERIALSSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RAW_MATERIALS
     */
    omit?: RAW_MATERIALSOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RAW_MATERIALSInclude<ExtArgs> | null
    /**
     * Filter, which RAW_MATERIALS to fetch.
     */
    where: RAW_MATERIALSWhereUniqueInput
  }

  /**
   * RAW_MATERIALS findUniqueOrThrow
   */
  export type RAW_MATERIALSFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RAW_MATERIALS
     */
    select?: RAW_MATERIALSSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RAW_MATERIALS
     */
    omit?: RAW_MATERIALSOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RAW_MATERIALSInclude<ExtArgs> | null
    /**
     * Filter, which RAW_MATERIALS to fetch.
     */
    where: RAW_MATERIALSWhereUniqueInput
  }

  /**
   * RAW_MATERIALS findFirst
   */
  export type RAW_MATERIALSFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RAW_MATERIALS
     */
    select?: RAW_MATERIALSSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RAW_MATERIALS
     */
    omit?: RAW_MATERIALSOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RAW_MATERIALSInclude<ExtArgs> | null
    /**
     * Filter, which RAW_MATERIALS to fetch.
     */
    where?: RAW_MATERIALSWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RAW_MATERIALS to fetch.
     */
    orderBy?: RAW_MATERIALSOrderByWithRelationInput | RAW_MATERIALSOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RAW_MATERIALS.
     */
    cursor?: RAW_MATERIALSWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RAW_MATERIALS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RAW_MATERIALS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RAW_MATERIALS.
     */
    distinct?: RAW_MATERIALSScalarFieldEnum | RAW_MATERIALSScalarFieldEnum[]
  }

  /**
   * RAW_MATERIALS findFirstOrThrow
   */
  export type RAW_MATERIALSFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RAW_MATERIALS
     */
    select?: RAW_MATERIALSSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RAW_MATERIALS
     */
    omit?: RAW_MATERIALSOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RAW_MATERIALSInclude<ExtArgs> | null
    /**
     * Filter, which RAW_MATERIALS to fetch.
     */
    where?: RAW_MATERIALSWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RAW_MATERIALS to fetch.
     */
    orderBy?: RAW_MATERIALSOrderByWithRelationInput | RAW_MATERIALSOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RAW_MATERIALS.
     */
    cursor?: RAW_MATERIALSWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RAW_MATERIALS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RAW_MATERIALS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RAW_MATERIALS.
     */
    distinct?: RAW_MATERIALSScalarFieldEnum | RAW_MATERIALSScalarFieldEnum[]
  }

  /**
   * RAW_MATERIALS findMany
   */
  export type RAW_MATERIALSFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RAW_MATERIALS
     */
    select?: RAW_MATERIALSSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RAW_MATERIALS
     */
    omit?: RAW_MATERIALSOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RAW_MATERIALSInclude<ExtArgs> | null
    /**
     * Filter, which RAW_MATERIALS to fetch.
     */
    where?: RAW_MATERIALSWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RAW_MATERIALS to fetch.
     */
    orderBy?: RAW_MATERIALSOrderByWithRelationInput | RAW_MATERIALSOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RAW_MATERIALS.
     */
    cursor?: RAW_MATERIALSWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RAW_MATERIALS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RAW_MATERIALS.
     */
    skip?: number
    distinct?: RAW_MATERIALSScalarFieldEnum | RAW_MATERIALSScalarFieldEnum[]
  }

  /**
   * RAW_MATERIALS create
   */
  export type RAW_MATERIALSCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RAW_MATERIALS
     */
    select?: RAW_MATERIALSSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RAW_MATERIALS
     */
    omit?: RAW_MATERIALSOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RAW_MATERIALSInclude<ExtArgs> | null
    /**
     * The data needed to create a RAW_MATERIALS.
     */
    data: XOR<RAW_MATERIALSCreateInput, RAW_MATERIALSUncheckedCreateInput>
  }

  /**
   * RAW_MATERIALS createMany
   */
  export type RAW_MATERIALSCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RAW_MATERIALS.
     */
    data: RAW_MATERIALSCreateManyInput | RAW_MATERIALSCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RAW_MATERIALS update
   */
  export type RAW_MATERIALSUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RAW_MATERIALS
     */
    select?: RAW_MATERIALSSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RAW_MATERIALS
     */
    omit?: RAW_MATERIALSOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RAW_MATERIALSInclude<ExtArgs> | null
    /**
     * The data needed to update a RAW_MATERIALS.
     */
    data: XOR<RAW_MATERIALSUpdateInput, RAW_MATERIALSUncheckedUpdateInput>
    /**
     * Choose, which RAW_MATERIALS to update.
     */
    where: RAW_MATERIALSWhereUniqueInput
  }

  /**
   * RAW_MATERIALS updateMany
   */
  export type RAW_MATERIALSUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RAW_MATERIALS.
     */
    data: XOR<RAW_MATERIALSUpdateManyMutationInput, RAW_MATERIALSUncheckedUpdateManyInput>
    /**
     * Filter which RAW_MATERIALS to update
     */
    where?: RAW_MATERIALSWhereInput
  }

  /**
   * RAW_MATERIALS upsert
   */
  export type RAW_MATERIALSUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RAW_MATERIALS
     */
    select?: RAW_MATERIALSSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RAW_MATERIALS
     */
    omit?: RAW_MATERIALSOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RAW_MATERIALSInclude<ExtArgs> | null
    /**
     * The filter to search for the RAW_MATERIALS to update in case it exists.
     */
    where: RAW_MATERIALSWhereUniqueInput
    /**
     * In case the RAW_MATERIALS found by the `where` argument doesn't exist, create a new RAW_MATERIALS with this data.
     */
    create: XOR<RAW_MATERIALSCreateInput, RAW_MATERIALSUncheckedCreateInput>
    /**
     * In case the RAW_MATERIALS was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RAW_MATERIALSUpdateInput, RAW_MATERIALSUncheckedUpdateInput>
  }

  /**
   * RAW_MATERIALS delete
   */
  export type RAW_MATERIALSDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RAW_MATERIALS
     */
    select?: RAW_MATERIALSSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RAW_MATERIALS
     */
    omit?: RAW_MATERIALSOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RAW_MATERIALSInclude<ExtArgs> | null
    /**
     * Filter which RAW_MATERIALS to delete.
     */
    where: RAW_MATERIALSWhereUniqueInput
  }

  /**
   * RAW_MATERIALS deleteMany
   */
  export type RAW_MATERIALSDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RAW_MATERIALS to delete
     */
    where?: RAW_MATERIALSWhereInput
  }

  /**
   * RAW_MATERIALS.VariantMaterials
   */
  export type RAW_MATERIALS$VariantMaterialsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VARIANT_RAW_MATERIALS_TRACKER
     */
    select?: VARIANT_RAW_MATERIALS_TRACKERSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VARIANT_RAW_MATERIALS_TRACKER
     */
    omit?: VARIANT_RAW_MATERIALS_TRACKEROmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VARIANT_RAW_MATERIALS_TRACKERInclude<ExtArgs> | null
    where?: VARIANT_RAW_MATERIALS_TRACKERWhereInput
    orderBy?: VARIANT_RAW_MATERIALS_TRACKEROrderByWithRelationInput | VARIANT_RAW_MATERIALS_TRACKEROrderByWithRelationInput[]
    cursor?: VARIANT_RAW_MATERIALS_TRACKERWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VARIANT_RAW_MATERIALS_TRACKERScalarFieldEnum | VARIANT_RAW_MATERIALS_TRACKERScalarFieldEnum[]
  }

  /**
   * RAW_MATERIALS.RMTransactions
   */
  export type RAW_MATERIALS$RMTransactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RM_TRANSACTIONS
     */
    select?: RM_TRANSACTIONSSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RM_TRANSACTIONS
     */
    omit?: RM_TRANSACTIONSOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RM_TRANSACTIONSInclude<ExtArgs> | null
    where?: RM_TRANSACTIONSWhereInput
    orderBy?: RM_TRANSACTIONSOrderByWithRelationInput | RM_TRANSACTIONSOrderByWithRelationInput[]
    cursor?: RM_TRANSACTIONSWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RM_TRANSACTIONSScalarFieldEnum | RM_TRANSACTIONSScalarFieldEnum[]
  }

  /**
   * RAW_MATERIALS.RMQualityChecks
   */
  export type RAW_MATERIALS$RMQualityChecksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RM_QC
     */
    select?: RM_QCSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RM_QC
     */
    omit?: RM_QCOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RM_QCInclude<ExtArgs> | null
    where?: RM_QCWhereInput
    orderBy?: RM_QCOrderByWithRelationInput | RM_QCOrderByWithRelationInput[]
    cursor?: RM_QCWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RM_QCScalarFieldEnum | RM_QCScalarFieldEnum[]
  }

  /**
   * RAW_MATERIALS.RMWastageLogs
   */
  export type RAW_MATERIALS$RMWastageLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RM_WASTAGE_LOGS
     */
    select?: RM_WASTAGE_LOGSSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RM_WASTAGE_LOGS
     */
    omit?: RM_WASTAGE_LOGSOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RM_WASTAGE_LOGSInclude<ExtArgs> | null
    where?: RM_WASTAGE_LOGSWhereInput
    orderBy?: RM_WASTAGE_LOGSOrderByWithRelationInput | RM_WASTAGE_LOGSOrderByWithRelationInput[]
    cursor?: RM_WASTAGE_LOGSWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RM_WASTAGE_LOGSScalarFieldEnum | RM_WASTAGE_LOGSScalarFieldEnum[]
  }

  /**
   * RAW_MATERIALS.WIPMaterials
   */
  export type RAW_MATERIALS$WIPMaterialsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WIPRawMaterial
     */
    select?: WIPRawMaterialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WIPRawMaterial
     */
    omit?: WIPRawMaterialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WIPRawMaterialInclude<ExtArgs> | null
    where?: WIPRawMaterialWhereInput
    orderBy?: WIPRawMaterialOrderByWithRelationInput | WIPRawMaterialOrderByWithRelationInput[]
    cursor?: WIPRawMaterialWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WIPRawMaterialScalarFieldEnum | WIPRawMaterialScalarFieldEnum[]
  }

  /**
   * RAW_MATERIALS without action
   */
  export type RAW_MATERIALSDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RAW_MATERIALS
     */
    select?: RAW_MATERIALSSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RAW_MATERIALS
     */
    omit?: RAW_MATERIALSOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RAW_MATERIALSInclude<ExtArgs> | null
  }


  /**
   * Model SHOPIFY_VARIANTS
   */

  export type AggregateSHOPIFY_VARIANTS = {
    _count: SHOPIFY_VARIANTSCountAggregateOutputType | null
    _avg: SHOPIFY_VARIANTSAvgAggregateOutputType | null
    _sum: SHOPIFY_VARIANTSSumAggregateOutputType | null
    _min: SHOPIFY_VARIANTSMinAggregateOutputType | null
    _max: SHOPIFY_VARIANTSMaxAggregateOutputType | null
  }

  export type SHOPIFY_VARIANTSAvgAggregateOutputType = {
    id: number | null
    productId: number | null
    AvailableQty: number | null
  }

  export type SHOPIFY_VARIANTSSumAggregateOutputType = {
    id: bigint | null
    productId: bigint | null
    AvailableQty: number | null
  }

  export type SHOPIFY_VARIANTSMinAggregateOutputType = {
    id: bigint | null
    productId: bigint | null
    name: string | null
    AvailableQty: number | null
    img: string | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
    variantName: string | null
    variantOption: string | null
  }

  export type SHOPIFY_VARIANTSMaxAggregateOutputType = {
    id: bigint | null
    productId: bigint | null
    name: string | null
    AvailableQty: number | null
    img: string | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
    variantName: string | null
    variantOption: string | null
  }

  export type SHOPIFY_VARIANTSCountAggregateOutputType = {
    id: number
    productId: number
    name: number
    AvailableQty: number
    img: number
    createdAt: number
    updatedAt: number
    deletedAt: number
    variantName: number
    variantOption: number
    _all: number
  }


  export type SHOPIFY_VARIANTSAvgAggregateInputType = {
    id?: true
    productId?: true
    AvailableQty?: true
  }

  export type SHOPIFY_VARIANTSSumAggregateInputType = {
    id?: true
    productId?: true
    AvailableQty?: true
  }

  export type SHOPIFY_VARIANTSMinAggregateInputType = {
    id?: true
    productId?: true
    name?: true
    AvailableQty?: true
    img?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
    variantName?: true
    variantOption?: true
  }

  export type SHOPIFY_VARIANTSMaxAggregateInputType = {
    id?: true
    productId?: true
    name?: true
    AvailableQty?: true
    img?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
    variantName?: true
    variantOption?: true
  }

  export type SHOPIFY_VARIANTSCountAggregateInputType = {
    id?: true
    productId?: true
    name?: true
    AvailableQty?: true
    img?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
    variantName?: true
    variantOption?: true
    _all?: true
  }

  export type SHOPIFY_VARIANTSAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SHOPIFY_VARIANTS to aggregate.
     */
    where?: SHOPIFY_VARIANTSWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SHOPIFY_VARIANTS to fetch.
     */
    orderBy?: SHOPIFY_VARIANTSOrderByWithRelationInput | SHOPIFY_VARIANTSOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SHOPIFY_VARIANTSWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SHOPIFY_VARIANTS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SHOPIFY_VARIANTS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SHOPIFY_VARIANTS
    **/
    _count?: true | SHOPIFY_VARIANTSCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SHOPIFY_VARIANTSAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SHOPIFY_VARIANTSSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SHOPIFY_VARIANTSMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SHOPIFY_VARIANTSMaxAggregateInputType
  }

  export type GetSHOPIFY_VARIANTSAggregateType<T extends SHOPIFY_VARIANTSAggregateArgs> = {
        [P in keyof T & keyof AggregateSHOPIFY_VARIANTS]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSHOPIFY_VARIANTS[P]>
      : GetScalarType<T[P], AggregateSHOPIFY_VARIANTS[P]>
  }




  export type SHOPIFY_VARIANTSGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SHOPIFY_VARIANTSWhereInput
    orderBy?: SHOPIFY_VARIANTSOrderByWithAggregationInput | SHOPIFY_VARIANTSOrderByWithAggregationInput[]
    by: SHOPIFY_VARIANTSScalarFieldEnum[] | SHOPIFY_VARIANTSScalarFieldEnum
    having?: SHOPIFY_VARIANTSScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SHOPIFY_VARIANTSCountAggregateInputType | true
    _avg?: SHOPIFY_VARIANTSAvgAggregateInputType
    _sum?: SHOPIFY_VARIANTSSumAggregateInputType
    _min?: SHOPIFY_VARIANTSMinAggregateInputType
    _max?: SHOPIFY_VARIANTSMaxAggregateInputType
  }

  export type SHOPIFY_VARIANTSGroupByOutputType = {
    id: bigint
    productId: bigint
    name: string
    AvailableQty: number
    img: string | null
    createdAt: Date
    updatedAt: Date
    deletedAt: Date | null
    variantName: string | null
    variantOption: string | null
    _count: SHOPIFY_VARIANTSCountAggregateOutputType | null
    _avg: SHOPIFY_VARIANTSAvgAggregateOutputType | null
    _sum: SHOPIFY_VARIANTSSumAggregateOutputType | null
    _min: SHOPIFY_VARIANTSMinAggregateOutputType | null
    _max: SHOPIFY_VARIANTSMaxAggregateOutputType | null
  }

  type GetSHOPIFY_VARIANTSGroupByPayload<T extends SHOPIFY_VARIANTSGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SHOPIFY_VARIANTSGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SHOPIFY_VARIANTSGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SHOPIFY_VARIANTSGroupByOutputType[P]>
            : GetScalarType<T[P], SHOPIFY_VARIANTSGroupByOutputType[P]>
        }
      >
    >


  export type SHOPIFY_VARIANTSSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    productId?: boolean
    name?: boolean
    AvailableQty?: boolean
    img?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    variantName?: boolean
    variantOption?: boolean
    product?: boolean | SHOPIFY_PRODUCTSDefaultArgs<ExtArgs>
    VariantMaterials?: boolean | SHOPIFY_VARIANTS$VariantMaterialsArgs<ExtArgs>
    _count?: boolean | SHOPIFY_VARIANTSCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["sHOPIFY_VARIANTS"]>



  export type SHOPIFY_VARIANTSSelectScalar = {
    id?: boolean
    productId?: boolean
    name?: boolean
    AvailableQty?: boolean
    img?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    variantName?: boolean
    variantOption?: boolean
  }

  export type SHOPIFY_VARIANTSOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "productId" | "name" | "AvailableQty" | "img" | "createdAt" | "updatedAt" | "deletedAt" | "variantName" | "variantOption", ExtArgs["result"]["sHOPIFY_VARIANTS"]>
  export type SHOPIFY_VARIANTSInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    product?: boolean | SHOPIFY_PRODUCTSDefaultArgs<ExtArgs>
    VariantMaterials?: boolean | SHOPIFY_VARIANTS$VariantMaterialsArgs<ExtArgs>
    _count?: boolean | SHOPIFY_VARIANTSCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $SHOPIFY_VARIANTSPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SHOPIFY_VARIANTS"
    objects: {
      product: Prisma.$SHOPIFY_PRODUCTSPayload<ExtArgs>
      VariantMaterials: Prisma.$VARIANT_RAW_MATERIALS_TRACKERPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: bigint
      productId: bigint
      name: string
      AvailableQty: number
      img: string | null
      createdAt: Date
      updatedAt: Date
      deletedAt: Date | null
      variantName: string | null
      variantOption: string | null
    }, ExtArgs["result"]["sHOPIFY_VARIANTS"]>
    composites: {}
  }

  type SHOPIFY_VARIANTSGetPayload<S extends boolean | null | undefined | SHOPIFY_VARIANTSDefaultArgs> = $Result.GetResult<Prisma.$SHOPIFY_VARIANTSPayload, S>

  type SHOPIFY_VARIANTSCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SHOPIFY_VARIANTSFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SHOPIFY_VARIANTSCountAggregateInputType | true
    }

  export interface SHOPIFY_VARIANTSDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SHOPIFY_VARIANTS'], meta: { name: 'SHOPIFY_VARIANTS' } }
    /**
     * Find zero or one SHOPIFY_VARIANTS that matches the filter.
     * @param {SHOPIFY_VARIANTSFindUniqueArgs} args - Arguments to find a SHOPIFY_VARIANTS
     * @example
     * // Get one SHOPIFY_VARIANTS
     * const sHOPIFY_VARIANTS = await prisma.sHOPIFY_VARIANTS.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SHOPIFY_VARIANTSFindUniqueArgs>(args: SelectSubset<T, SHOPIFY_VARIANTSFindUniqueArgs<ExtArgs>>): Prisma__SHOPIFY_VARIANTSClient<$Result.GetResult<Prisma.$SHOPIFY_VARIANTSPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one SHOPIFY_VARIANTS that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SHOPIFY_VARIANTSFindUniqueOrThrowArgs} args - Arguments to find a SHOPIFY_VARIANTS
     * @example
     * // Get one SHOPIFY_VARIANTS
     * const sHOPIFY_VARIANTS = await prisma.sHOPIFY_VARIANTS.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SHOPIFY_VARIANTSFindUniqueOrThrowArgs>(args: SelectSubset<T, SHOPIFY_VARIANTSFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SHOPIFY_VARIANTSClient<$Result.GetResult<Prisma.$SHOPIFY_VARIANTSPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first SHOPIFY_VARIANTS that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SHOPIFY_VARIANTSFindFirstArgs} args - Arguments to find a SHOPIFY_VARIANTS
     * @example
     * // Get one SHOPIFY_VARIANTS
     * const sHOPIFY_VARIANTS = await prisma.sHOPIFY_VARIANTS.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SHOPIFY_VARIANTSFindFirstArgs>(args?: SelectSubset<T, SHOPIFY_VARIANTSFindFirstArgs<ExtArgs>>): Prisma__SHOPIFY_VARIANTSClient<$Result.GetResult<Prisma.$SHOPIFY_VARIANTSPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first SHOPIFY_VARIANTS that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SHOPIFY_VARIANTSFindFirstOrThrowArgs} args - Arguments to find a SHOPIFY_VARIANTS
     * @example
     * // Get one SHOPIFY_VARIANTS
     * const sHOPIFY_VARIANTS = await prisma.sHOPIFY_VARIANTS.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SHOPIFY_VARIANTSFindFirstOrThrowArgs>(args?: SelectSubset<T, SHOPIFY_VARIANTSFindFirstOrThrowArgs<ExtArgs>>): Prisma__SHOPIFY_VARIANTSClient<$Result.GetResult<Prisma.$SHOPIFY_VARIANTSPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more SHOPIFY_VARIANTS that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SHOPIFY_VARIANTSFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SHOPIFY_VARIANTS
     * const sHOPIFY_VARIANTS = await prisma.sHOPIFY_VARIANTS.findMany()
     * 
     * // Get first 10 SHOPIFY_VARIANTS
     * const sHOPIFY_VARIANTS = await prisma.sHOPIFY_VARIANTS.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sHOPIFY_VARIANTSWithIdOnly = await prisma.sHOPIFY_VARIANTS.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SHOPIFY_VARIANTSFindManyArgs>(args?: SelectSubset<T, SHOPIFY_VARIANTSFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SHOPIFY_VARIANTSPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a SHOPIFY_VARIANTS.
     * @param {SHOPIFY_VARIANTSCreateArgs} args - Arguments to create a SHOPIFY_VARIANTS.
     * @example
     * // Create one SHOPIFY_VARIANTS
     * const SHOPIFY_VARIANTS = await prisma.sHOPIFY_VARIANTS.create({
     *   data: {
     *     // ... data to create a SHOPIFY_VARIANTS
     *   }
     * })
     * 
     */
    create<T extends SHOPIFY_VARIANTSCreateArgs>(args: SelectSubset<T, SHOPIFY_VARIANTSCreateArgs<ExtArgs>>): Prisma__SHOPIFY_VARIANTSClient<$Result.GetResult<Prisma.$SHOPIFY_VARIANTSPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many SHOPIFY_VARIANTS.
     * @param {SHOPIFY_VARIANTSCreateManyArgs} args - Arguments to create many SHOPIFY_VARIANTS.
     * @example
     * // Create many SHOPIFY_VARIANTS
     * const sHOPIFY_VARIANTS = await prisma.sHOPIFY_VARIANTS.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SHOPIFY_VARIANTSCreateManyArgs>(args?: SelectSubset<T, SHOPIFY_VARIANTSCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a SHOPIFY_VARIANTS.
     * @param {SHOPIFY_VARIANTSDeleteArgs} args - Arguments to delete one SHOPIFY_VARIANTS.
     * @example
     * // Delete one SHOPIFY_VARIANTS
     * const SHOPIFY_VARIANTS = await prisma.sHOPIFY_VARIANTS.delete({
     *   where: {
     *     // ... filter to delete one SHOPIFY_VARIANTS
     *   }
     * })
     * 
     */
    delete<T extends SHOPIFY_VARIANTSDeleteArgs>(args: SelectSubset<T, SHOPIFY_VARIANTSDeleteArgs<ExtArgs>>): Prisma__SHOPIFY_VARIANTSClient<$Result.GetResult<Prisma.$SHOPIFY_VARIANTSPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one SHOPIFY_VARIANTS.
     * @param {SHOPIFY_VARIANTSUpdateArgs} args - Arguments to update one SHOPIFY_VARIANTS.
     * @example
     * // Update one SHOPIFY_VARIANTS
     * const sHOPIFY_VARIANTS = await prisma.sHOPIFY_VARIANTS.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SHOPIFY_VARIANTSUpdateArgs>(args: SelectSubset<T, SHOPIFY_VARIANTSUpdateArgs<ExtArgs>>): Prisma__SHOPIFY_VARIANTSClient<$Result.GetResult<Prisma.$SHOPIFY_VARIANTSPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more SHOPIFY_VARIANTS.
     * @param {SHOPIFY_VARIANTSDeleteManyArgs} args - Arguments to filter SHOPIFY_VARIANTS to delete.
     * @example
     * // Delete a few SHOPIFY_VARIANTS
     * const { count } = await prisma.sHOPIFY_VARIANTS.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SHOPIFY_VARIANTSDeleteManyArgs>(args?: SelectSubset<T, SHOPIFY_VARIANTSDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SHOPIFY_VARIANTS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SHOPIFY_VARIANTSUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SHOPIFY_VARIANTS
     * const sHOPIFY_VARIANTS = await prisma.sHOPIFY_VARIANTS.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SHOPIFY_VARIANTSUpdateManyArgs>(args: SelectSubset<T, SHOPIFY_VARIANTSUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SHOPIFY_VARIANTS.
     * @param {SHOPIFY_VARIANTSUpsertArgs} args - Arguments to update or create a SHOPIFY_VARIANTS.
     * @example
     * // Update or create a SHOPIFY_VARIANTS
     * const sHOPIFY_VARIANTS = await prisma.sHOPIFY_VARIANTS.upsert({
     *   create: {
     *     // ... data to create a SHOPIFY_VARIANTS
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SHOPIFY_VARIANTS we want to update
     *   }
     * })
     */
    upsert<T extends SHOPIFY_VARIANTSUpsertArgs>(args: SelectSubset<T, SHOPIFY_VARIANTSUpsertArgs<ExtArgs>>): Prisma__SHOPIFY_VARIANTSClient<$Result.GetResult<Prisma.$SHOPIFY_VARIANTSPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of SHOPIFY_VARIANTS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SHOPIFY_VARIANTSCountArgs} args - Arguments to filter SHOPIFY_VARIANTS to count.
     * @example
     * // Count the number of SHOPIFY_VARIANTS
     * const count = await prisma.sHOPIFY_VARIANTS.count({
     *   where: {
     *     // ... the filter for the SHOPIFY_VARIANTS we want to count
     *   }
     * })
    **/
    count<T extends SHOPIFY_VARIANTSCountArgs>(
      args?: Subset<T, SHOPIFY_VARIANTSCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SHOPIFY_VARIANTSCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SHOPIFY_VARIANTS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SHOPIFY_VARIANTSAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SHOPIFY_VARIANTSAggregateArgs>(args: Subset<T, SHOPIFY_VARIANTSAggregateArgs>): Prisma.PrismaPromise<GetSHOPIFY_VARIANTSAggregateType<T>>

    /**
     * Group by SHOPIFY_VARIANTS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SHOPIFY_VARIANTSGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SHOPIFY_VARIANTSGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SHOPIFY_VARIANTSGroupByArgs['orderBy'] }
        : { orderBy?: SHOPIFY_VARIANTSGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SHOPIFY_VARIANTSGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSHOPIFY_VARIANTSGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SHOPIFY_VARIANTS model
   */
  readonly fields: SHOPIFY_VARIANTSFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SHOPIFY_VARIANTS.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SHOPIFY_VARIANTSClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    product<T extends SHOPIFY_PRODUCTSDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SHOPIFY_PRODUCTSDefaultArgs<ExtArgs>>): Prisma__SHOPIFY_PRODUCTSClient<$Result.GetResult<Prisma.$SHOPIFY_PRODUCTSPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    VariantMaterials<T extends SHOPIFY_VARIANTS$VariantMaterialsArgs<ExtArgs> = {}>(args?: Subset<T, SHOPIFY_VARIANTS$VariantMaterialsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VARIANT_RAW_MATERIALS_TRACKERPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SHOPIFY_VARIANTS model
   */ 
  interface SHOPIFY_VARIANTSFieldRefs {
    readonly id: FieldRef<"SHOPIFY_VARIANTS", 'BigInt'>
    readonly productId: FieldRef<"SHOPIFY_VARIANTS", 'BigInt'>
    readonly name: FieldRef<"SHOPIFY_VARIANTS", 'String'>
    readonly AvailableQty: FieldRef<"SHOPIFY_VARIANTS", 'Int'>
    readonly img: FieldRef<"SHOPIFY_VARIANTS", 'String'>
    readonly createdAt: FieldRef<"SHOPIFY_VARIANTS", 'DateTime'>
    readonly updatedAt: FieldRef<"SHOPIFY_VARIANTS", 'DateTime'>
    readonly deletedAt: FieldRef<"SHOPIFY_VARIANTS", 'DateTime'>
    readonly variantName: FieldRef<"SHOPIFY_VARIANTS", 'String'>
    readonly variantOption: FieldRef<"SHOPIFY_VARIANTS", 'String'>
  }
    

  // Custom InputTypes
  /**
   * SHOPIFY_VARIANTS findUnique
   */
  export type SHOPIFY_VARIANTSFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SHOPIFY_VARIANTS
     */
    select?: SHOPIFY_VARIANTSSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SHOPIFY_VARIANTS
     */
    omit?: SHOPIFY_VARIANTSOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SHOPIFY_VARIANTSInclude<ExtArgs> | null
    /**
     * Filter, which SHOPIFY_VARIANTS to fetch.
     */
    where: SHOPIFY_VARIANTSWhereUniqueInput
  }

  /**
   * SHOPIFY_VARIANTS findUniqueOrThrow
   */
  export type SHOPIFY_VARIANTSFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SHOPIFY_VARIANTS
     */
    select?: SHOPIFY_VARIANTSSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SHOPIFY_VARIANTS
     */
    omit?: SHOPIFY_VARIANTSOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SHOPIFY_VARIANTSInclude<ExtArgs> | null
    /**
     * Filter, which SHOPIFY_VARIANTS to fetch.
     */
    where: SHOPIFY_VARIANTSWhereUniqueInput
  }

  /**
   * SHOPIFY_VARIANTS findFirst
   */
  export type SHOPIFY_VARIANTSFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SHOPIFY_VARIANTS
     */
    select?: SHOPIFY_VARIANTSSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SHOPIFY_VARIANTS
     */
    omit?: SHOPIFY_VARIANTSOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SHOPIFY_VARIANTSInclude<ExtArgs> | null
    /**
     * Filter, which SHOPIFY_VARIANTS to fetch.
     */
    where?: SHOPIFY_VARIANTSWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SHOPIFY_VARIANTS to fetch.
     */
    orderBy?: SHOPIFY_VARIANTSOrderByWithRelationInput | SHOPIFY_VARIANTSOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SHOPIFY_VARIANTS.
     */
    cursor?: SHOPIFY_VARIANTSWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SHOPIFY_VARIANTS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SHOPIFY_VARIANTS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SHOPIFY_VARIANTS.
     */
    distinct?: SHOPIFY_VARIANTSScalarFieldEnum | SHOPIFY_VARIANTSScalarFieldEnum[]
  }

  /**
   * SHOPIFY_VARIANTS findFirstOrThrow
   */
  export type SHOPIFY_VARIANTSFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SHOPIFY_VARIANTS
     */
    select?: SHOPIFY_VARIANTSSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SHOPIFY_VARIANTS
     */
    omit?: SHOPIFY_VARIANTSOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SHOPIFY_VARIANTSInclude<ExtArgs> | null
    /**
     * Filter, which SHOPIFY_VARIANTS to fetch.
     */
    where?: SHOPIFY_VARIANTSWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SHOPIFY_VARIANTS to fetch.
     */
    orderBy?: SHOPIFY_VARIANTSOrderByWithRelationInput | SHOPIFY_VARIANTSOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SHOPIFY_VARIANTS.
     */
    cursor?: SHOPIFY_VARIANTSWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SHOPIFY_VARIANTS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SHOPIFY_VARIANTS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SHOPIFY_VARIANTS.
     */
    distinct?: SHOPIFY_VARIANTSScalarFieldEnum | SHOPIFY_VARIANTSScalarFieldEnum[]
  }

  /**
   * SHOPIFY_VARIANTS findMany
   */
  export type SHOPIFY_VARIANTSFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SHOPIFY_VARIANTS
     */
    select?: SHOPIFY_VARIANTSSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SHOPIFY_VARIANTS
     */
    omit?: SHOPIFY_VARIANTSOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SHOPIFY_VARIANTSInclude<ExtArgs> | null
    /**
     * Filter, which SHOPIFY_VARIANTS to fetch.
     */
    where?: SHOPIFY_VARIANTSWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SHOPIFY_VARIANTS to fetch.
     */
    orderBy?: SHOPIFY_VARIANTSOrderByWithRelationInput | SHOPIFY_VARIANTSOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SHOPIFY_VARIANTS.
     */
    cursor?: SHOPIFY_VARIANTSWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SHOPIFY_VARIANTS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SHOPIFY_VARIANTS.
     */
    skip?: number
    distinct?: SHOPIFY_VARIANTSScalarFieldEnum | SHOPIFY_VARIANTSScalarFieldEnum[]
  }

  /**
   * SHOPIFY_VARIANTS create
   */
  export type SHOPIFY_VARIANTSCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SHOPIFY_VARIANTS
     */
    select?: SHOPIFY_VARIANTSSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SHOPIFY_VARIANTS
     */
    omit?: SHOPIFY_VARIANTSOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SHOPIFY_VARIANTSInclude<ExtArgs> | null
    /**
     * The data needed to create a SHOPIFY_VARIANTS.
     */
    data: XOR<SHOPIFY_VARIANTSCreateInput, SHOPIFY_VARIANTSUncheckedCreateInput>
  }

  /**
   * SHOPIFY_VARIANTS createMany
   */
  export type SHOPIFY_VARIANTSCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SHOPIFY_VARIANTS.
     */
    data: SHOPIFY_VARIANTSCreateManyInput | SHOPIFY_VARIANTSCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SHOPIFY_VARIANTS update
   */
  export type SHOPIFY_VARIANTSUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SHOPIFY_VARIANTS
     */
    select?: SHOPIFY_VARIANTSSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SHOPIFY_VARIANTS
     */
    omit?: SHOPIFY_VARIANTSOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SHOPIFY_VARIANTSInclude<ExtArgs> | null
    /**
     * The data needed to update a SHOPIFY_VARIANTS.
     */
    data: XOR<SHOPIFY_VARIANTSUpdateInput, SHOPIFY_VARIANTSUncheckedUpdateInput>
    /**
     * Choose, which SHOPIFY_VARIANTS to update.
     */
    where: SHOPIFY_VARIANTSWhereUniqueInput
  }

  /**
   * SHOPIFY_VARIANTS updateMany
   */
  export type SHOPIFY_VARIANTSUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SHOPIFY_VARIANTS.
     */
    data: XOR<SHOPIFY_VARIANTSUpdateManyMutationInput, SHOPIFY_VARIANTSUncheckedUpdateManyInput>
    /**
     * Filter which SHOPIFY_VARIANTS to update
     */
    where?: SHOPIFY_VARIANTSWhereInput
  }

  /**
   * SHOPIFY_VARIANTS upsert
   */
  export type SHOPIFY_VARIANTSUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SHOPIFY_VARIANTS
     */
    select?: SHOPIFY_VARIANTSSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SHOPIFY_VARIANTS
     */
    omit?: SHOPIFY_VARIANTSOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SHOPIFY_VARIANTSInclude<ExtArgs> | null
    /**
     * The filter to search for the SHOPIFY_VARIANTS to update in case it exists.
     */
    where: SHOPIFY_VARIANTSWhereUniqueInput
    /**
     * In case the SHOPIFY_VARIANTS found by the `where` argument doesn't exist, create a new SHOPIFY_VARIANTS with this data.
     */
    create: XOR<SHOPIFY_VARIANTSCreateInput, SHOPIFY_VARIANTSUncheckedCreateInput>
    /**
     * In case the SHOPIFY_VARIANTS was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SHOPIFY_VARIANTSUpdateInput, SHOPIFY_VARIANTSUncheckedUpdateInput>
  }

  /**
   * SHOPIFY_VARIANTS delete
   */
  export type SHOPIFY_VARIANTSDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SHOPIFY_VARIANTS
     */
    select?: SHOPIFY_VARIANTSSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SHOPIFY_VARIANTS
     */
    omit?: SHOPIFY_VARIANTSOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SHOPIFY_VARIANTSInclude<ExtArgs> | null
    /**
     * Filter which SHOPIFY_VARIANTS to delete.
     */
    where: SHOPIFY_VARIANTSWhereUniqueInput
  }

  /**
   * SHOPIFY_VARIANTS deleteMany
   */
  export type SHOPIFY_VARIANTSDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SHOPIFY_VARIANTS to delete
     */
    where?: SHOPIFY_VARIANTSWhereInput
  }

  /**
   * SHOPIFY_VARIANTS.VariantMaterials
   */
  export type SHOPIFY_VARIANTS$VariantMaterialsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VARIANT_RAW_MATERIALS_TRACKER
     */
    select?: VARIANT_RAW_MATERIALS_TRACKERSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VARIANT_RAW_MATERIALS_TRACKER
     */
    omit?: VARIANT_RAW_MATERIALS_TRACKEROmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VARIANT_RAW_MATERIALS_TRACKERInclude<ExtArgs> | null
    where?: VARIANT_RAW_MATERIALS_TRACKERWhereInput
    orderBy?: VARIANT_RAW_MATERIALS_TRACKEROrderByWithRelationInput | VARIANT_RAW_MATERIALS_TRACKEROrderByWithRelationInput[]
    cursor?: VARIANT_RAW_MATERIALS_TRACKERWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VARIANT_RAW_MATERIALS_TRACKERScalarFieldEnum | VARIANT_RAW_MATERIALS_TRACKERScalarFieldEnum[]
  }

  /**
   * SHOPIFY_VARIANTS without action
   */
  export type SHOPIFY_VARIANTSDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SHOPIFY_VARIANTS
     */
    select?: SHOPIFY_VARIANTSSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SHOPIFY_VARIANTS
     */
    omit?: SHOPIFY_VARIANTSOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SHOPIFY_VARIANTSInclude<ExtArgs> | null
  }


  /**
   * Model VARIANT_RAW_MATERIALS_TRACKER
   */

  export type AggregateVARIANT_RAW_MATERIALS_TRACKER = {
    _count: VARIANT_RAW_MATERIALS_TRACKERCountAggregateOutputType | null
    _avg: VARIANT_RAW_MATERIALS_TRACKERAvgAggregateOutputType | null
    _sum: VARIANT_RAW_MATERIALS_TRACKERSumAggregateOutputType | null
    _min: VARIANT_RAW_MATERIALS_TRACKERMinAggregateOutputType | null
    _max: VARIANT_RAW_MATERIALS_TRACKERMaxAggregateOutputType | null
  }

  export type VARIANT_RAW_MATERIALS_TRACKERAvgAggregateOutputType = {
    variantId: number | null
    rawMaterialId: number | null
    avgQuantity: Decimal | null
  }

  export type VARIANT_RAW_MATERIALS_TRACKERSumAggregateOutputType = {
    variantId: bigint | null
    rawMaterialId: bigint | null
    avgQuantity: Decimal | null
  }

  export type VARIANT_RAW_MATERIALS_TRACKERMinAggregateOutputType = {
    variantId: bigint | null
    rawMaterialId: bigint | null
    avgQuantity: Decimal | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type VARIANT_RAW_MATERIALS_TRACKERMaxAggregateOutputType = {
    variantId: bigint | null
    rawMaterialId: bigint | null
    avgQuantity: Decimal | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type VARIANT_RAW_MATERIALS_TRACKERCountAggregateOutputType = {
    variantId: number
    rawMaterialId: number
    avgQuantity: number
    createdAt: number
    updatedAt: number
    deletedAt: number
    _all: number
  }


  export type VARIANT_RAW_MATERIALS_TRACKERAvgAggregateInputType = {
    variantId?: true
    rawMaterialId?: true
    avgQuantity?: true
  }

  export type VARIANT_RAW_MATERIALS_TRACKERSumAggregateInputType = {
    variantId?: true
    rawMaterialId?: true
    avgQuantity?: true
  }

  export type VARIANT_RAW_MATERIALS_TRACKERMinAggregateInputType = {
    variantId?: true
    rawMaterialId?: true
    avgQuantity?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type VARIANT_RAW_MATERIALS_TRACKERMaxAggregateInputType = {
    variantId?: true
    rawMaterialId?: true
    avgQuantity?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type VARIANT_RAW_MATERIALS_TRACKERCountAggregateInputType = {
    variantId?: true
    rawMaterialId?: true
    avgQuantity?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
    _all?: true
  }

  export type VARIANT_RAW_MATERIALS_TRACKERAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VARIANT_RAW_MATERIALS_TRACKER to aggregate.
     */
    where?: VARIANT_RAW_MATERIALS_TRACKERWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VARIANT_RAW_MATERIALS_TRACKERS to fetch.
     */
    orderBy?: VARIANT_RAW_MATERIALS_TRACKEROrderByWithRelationInput | VARIANT_RAW_MATERIALS_TRACKEROrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VARIANT_RAW_MATERIALS_TRACKERWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VARIANT_RAW_MATERIALS_TRACKERS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VARIANT_RAW_MATERIALS_TRACKERS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned VARIANT_RAW_MATERIALS_TRACKERS
    **/
    _count?: true | VARIANT_RAW_MATERIALS_TRACKERCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: VARIANT_RAW_MATERIALS_TRACKERAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: VARIANT_RAW_MATERIALS_TRACKERSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VARIANT_RAW_MATERIALS_TRACKERMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VARIANT_RAW_MATERIALS_TRACKERMaxAggregateInputType
  }

  export type GetVARIANT_RAW_MATERIALS_TRACKERAggregateType<T extends VARIANT_RAW_MATERIALS_TRACKERAggregateArgs> = {
        [P in keyof T & keyof AggregateVARIANT_RAW_MATERIALS_TRACKER]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVARIANT_RAW_MATERIALS_TRACKER[P]>
      : GetScalarType<T[P], AggregateVARIANT_RAW_MATERIALS_TRACKER[P]>
  }




  export type VARIANT_RAW_MATERIALS_TRACKERGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VARIANT_RAW_MATERIALS_TRACKERWhereInput
    orderBy?: VARIANT_RAW_MATERIALS_TRACKEROrderByWithAggregationInput | VARIANT_RAW_MATERIALS_TRACKEROrderByWithAggregationInput[]
    by: VARIANT_RAW_MATERIALS_TRACKERScalarFieldEnum[] | VARIANT_RAW_MATERIALS_TRACKERScalarFieldEnum
    having?: VARIANT_RAW_MATERIALS_TRACKERScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VARIANT_RAW_MATERIALS_TRACKERCountAggregateInputType | true
    _avg?: VARIANT_RAW_MATERIALS_TRACKERAvgAggregateInputType
    _sum?: VARIANT_RAW_MATERIALS_TRACKERSumAggregateInputType
    _min?: VARIANT_RAW_MATERIALS_TRACKERMinAggregateInputType
    _max?: VARIANT_RAW_MATERIALS_TRACKERMaxAggregateInputType
  }

  export type VARIANT_RAW_MATERIALS_TRACKERGroupByOutputType = {
    variantId: bigint
    rawMaterialId: bigint
    avgQuantity: Decimal
    createdAt: Date
    updatedAt: Date
    deletedAt: Date | null
    _count: VARIANT_RAW_MATERIALS_TRACKERCountAggregateOutputType | null
    _avg: VARIANT_RAW_MATERIALS_TRACKERAvgAggregateOutputType | null
    _sum: VARIANT_RAW_MATERIALS_TRACKERSumAggregateOutputType | null
    _min: VARIANT_RAW_MATERIALS_TRACKERMinAggregateOutputType | null
    _max: VARIANT_RAW_MATERIALS_TRACKERMaxAggregateOutputType | null
  }

  type GetVARIANT_RAW_MATERIALS_TRACKERGroupByPayload<T extends VARIANT_RAW_MATERIALS_TRACKERGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VARIANT_RAW_MATERIALS_TRACKERGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VARIANT_RAW_MATERIALS_TRACKERGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VARIANT_RAW_MATERIALS_TRACKERGroupByOutputType[P]>
            : GetScalarType<T[P], VARIANT_RAW_MATERIALS_TRACKERGroupByOutputType[P]>
        }
      >
    >


  export type VARIANT_RAW_MATERIALS_TRACKERSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    variantId?: boolean
    rawMaterialId?: boolean
    avgQuantity?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    variant?: boolean | SHOPIFY_VARIANTSDefaultArgs<ExtArgs>
    rawMaterial?: boolean | RAW_MATERIALSDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["vARIANT_RAW_MATERIALS_TRACKER"]>



  export type VARIANT_RAW_MATERIALS_TRACKERSelectScalar = {
    variantId?: boolean
    rawMaterialId?: boolean
    avgQuantity?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
  }

  export type VARIANT_RAW_MATERIALS_TRACKEROmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"variantId" | "rawMaterialId" | "avgQuantity" | "createdAt" | "updatedAt" | "deletedAt", ExtArgs["result"]["vARIANT_RAW_MATERIALS_TRACKER"]>
  export type VARIANT_RAW_MATERIALS_TRACKERInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    variant?: boolean | SHOPIFY_VARIANTSDefaultArgs<ExtArgs>
    rawMaterial?: boolean | RAW_MATERIALSDefaultArgs<ExtArgs>
  }

  export type $VARIANT_RAW_MATERIALS_TRACKERPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "VARIANT_RAW_MATERIALS_TRACKER"
    objects: {
      variant: Prisma.$SHOPIFY_VARIANTSPayload<ExtArgs>
      rawMaterial: Prisma.$RAW_MATERIALSPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      variantId: bigint
      rawMaterialId: bigint
      avgQuantity: Prisma.Decimal
      createdAt: Date
      updatedAt: Date
      deletedAt: Date | null
    }, ExtArgs["result"]["vARIANT_RAW_MATERIALS_TRACKER"]>
    composites: {}
  }

  type VARIANT_RAW_MATERIALS_TRACKERGetPayload<S extends boolean | null | undefined | VARIANT_RAW_MATERIALS_TRACKERDefaultArgs> = $Result.GetResult<Prisma.$VARIANT_RAW_MATERIALS_TRACKERPayload, S>

  type VARIANT_RAW_MATERIALS_TRACKERCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<VARIANT_RAW_MATERIALS_TRACKERFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: VARIANT_RAW_MATERIALS_TRACKERCountAggregateInputType | true
    }

  export interface VARIANT_RAW_MATERIALS_TRACKERDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['VARIANT_RAW_MATERIALS_TRACKER'], meta: { name: 'VARIANT_RAW_MATERIALS_TRACKER' } }
    /**
     * Find zero or one VARIANT_RAW_MATERIALS_TRACKER that matches the filter.
     * @param {VARIANT_RAW_MATERIALS_TRACKERFindUniqueArgs} args - Arguments to find a VARIANT_RAW_MATERIALS_TRACKER
     * @example
     * // Get one VARIANT_RAW_MATERIALS_TRACKER
     * const vARIANT_RAW_MATERIALS_TRACKER = await prisma.vARIANT_RAW_MATERIALS_TRACKER.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VARIANT_RAW_MATERIALS_TRACKERFindUniqueArgs>(args: SelectSubset<T, VARIANT_RAW_MATERIALS_TRACKERFindUniqueArgs<ExtArgs>>): Prisma__VARIANT_RAW_MATERIALS_TRACKERClient<$Result.GetResult<Prisma.$VARIANT_RAW_MATERIALS_TRACKERPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one VARIANT_RAW_MATERIALS_TRACKER that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {VARIANT_RAW_MATERIALS_TRACKERFindUniqueOrThrowArgs} args - Arguments to find a VARIANT_RAW_MATERIALS_TRACKER
     * @example
     * // Get one VARIANT_RAW_MATERIALS_TRACKER
     * const vARIANT_RAW_MATERIALS_TRACKER = await prisma.vARIANT_RAW_MATERIALS_TRACKER.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VARIANT_RAW_MATERIALS_TRACKERFindUniqueOrThrowArgs>(args: SelectSubset<T, VARIANT_RAW_MATERIALS_TRACKERFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VARIANT_RAW_MATERIALS_TRACKERClient<$Result.GetResult<Prisma.$VARIANT_RAW_MATERIALS_TRACKERPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first VARIANT_RAW_MATERIALS_TRACKER that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VARIANT_RAW_MATERIALS_TRACKERFindFirstArgs} args - Arguments to find a VARIANT_RAW_MATERIALS_TRACKER
     * @example
     * // Get one VARIANT_RAW_MATERIALS_TRACKER
     * const vARIANT_RAW_MATERIALS_TRACKER = await prisma.vARIANT_RAW_MATERIALS_TRACKER.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VARIANT_RAW_MATERIALS_TRACKERFindFirstArgs>(args?: SelectSubset<T, VARIANT_RAW_MATERIALS_TRACKERFindFirstArgs<ExtArgs>>): Prisma__VARIANT_RAW_MATERIALS_TRACKERClient<$Result.GetResult<Prisma.$VARIANT_RAW_MATERIALS_TRACKERPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first VARIANT_RAW_MATERIALS_TRACKER that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VARIANT_RAW_MATERIALS_TRACKERFindFirstOrThrowArgs} args - Arguments to find a VARIANT_RAW_MATERIALS_TRACKER
     * @example
     * // Get one VARIANT_RAW_MATERIALS_TRACKER
     * const vARIANT_RAW_MATERIALS_TRACKER = await prisma.vARIANT_RAW_MATERIALS_TRACKER.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VARIANT_RAW_MATERIALS_TRACKERFindFirstOrThrowArgs>(args?: SelectSubset<T, VARIANT_RAW_MATERIALS_TRACKERFindFirstOrThrowArgs<ExtArgs>>): Prisma__VARIANT_RAW_MATERIALS_TRACKERClient<$Result.GetResult<Prisma.$VARIANT_RAW_MATERIALS_TRACKERPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more VARIANT_RAW_MATERIALS_TRACKERS that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VARIANT_RAW_MATERIALS_TRACKERFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all VARIANT_RAW_MATERIALS_TRACKERS
     * const vARIANT_RAW_MATERIALS_TRACKERS = await prisma.vARIANT_RAW_MATERIALS_TRACKER.findMany()
     * 
     * // Get first 10 VARIANT_RAW_MATERIALS_TRACKERS
     * const vARIANT_RAW_MATERIALS_TRACKERS = await prisma.vARIANT_RAW_MATERIALS_TRACKER.findMany({ take: 10 })
     * 
     * // Only select the `variantId`
     * const vARIANT_RAW_MATERIALS_TRACKERWithVariantIdOnly = await prisma.vARIANT_RAW_MATERIALS_TRACKER.findMany({ select: { variantId: true } })
     * 
     */
    findMany<T extends VARIANT_RAW_MATERIALS_TRACKERFindManyArgs>(args?: SelectSubset<T, VARIANT_RAW_MATERIALS_TRACKERFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VARIANT_RAW_MATERIALS_TRACKERPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a VARIANT_RAW_MATERIALS_TRACKER.
     * @param {VARIANT_RAW_MATERIALS_TRACKERCreateArgs} args - Arguments to create a VARIANT_RAW_MATERIALS_TRACKER.
     * @example
     * // Create one VARIANT_RAW_MATERIALS_TRACKER
     * const VARIANT_RAW_MATERIALS_TRACKER = await prisma.vARIANT_RAW_MATERIALS_TRACKER.create({
     *   data: {
     *     // ... data to create a VARIANT_RAW_MATERIALS_TRACKER
     *   }
     * })
     * 
     */
    create<T extends VARIANT_RAW_MATERIALS_TRACKERCreateArgs>(args: SelectSubset<T, VARIANT_RAW_MATERIALS_TRACKERCreateArgs<ExtArgs>>): Prisma__VARIANT_RAW_MATERIALS_TRACKERClient<$Result.GetResult<Prisma.$VARIANT_RAW_MATERIALS_TRACKERPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many VARIANT_RAW_MATERIALS_TRACKERS.
     * @param {VARIANT_RAW_MATERIALS_TRACKERCreateManyArgs} args - Arguments to create many VARIANT_RAW_MATERIALS_TRACKERS.
     * @example
     * // Create many VARIANT_RAW_MATERIALS_TRACKERS
     * const vARIANT_RAW_MATERIALS_TRACKER = await prisma.vARIANT_RAW_MATERIALS_TRACKER.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VARIANT_RAW_MATERIALS_TRACKERCreateManyArgs>(args?: SelectSubset<T, VARIANT_RAW_MATERIALS_TRACKERCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a VARIANT_RAW_MATERIALS_TRACKER.
     * @param {VARIANT_RAW_MATERIALS_TRACKERDeleteArgs} args - Arguments to delete one VARIANT_RAW_MATERIALS_TRACKER.
     * @example
     * // Delete one VARIANT_RAW_MATERIALS_TRACKER
     * const VARIANT_RAW_MATERIALS_TRACKER = await prisma.vARIANT_RAW_MATERIALS_TRACKER.delete({
     *   where: {
     *     // ... filter to delete one VARIANT_RAW_MATERIALS_TRACKER
     *   }
     * })
     * 
     */
    delete<T extends VARIANT_RAW_MATERIALS_TRACKERDeleteArgs>(args: SelectSubset<T, VARIANT_RAW_MATERIALS_TRACKERDeleteArgs<ExtArgs>>): Prisma__VARIANT_RAW_MATERIALS_TRACKERClient<$Result.GetResult<Prisma.$VARIANT_RAW_MATERIALS_TRACKERPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one VARIANT_RAW_MATERIALS_TRACKER.
     * @param {VARIANT_RAW_MATERIALS_TRACKERUpdateArgs} args - Arguments to update one VARIANT_RAW_MATERIALS_TRACKER.
     * @example
     * // Update one VARIANT_RAW_MATERIALS_TRACKER
     * const vARIANT_RAW_MATERIALS_TRACKER = await prisma.vARIANT_RAW_MATERIALS_TRACKER.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VARIANT_RAW_MATERIALS_TRACKERUpdateArgs>(args: SelectSubset<T, VARIANT_RAW_MATERIALS_TRACKERUpdateArgs<ExtArgs>>): Prisma__VARIANT_RAW_MATERIALS_TRACKERClient<$Result.GetResult<Prisma.$VARIANT_RAW_MATERIALS_TRACKERPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more VARIANT_RAW_MATERIALS_TRACKERS.
     * @param {VARIANT_RAW_MATERIALS_TRACKERDeleteManyArgs} args - Arguments to filter VARIANT_RAW_MATERIALS_TRACKERS to delete.
     * @example
     * // Delete a few VARIANT_RAW_MATERIALS_TRACKERS
     * const { count } = await prisma.vARIANT_RAW_MATERIALS_TRACKER.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VARIANT_RAW_MATERIALS_TRACKERDeleteManyArgs>(args?: SelectSubset<T, VARIANT_RAW_MATERIALS_TRACKERDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VARIANT_RAW_MATERIALS_TRACKERS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VARIANT_RAW_MATERIALS_TRACKERUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many VARIANT_RAW_MATERIALS_TRACKERS
     * const vARIANT_RAW_MATERIALS_TRACKER = await prisma.vARIANT_RAW_MATERIALS_TRACKER.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VARIANT_RAW_MATERIALS_TRACKERUpdateManyArgs>(args: SelectSubset<T, VARIANT_RAW_MATERIALS_TRACKERUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one VARIANT_RAW_MATERIALS_TRACKER.
     * @param {VARIANT_RAW_MATERIALS_TRACKERUpsertArgs} args - Arguments to update or create a VARIANT_RAW_MATERIALS_TRACKER.
     * @example
     * // Update or create a VARIANT_RAW_MATERIALS_TRACKER
     * const vARIANT_RAW_MATERIALS_TRACKER = await prisma.vARIANT_RAW_MATERIALS_TRACKER.upsert({
     *   create: {
     *     // ... data to create a VARIANT_RAW_MATERIALS_TRACKER
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the VARIANT_RAW_MATERIALS_TRACKER we want to update
     *   }
     * })
     */
    upsert<T extends VARIANT_RAW_MATERIALS_TRACKERUpsertArgs>(args: SelectSubset<T, VARIANT_RAW_MATERIALS_TRACKERUpsertArgs<ExtArgs>>): Prisma__VARIANT_RAW_MATERIALS_TRACKERClient<$Result.GetResult<Prisma.$VARIANT_RAW_MATERIALS_TRACKERPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of VARIANT_RAW_MATERIALS_TRACKERS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VARIANT_RAW_MATERIALS_TRACKERCountArgs} args - Arguments to filter VARIANT_RAW_MATERIALS_TRACKERS to count.
     * @example
     * // Count the number of VARIANT_RAW_MATERIALS_TRACKERS
     * const count = await prisma.vARIANT_RAW_MATERIALS_TRACKER.count({
     *   where: {
     *     // ... the filter for the VARIANT_RAW_MATERIALS_TRACKERS we want to count
     *   }
     * })
    **/
    count<T extends VARIANT_RAW_MATERIALS_TRACKERCountArgs>(
      args?: Subset<T, VARIANT_RAW_MATERIALS_TRACKERCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VARIANT_RAW_MATERIALS_TRACKERCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a VARIANT_RAW_MATERIALS_TRACKER.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VARIANT_RAW_MATERIALS_TRACKERAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VARIANT_RAW_MATERIALS_TRACKERAggregateArgs>(args: Subset<T, VARIANT_RAW_MATERIALS_TRACKERAggregateArgs>): Prisma.PrismaPromise<GetVARIANT_RAW_MATERIALS_TRACKERAggregateType<T>>

    /**
     * Group by VARIANT_RAW_MATERIALS_TRACKER.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VARIANT_RAW_MATERIALS_TRACKERGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VARIANT_RAW_MATERIALS_TRACKERGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VARIANT_RAW_MATERIALS_TRACKERGroupByArgs['orderBy'] }
        : { orderBy?: VARIANT_RAW_MATERIALS_TRACKERGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VARIANT_RAW_MATERIALS_TRACKERGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVARIANT_RAW_MATERIALS_TRACKERGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the VARIANT_RAW_MATERIALS_TRACKER model
   */
  readonly fields: VARIANT_RAW_MATERIALS_TRACKERFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for VARIANT_RAW_MATERIALS_TRACKER.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VARIANT_RAW_MATERIALS_TRACKERClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    variant<T extends SHOPIFY_VARIANTSDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SHOPIFY_VARIANTSDefaultArgs<ExtArgs>>): Prisma__SHOPIFY_VARIANTSClient<$Result.GetResult<Prisma.$SHOPIFY_VARIANTSPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    rawMaterial<T extends RAW_MATERIALSDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RAW_MATERIALSDefaultArgs<ExtArgs>>): Prisma__RAW_MATERIALSClient<$Result.GetResult<Prisma.$RAW_MATERIALSPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the VARIANT_RAW_MATERIALS_TRACKER model
   */ 
  interface VARIANT_RAW_MATERIALS_TRACKERFieldRefs {
    readonly variantId: FieldRef<"VARIANT_RAW_MATERIALS_TRACKER", 'BigInt'>
    readonly rawMaterialId: FieldRef<"VARIANT_RAW_MATERIALS_TRACKER", 'BigInt'>
    readonly avgQuantity: FieldRef<"VARIANT_RAW_MATERIALS_TRACKER", 'Decimal'>
    readonly createdAt: FieldRef<"VARIANT_RAW_MATERIALS_TRACKER", 'DateTime'>
    readonly updatedAt: FieldRef<"VARIANT_RAW_MATERIALS_TRACKER", 'DateTime'>
    readonly deletedAt: FieldRef<"VARIANT_RAW_MATERIALS_TRACKER", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * VARIANT_RAW_MATERIALS_TRACKER findUnique
   */
  export type VARIANT_RAW_MATERIALS_TRACKERFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VARIANT_RAW_MATERIALS_TRACKER
     */
    select?: VARIANT_RAW_MATERIALS_TRACKERSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VARIANT_RAW_MATERIALS_TRACKER
     */
    omit?: VARIANT_RAW_MATERIALS_TRACKEROmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VARIANT_RAW_MATERIALS_TRACKERInclude<ExtArgs> | null
    /**
     * Filter, which VARIANT_RAW_MATERIALS_TRACKER to fetch.
     */
    where: VARIANT_RAW_MATERIALS_TRACKERWhereUniqueInput
  }

  /**
   * VARIANT_RAW_MATERIALS_TRACKER findUniqueOrThrow
   */
  export type VARIANT_RAW_MATERIALS_TRACKERFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VARIANT_RAW_MATERIALS_TRACKER
     */
    select?: VARIANT_RAW_MATERIALS_TRACKERSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VARIANT_RAW_MATERIALS_TRACKER
     */
    omit?: VARIANT_RAW_MATERIALS_TRACKEROmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VARIANT_RAW_MATERIALS_TRACKERInclude<ExtArgs> | null
    /**
     * Filter, which VARIANT_RAW_MATERIALS_TRACKER to fetch.
     */
    where: VARIANT_RAW_MATERIALS_TRACKERWhereUniqueInput
  }

  /**
   * VARIANT_RAW_MATERIALS_TRACKER findFirst
   */
  export type VARIANT_RAW_MATERIALS_TRACKERFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VARIANT_RAW_MATERIALS_TRACKER
     */
    select?: VARIANT_RAW_MATERIALS_TRACKERSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VARIANT_RAW_MATERIALS_TRACKER
     */
    omit?: VARIANT_RAW_MATERIALS_TRACKEROmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VARIANT_RAW_MATERIALS_TRACKERInclude<ExtArgs> | null
    /**
     * Filter, which VARIANT_RAW_MATERIALS_TRACKER to fetch.
     */
    where?: VARIANT_RAW_MATERIALS_TRACKERWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VARIANT_RAW_MATERIALS_TRACKERS to fetch.
     */
    orderBy?: VARIANT_RAW_MATERIALS_TRACKEROrderByWithRelationInput | VARIANT_RAW_MATERIALS_TRACKEROrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VARIANT_RAW_MATERIALS_TRACKERS.
     */
    cursor?: VARIANT_RAW_MATERIALS_TRACKERWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VARIANT_RAW_MATERIALS_TRACKERS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VARIANT_RAW_MATERIALS_TRACKERS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VARIANT_RAW_MATERIALS_TRACKERS.
     */
    distinct?: VARIANT_RAW_MATERIALS_TRACKERScalarFieldEnum | VARIANT_RAW_MATERIALS_TRACKERScalarFieldEnum[]
  }

  /**
   * VARIANT_RAW_MATERIALS_TRACKER findFirstOrThrow
   */
  export type VARIANT_RAW_MATERIALS_TRACKERFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VARIANT_RAW_MATERIALS_TRACKER
     */
    select?: VARIANT_RAW_MATERIALS_TRACKERSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VARIANT_RAW_MATERIALS_TRACKER
     */
    omit?: VARIANT_RAW_MATERIALS_TRACKEROmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VARIANT_RAW_MATERIALS_TRACKERInclude<ExtArgs> | null
    /**
     * Filter, which VARIANT_RAW_MATERIALS_TRACKER to fetch.
     */
    where?: VARIANT_RAW_MATERIALS_TRACKERWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VARIANT_RAW_MATERIALS_TRACKERS to fetch.
     */
    orderBy?: VARIANT_RAW_MATERIALS_TRACKEROrderByWithRelationInput | VARIANT_RAW_MATERIALS_TRACKEROrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VARIANT_RAW_MATERIALS_TRACKERS.
     */
    cursor?: VARIANT_RAW_MATERIALS_TRACKERWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VARIANT_RAW_MATERIALS_TRACKERS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VARIANT_RAW_MATERIALS_TRACKERS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VARIANT_RAW_MATERIALS_TRACKERS.
     */
    distinct?: VARIANT_RAW_MATERIALS_TRACKERScalarFieldEnum | VARIANT_RAW_MATERIALS_TRACKERScalarFieldEnum[]
  }

  /**
   * VARIANT_RAW_MATERIALS_TRACKER findMany
   */
  export type VARIANT_RAW_MATERIALS_TRACKERFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VARIANT_RAW_MATERIALS_TRACKER
     */
    select?: VARIANT_RAW_MATERIALS_TRACKERSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VARIANT_RAW_MATERIALS_TRACKER
     */
    omit?: VARIANT_RAW_MATERIALS_TRACKEROmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VARIANT_RAW_MATERIALS_TRACKERInclude<ExtArgs> | null
    /**
     * Filter, which VARIANT_RAW_MATERIALS_TRACKERS to fetch.
     */
    where?: VARIANT_RAW_MATERIALS_TRACKERWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VARIANT_RAW_MATERIALS_TRACKERS to fetch.
     */
    orderBy?: VARIANT_RAW_MATERIALS_TRACKEROrderByWithRelationInput | VARIANT_RAW_MATERIALS_TRACKEROrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing VARIANT_RAW_MATERIALS_TRACKERS.
     */
    cursor?: VARIANT_RAW_MATERIALS_TRACKERWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VARIANT_RAW_MATERIALS_TRACKERS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VARIANT_RAW_MATERIALS_TRACKERS.
     */
    skip?: number
    distinct?: VARIANT_RAW_MATERIALS_TRACKERScalarFieldEnum | VARIANT_RAW_MATERIALS_TRACKERScalarFieldEnum[]
  }

  /**
   * VARIANT_RAW_MATERIALS_TRACKER create
   */
  export type VARIANT_RAW_MATERIALS_TRACKERCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VARIANT_RAW_MATERIALS_TRACKER
     */
    select?: VARIANT_RAW_MATERIALS_TRACKERSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VARIANT_RAW_MATERIALS_TRACKER
     */
    omit?: VARIANT_RAW_MATERIALS_TRACKEROmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VARIANT_RAW_MATERIALS_TRACKERInclude<ExtArgs> | null
    /**
     * The data needed to create a VARIANT_RAW_MATERIALS_TRACKER.
     */
    data: XOR<VARIANT_RAW_MATERIALS_TRACKERCreateInput, VARIANT_RAW_MATERIALS_TRACKERUncheckedCreateInput>
  }

  /**
   * VARIANT_RAW_MATERIALS_TRACKER createMany
   */
  export type VARIANT_RAW_MATERIALS_TRACKERCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many VARIANT_RAW_MATERIALS_TRACKERS.
     */
    data: VARIANT_RAW_MATERIALS_TRACKERCreateManyInput | VARIANT_RAW_MATERIALS_TRACKERCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * VARIANT_RAW_MATERIALS_TRACKER update
   */
  export type VARIANT_RAW_MATERIALS_TRACKERUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VARIANT_RAW_MATERIALS_TRACKER
     */
    select?: VARIANT_RAW_MATERIALS_TRACKERSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VARIANT_RAW_MATERIALS_TRACKER
     */
    omit?: VARIANT_RAW_MATERIALS_TRACKEROmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VARIANT_RAW_MATERIALS_TRACKERInclude<ExtArgs> | null
    /**
     * The data needed to update a VARIANT_RAW_MATERIALS_TRACKER.
     */
    data: XOR<VARIANT_RAW_MATERIALS_TRACKERUpdateInput, VARIANT_RAW_MATERIALS_TRACKERUncheckedUpdateInput>
    /**
     * Choose, which VARIANT_RAW_MATERIALS_TRACKER to update.
     */
    where: VARIANT_RAW_MATERIALS_TRACKERWhereUniqueInput
  }

  /**
   * VARIANT_RAW_MATERIALS_TRACKER updateMany
   */
  export type VARIANT_RAW_MATERIALS_TRACKERUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update VARIANT_RAW_MATERIALS_TRACKERS.
     */
    data: XOR<VARIANT_RAW_MATERIALS_TRACKERUpdateManyMutationInput, VARIANT_RAW_MATERIALS_TRACKERUncheckedUpdateManyInput>
    /**
     * Filter which VARIANT_RAW_MATERIALS_TRACKERS to update
     */
    where?: VARIANT_RAW_MATERIALS_TRACKERWhereInput
  }

  /**
   * VARIANT_RAW_MATERIALS_TRACKER upsert
   */
  export type VARIANT_RAW_MATERIALS_TRACKERUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VARIANT_RAW_MATERIALS_TRACKER
     */
    select?: VARIANT_RAW_MATERIALS_TRACKERSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VARIANT_RAW_MATERIALS_TRACKER
     */
    omit?: VARIANT_RAW_MATERIALS_TRACKEROmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VARIANT_RAW_MATERIALS_TRACKERInclude<ExtArgs> | null
    /**
     * The filter to search for the VARIANT_RAW_MATERIALS_TRACKER to update in case it exists.
     */
    where: VARIANT_RAW_MATERIALS_TRACKERWhereUniqueInput
    /**
     * In case the VARIANT_RAW_MATERIALS_TRACKER found by the `where` argument doesn't exist, create a new VARIANT_RAW_MATERIALS_TRACKER with this data.
     */
    create: XOR<VARIANT_RAW_MATERIALS_TRACKERCreateInput, VARIANT_RAW_MATERIALS_TRACKERUncheckedCreateInput>
    /**
     * In case the VARIANT_RAW_MATERIALS_TRACKER was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VARIANT_RAW_MATERIALS_TRACKERUpdateInput, VARIANT_RAW_MATERIALS_TRACKERUncheckedUpdateInput>
  }

  /**
   * VARIANT_RAW_MATERIALS_TRACKER delete
   */
  export type VARIANT_RAW_MATERIALS_TRACKERDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VARIANT_RAW_MATERIALS_TRACKER
     */
    select?: VARIANT_RAW_MATERIALS_TRACKERSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VARIANT_RAW_MATERIALS_TRACKER
     */
    omit?: VARIANT_RAW_MATERIALS_TRACKEROmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VARIANT_RAW_MATERIALS_TRACKERInclude<ExtArgs> | null
    /**
     * Filter which VARIANT_RAW_MATERIALS_TRACKER to delete.
     */
    where: VARIANT_RAW_MATERIALS_TRACKERWhereUniqueInput
  }

  /**
   * VARIANT_RAW_MATERIALS_TRACKER deleteMany
   */
  export type VARIANT_RAW_MATERIALS_TRACKERDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VARIANT_RAW_MATERIALS_TRACKERS to delete
     */
    where?: VARIANT_RAW_MATERIALS_TRACKERWhereInput
  }

  /**
   * VARIANT_RAW_MATERIALS_TRACKER without action
   */
  export type VARIANT_RAW_MATERIALS_TRACKERDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VARIANT_RAW_MATERIALS_TRACKER
     */
    select?: VARIANT_RAW_MATERIALS_TRACKERSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VARIANT_RAW_MATERIALS_TRACKER
     */
    omit?: VARIANT_RAW_MATERIALS_TRACKEROmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VARIANT_RAW_MATERIALS_TRACKERInclude<ExtArgs> | null
  }


  /**
   * Model CATEGORIES
   */

  export type AggregateCATEGORIES = {
    _count: CATEGORIESCountAggregateOutputType | null
    _avg: CATEGORIESAvgAggregateOutputType | null
    _sum: CATEGORIESSumAggregateOutputType | null
    _min: CATEGORIESMinAggregateOutputType | null
    _max: CATEGORIESMaxAggregateOutputType | null
  }

  export type CATEGORIESAvgAggregateOutputType = {
    id: number | null
  }

  export type CATEGORIESSumAggregateOutputType = {
    id: number | null
  }

  export type CATEGORIESMinAggregateOutputType = {
    id: number | null
    name: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CATEGORIESMaxAggregateOutputType = {
    id: number | null
    name: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CATEGORIESCountAggregateOutputType = {
    id: number
    name: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CATEGORIESAvgAggregateInputType = {
    id?: true
  }

  export type CATEGORIESSumAggregateInputType = {
    id?: true
  }

  export type CATEGORIESMinAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CATEGORIESMaxAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CATEGORIESCountAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CATEGORIESAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CATEGORIES to aggregate.
     */
    where?: CATEGORIESWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CATEGORIES to fetch.
     */
    orderBy?: CATEGORIESOrderByWithRelationInput | CATEGORIESOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CATEGORIESWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CATEGORIES from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CATEGORIES.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CATEGORIES
    **/
    _count?: true | CATEGORIESCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CATEGORIESAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CATEGORIESSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CATEGORIESMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CATEGORIESMaxAggregateInputType
  }

  export type GetCATEGORIESAggregateType<T extends CATEGORIESAggregateArgs> = {
        [P in keyof T & keyof AggregateCATEGORIES]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCATEGORIES[P]>
      : GetScalarType<T[P], AggregateCATEGORIES[P]>
  }




  export type CATEGORIESGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CATEGORIESWhereInput
    orderBy?: CATEGORIESOrderByWithAggregationInput | CATEGORIESOrderByWithAggregationInput[]
    by: CATEGORIESScalarFieldEnum[] | CATEGORIESScalarFieldEnum
    having?: CATEGORIESScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CATEGORIESCountAggregateInputType | true
    _avg?: CATEGORIESAvgAggregateInputType
    _sum?: CATEGORIESSumAggregateInputType
    _min?: CATEGORIESMinAggregateInputType
    _max?: CATEGORIESMaxAggregateInputType
  }

  export type CATEGORIESGroupByOutputType = {
    id: number
    name: string
    createdAt: Date
    updatedAt: Date
    _count: CATEGORIESCountAggregateOutputType | null
    _avg: CATEGORIESAvgAggregateOutputType | null
    _sum: CATEGORIESSumAggregateOutputType | null
    _min: CATEGORIESMinAggregateOutputType | null
    _max: CATEGORIESMaxAggregateOutputType | null
  }

  type GetCATEGORIESGroupByPayload<T extends CATEGORIESGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CATEGORIESGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CATEGORIESGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CATEGORIESGroupByOutputType[P]>
            : GetScalarType<T[P], CATEGORIESGroupByOutputType[P]>
        }
      >
    >


  export type CATEGORIESSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    ShopifyProducts?: boolean | CATEGORIES$ShopifyProductsArgs<ExtArgs>
    _count?: boolean | CATEGORIESCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cATEGORIES"]>



  export type CATEGORIESSelectScalar = {
    id?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CATEGORIESOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "createdAt" | "updatedAt", ExtArgs["result"]["cATEGORIES"]>
  export type CATEGORIESInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ShopifyProducts?: boolean | CATEGORIES$ShopifyProductsArgs<ExtArgs>
    _count?: boolean | CATEGORIESCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $CATEGORIESPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CATEGORIES"
    objects: {
      ShopifyProducts: Prisma.$SHOPIFY_PRODUCTSPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["cATEGORIES"]>
    composites: {}
  }

  type CATEGORIESGetPayload<S extends boolean | null | undefined | CATEGORIESDefaultArgs> = $Result.GetResult<Prisma.$CATEGORIESPayload, S>

  type CATEGORIESCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CATEGORIESFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CATEGORIESCountAggregateInputType | true
    }

  export interface CATEGORIESDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CATEGORIES'], meta: { name: 'CATEGORIES' } }
    /**
     * Find zero or one CATEGORIES that matches the filter.
     * @param {CATEGORIESFindUniqueArgs} args - Arguments to find a CATEGORIES
     * @example
     * // Get one CATEGORIES
     * const cATEGORIES = await prisma.cATEGORIES.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CATEGORIESFindUniqueArgs>(args: SelectSubset<T, CATEGORIESFindUniqueArgs<ExtArgs>>): Prisma__CATEGORIESClient<$Result.GetResult<Prisma.$CATEGORIESPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one CATEGORIES that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CATEGORIESFindUniqueOrThrowArgs} args - Arguments to find a CATEGORIES
     * @example
     * // Get one CATEGORIES
     * const cATEGORIES = await prisma.cATEGORIES.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CATEGORIESFindUniqueOrThrowArgs>(args: SelectSubset<T, CATEGORIESFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CATEGORIESClient<$Result.GetResult<Prisma.$CATEGORIESPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first CATEGORIES that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CATEGORIESFindFirstArgs} args - Arguments to find a CATEGORIES
     * @example
     * // Get one CATEGORIES
     * const cATEGORIES = await prisma.cATEGORIES.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CATEGORIESFindFirstArgs>(args?: SelectSubset<T, CATEGORIESFindFirstArgs<ExtArgs>>): Prisma__CATEGORIESClient<$Result.GetResult<Prisma.$CATEGORIESPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first CATEGORIES that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CATEGORIESFindFirstOrThrowArgs} args - Arguments to find a CATEGORIES
     * @example
     * // Get one CATEGORIES
     * const cATEGORIES = await prisma.cATEGORIES.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CATEGORIESFindFirstOrThrowArgs>(args?: SelectSubset<T, CATEGORIESFindFirstOrThrowArgs<ExtArgs>>): Prisma__CATEGORIESClient<$Result.GetResult<Prisma.$CATEGORIESPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more CATEGORIES that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CATEGORIESFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CATEGORIES
     * const cATEGORIES = await prisma.cATEGORIES.findMany()
     * 
     * // Get first 10 CATEGORIES
     * const cATEGORIES = await prisma.cATEGORIES.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const cATEGORIESWithIdOnly = await prisma.cATEGORIES.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CATEGORIESFindManyArgs>(args?: SelectSubset<T, CATEGORIESFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CATEGORIESPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a CATEGORIES.
     * @param {CATEGORIESCreateArgs} args - Arguments to create a CATEGORIES.
     * @example
     * // Create one CATEGORIES
     * const CATEGORIES = await prisma.cATEGORIES.create({
     *   data: {
     *     // ... data to create a CATEGORIES
     *   }
     * })
     * 
     */
    create<T extends CATEGORIESCreateArgs>(args: SelectSubset<T, CATEGORIESCreateArgs<ExtArgs>>): Prisma__CATEGORIESClient<$Result.GetResult<Prisma.$CATEGORIESPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many CATEGORIES.
     * @param {CATEGORIESCreateManyArgs} args - Arguments to create many CATEGORIES.
     * @example
     * // Create many CATEGORIES
     * const cATEGORIES = await prisma.cATEGORIES.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CATEGORIESCreateManyArgs>(args?: SelectSubset<T, CATEGORIESCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a CATEGORIES.
     * @param {CATEGORIESDeleteArgs} args - Arguments to delete one CATEGORIES.
     * @example
     * // Delete one CATEGORIES
     * const CATEGORIES = await prisma.cATEGORIES.delete({
     *   where: {
     *     // ... filter to delete one CATEGORIES
     *   }
     * })
     * 
     */
    delete<T extends CATEGORIESDeleteArgs>(args: SelectSubset<T, CATEGORIESDeleteArgs<ExtArgs>>): Prisma__CATEGORIESClient<$Result.GetResult<Prisma.$CATEGORIESPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one CATEGORIES.
     * @param {CATEGORIESUpdateArgs} args - Arguments to update one CATEGORIES.
     * @example
     * // Update one CATEGORIES
     * const cATEGORIES = await prisma.cATEGORIES.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CATEGORIESUpdateArgs>(args: SelectSubset<T, CATEGORIESUpdateArgs<ExtArgs>>): Prisma__CATEGORIESClient<$Result.GetResult<Prisma.$CATEGORIESPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more CATEGORIES.
     * @param {CATEGORIESDeleteManyArgs} args - Arguments to filter CATEGORIES to delete.
     * @example
     * // Delete a few CATEGORIES
     * const { count } = await prisma.cATEGORIES.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CATEGORIESDeleteManyArgs>(args?: SelectSubset<T, CATEGORIESDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CATEGORIES.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CATEGORIESUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CATEGORIES
     * const cATEGORIES = await prisma.cATEGORIES.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CATEGORIESUpdateManyArgs>(args: SelectSubset<T, CATEGORIESUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CATEGORIES.
     * @param {CATEGORIESUpsertArgs} args - Arguments to update or create a CATEGORIES.
     * @example
     * // Update or create a CATEGORIES
     * const cATEGORIES = await prisma.cATEGORIES.upsert({
     *   create: {
     *     // ... data to create a CATEGORIES
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CATEGORIES we want to update
     *   }
     * })
     */
    upsert<T extends CATEGORIESUpsertArgs>(args: SelectSubset<T, CATEGORIESUpsertArgs<ExtArgs>>): Prisma__CATEGORIESClient<$Result.GetResult<Prisma.$CATEGORIESPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of CATEGORIES.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CATEGORIESCountArgs} args - Arguments to filter CATEGORIES to count.
     * @example
     * // Count the number of CATEGORIES
     * const count = await prisma.cATEGORIES.count({
     *   where: {
     *     // ... the filter for the CATEGORIES we want to count
     *   }
     * })
    **/
    count<T extends CATEGORIESCountArgs>(
      args?: Subset<T, CATEGORIESCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CATEGORIESCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CATEGORIES.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CATEGORIESAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CATEGORIESAggregateArgs>(args: Subset<T, CATEGORIESAggregateArgs>): Prisma.PrismaPromise<GetCATEGORIESAggregateType<T>>

    /**
     * Group by CATEGORIES.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CATEGORIESGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CATEGORIESGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CATEGORIESGroupByArgs['orderBy'] }
        : { orderBy?: CATEGORIESGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CATEGORIESGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCATEGORIESGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CATEGORIES model
   */
  readonly fields: CATEGORIESFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CATEGORIES.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CATEGORIESClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    ShopifyProducts<T extends CATEGORIES$ShopifyProductsArgs<ExtArgs> = {}>(args?: Subset<T, CATEGORIES$ShopifyProductsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SHOPIFY_PRODUCTSPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CATEGORIES model
   */ 
  interface CATEGORIESFieldRefs {
    readonly id: FieldRef<"CATEGORIES", 'Int'>
    readonly name: FieldRef<"CATEGORIES", 'String'>
    readonly createdAt: FieldRef<"CATEGORIES", 'DateTime'>
    readonly updatedAt: FieldRef<"CATEGORIES", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CATEGORIES findUnique
   */
  export type CATEGORIESFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CATEGORIES
     */
    select?: CATEGORIESSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CATEGORIES
     */
    omit?: CATEGORIESOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CATEGORIESInclude<ExtArgs> | null
    /**
     * Filter, which CATEGORIES to fetch.
     */
    where: CATEGORIESWhereUniqueInput
  }

  /**
   * CATEGORIES findUniqueOrThrow
   */
  export type CATEGORIESFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CATEGORIES
     */
    select?: CATEGORIESSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CATEGORIES
     */
    omit?: CATEGORIESOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CATEGORIESInclude<ExtArgs> | null
    /**
     * Filter, which CATEGORIES to fetch.
     */
    where: CATEGORIESWhereUniqueInput
  }

  /**
   * CATEGORIES findFirst
   */
  export type CATEGORIESFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CATEGORIES
     */
    select?: CATEGORIESSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CATEGORIES
     */
    omit?: CATEGORIESOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CATEGORIESInclude<ExtArgs> | null
    /**
     * Filter, which CATEGORIES to fetch.
     */
    where?: CATEGORIESWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CATEGORIES to fetch.
     */
    orderBy?: CATEGORIESOrderByWithRelationInput | CATEGORIESOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CATEGORIES.
     */
    cursor?: CATEGORIESWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CATEGORIES from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CATEGORIES.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CATEGORIES.
     */
    distinct?: CATEGORIESScalarFieldEnum | CATEGORIESScalarFieldEnum[]
  }

  /**
   * CATEGORIES findFirstOrThrow
   */
  export type CATEGORIESFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CATEGORIES
     */
    select?: CATEGORIESSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CATEGORIES
     */
    omit?: CATEGORIESOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CATEGORIESInclude<ExtArgs> | null
    /**
     * Filter, which CATEGORIES to fetch.
     */
    where?: CATEGORIESWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CATEGORIES to fetch.
     */
    orderBy?: CATEGORIESOrderByWithRelationInput | CATEGORIESOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CATEGORIES.
     */
    cursor?: CATEGORIESWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CATEGORIES from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CATEGORIES.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CATEGORIES.
     */
    distinct?: CATEGORIESScalarFieldEnum | CATEGORIESScalarFieldEnum[]
  }

  /**
   * CATEGORIES findMany
   */
  export type CATEGORIESFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CATEGORIES
     */
    select?: CATEGORIESSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CATEGORIES
     */
    omit?: CATEGORIESOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CATEGORIESInclude<ExtArgs> | null
    /**
     * Filter, which CATEGORIES to fetch.
     */
    where?: CATEGORIESWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CATEGORIES to fetch.
     */
    orderBy?: CATEGORIESOrderByWithRelationInput | CATEGORIESOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CATEGORIES.
     */
    cursor?: CATEGORIESWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CATEGORIES from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CATEGORIES.
     */
    skip?: number
    distinct?: CATEGORIESScalarFieldEnum | CATEGORIESScalarFieldEnum[]
  }

  /**
   * CATEGORIES create
   */
  export type CATEGORIESCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CATEGORIES
     */
    select?: CATEGORIESSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CATEGORIES
     */
    omit?: CATEGORIESOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CATEGORIESInclude<ExtArgs> | null
    /**
     * The data needed to create a CATEGORIES.
     */
    data: XOR<CATEGORIESCreateInput, CATEGORIESUncheckedCreateInput>
  }

  /**
   * CATEGORIES createMany
   */
  export type CATEGORIESCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CATEGORIES.
     */
    data: CATEGORIESCreateManyInput | CATEGORIESCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CATEGORIES update
   */
  export type CATEGORIESUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CATEGORIES
     */
    select?: CATEGORIESSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CATEGORIES
     */
    omit?: CATEGORIESOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CATEGORIESInclude<ExtArgs> | null
    /**
     * The data needed to update a CATEGORIES.
     */
    data: XOR<CATEGORIESUpdateInput, CATEGORIESUncheckedUpdateInput>
    /**
     * Choose, which CATEGORIES to update.
     */
    where: CATEGORIESWhereUniqueInput
  }

  /**
   * CATEGORIES updateMany
   */
  export type CATEGORIESUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CATEGORIES.
     */
    data: XOR<CATEGORIESUpdateManyMutationInput, CATEGORIESUncheckedUpdateManyInput>
    /**
     * Filter which CATEGORIES to update
     */
    where?: CATEGORIESWhereInput
  }

  /**
   * CATEGORIES upsert
   */
  export type CATEGORIESUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CATEGORIES
     */
    select?: CATEGORIESSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CATEGORIES
     */
    omit?: CATEGORIESOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CATEGORIESInclude<ExtArgs> | null
    /**
     * The filter to search for the CATEGORIES to update in case it exists.
     */
    where: CATEGORIESWhereUniqueInput
    /**
     * In case the CATEGORIES found by the `where` argument doesn't exist, create a new CATEGORIES with this data.
     */
    create: XOR<CATEGORIESCreateInput, CATEGORIESUncheckedCreateInput>
    /**
     * In case the CATEGORIES was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CATEGORIESUpdateInput, CATEGORIESUncheckedUpdateInput>
  }

  /**
   * CATEGORIES delete
   */
  export type CATEGORIESDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CATEGORIES
     */
    select?: CATEGORIESSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CATEGORIES
     */
    omit?: CATEGORIESOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CATEGORIESInclude<ExtArgs> | null
    /**
     * Filter which CATEGORIES to delete.
     */
    where: CATEGORIESWhereUniqueInput
  }

  /**
   * CATEGORIES deleteMany
   */
  export type CATEGORIESDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CATEGORIES to delete
     */
    where?: CATEGORIESWhereInput
  }

  /**
   * CATEGORIES.ShopifyProducts
   */
  export type CATEGORIES$ShopifyProductsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SHOPIFY_PRODUCTS
     */
    select?: SHOPIFY_PRODUCTSSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SHOPIFY_PRODUCTS
     */
    omit?: SHOPIFY_PRODUCTSOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SHOPIFY_PRODUCTSInclude<ExtArgs> | null
    where?: SHOPIFY_PRODUCTSWhereInput
    orderBy?: SHOPIFY_PRODUCTSOrderByWithRelationInput | SHOPIFY_PRODUCTSOrderByWithRelationInput[]
    cursor?: SHOPIFY_PRODUCTSWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SHOPIFY_PRODUCTSScalarFieldEnum | SHOPIFY_PRODUCTSScalarFieldEnum[]
  }

  /**
   * CATEGORIES without action
   */
  export type CATEGORIESDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CATEGORIES
     */
    select?: CATEGORIESSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CATEGORIES
     */
    omit?: CATEGORIESOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CATEGORIESInclude<ExtArgs> | null
  }


  /**
   * Model SHOPIFY_PRODUCTS
   */

  export type AggregateSHOPIFY_PRODUCTS = {
    _count: SHOPIFY_PRODUCTSCountAggregateOutputType | null
    _avg: SHOPIFY_PRODUCTSAvgAggregateOutputType | null
    _sum: SHOPIFY_PRODUCTSSumAggregateOutputType | null
    _min: SHOPIFY_PRODUCTSMinAggregateOutputType | null
    _max: SHOPIFY_PRODUCTSMaxAggregateOutputType | null
  }

  export type SHOPIFY_PRODUCTSAvgAggregateOutputType = {
    id: number | null
    categoryId: number | null
    price: Decimal | null
  }

  export type SHOPIFY_PRODUCTSSumAggregateOutputType = {
    id: bigint | null
    categoryId: number | null
    price: Decimal | null
  }

  export type SHOPIFY_PRODUCTSMinAggregateOutputType = {
    id: bigint | null
    name: string | null
    categoryId: number | null
    price: Decimal | null
    status: string | null
    img: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SHOPIFY_PRODUCTSMaxAggregateOutputType = {
    id: bigint | null
    name: string | null
    categoryId: number | null
    price: Decimal | null
    status: string | null
    img: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SHOPIFY_PRODUCTSCountAggregateOutputType = {
    id: number
    name: number
    categoryId: number
    price: number
    status: number
    img: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SHOPIFY_PRODUCTSAvgAggregateInputType = {
    id?: true
    categoryId?: true
    price?: true
  }

  export type SHOPIFY_PRODUCTSSumAggregateInputType = {
    id?: true
    categoryId?: true
    price?: true
  }

  export type SHOPIFY_PRODUCTSMinAggregateInputType = {
    id?: true
    name?: true
    categoryId?: true
    price?: true
    status?: true
    img?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SHOPIFY_PRODUCTSMaxAggregateInputType = {
    id?: true
    name?: true
    categoryId?: true
    price?: true
    status?: true
    img?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SHOPIFY_PRODUCTSCountAggregateInputType = {
    id?: true
    name?: true
    categoryId?: true
    price?: true
    status?: true
    img?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SHOPIFY_PRODUCTSAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SHOPIFY_PRODUCTS to aggregate.
     */
    where?: SHOPIFY_PRODUCTSWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SHOPIFY_PRODUCTS to fetch.
     */
    orderBy?: SHOPIFY_PRODUCTSOrderByWithRelationInput | SHOPIFY_PRODUCTSOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SHOPIFY_PRODUCTSWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SHOPIFY_PRODUCTS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SHOPIFY_PRODUCTS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SHOPIFY_PRODUCTS
    **/
    _count?: true | SHOPIFY_PRODUCTSCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SHOPIFY_PRODUCTSAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SHOPIFY_PRODUCTSSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SHOPIFY_PRODUCTSMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SHOPIFY_PRODUCTSMaxAggregateInputType
  }

  export type GetSHOPIFY_PRODUCTSAggregateType<T extends SHOPIFY_PRODUCTSAggregateArgs> = {
        [P in keyof T & keyof AggregateSHOPIFY_PRODUCTS]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSHOPIFY_PRODUCTS[P]>
      : GetScalarType<T[P], AggregateSHOPIFY_PRODUCTS[P]>
  }




  export type SHOPIFY_PRODUCTSGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SHOPIFY_PRODUCTSWhereInput
    orderBy?: SHOPIFY_PRODUCTSOrderByWithAggregationInput | SHOPIFY_PRODUCTSOrderByWithAggregationInput[]
    by: SHOPIFY_PRODUCTSScalarFieldEnum[] | SHOPIFY_PRODUCTSScalarFieldEnum
    having?: SHOPIFY_PRODUCTSScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SHOPIFY_PRODUCTSCountAggregateInputType | true
    _avg?: SHOPIFY_PRODUCTSAvgAggregateInputType
    _sum?: SHOPIFY_PRODUCTSSumAggregateInputType
    _min?: SHOPIFY_PRODUCTSMinAggregateInputType
    _max?: SHOPIFY_PRODUCTSMaxAggregateInputType
  }

  export type SHOPIFY_PRODUCTSGroupByOutputType = {
    id: bigint
    name: string
    categoryId: number
    price: Decimal
    status: string | null
    img: string | null
    createdAt: Date
    updatedAt: Date
    _count: SHOPIFY_PRODUCTSCountAggregateOutputType | null
    _avg: SHOPIFY_PRODUCTSAvgAggregateOutputType | null
    _sum: SHOPIFY_PRODUCTSSumAggregateOutputType | null
    _min: SHOPIFY_PRODUCTSMinAggregateOutputType | null
    _max: SHOPIFY_PRODUCTSMaxAggregateOutputType | null
  }

  type GetSHOPIFY_PRODUCTSGroupByPayload<T extends SHOPIFY_PRODUCTSGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SHOPIFY_PRODUCTSGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SHOPIFY_PRODUCTSGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SHOPIFY_PRODUCTSGroupByOutputType[P]>
            : GetScalarType<T[P], SHOPIFY_PRODUCTSGroupByOutputType[P]>
        }
      >
    >


  export type SHOPIFY_PRODUCTSSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    categoryId?: boolean
    price?: boolean
    status?: boolean
    img?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    category?: boolean | CATEGORIESDefaultArgs<ExtArgs>
    ShopifyVariants?: boolean | SHOPIFY_PRODUCTS$ShopifyVariantsArgs<ExtArgs>
    WIPProducts?: boolean | SHOPIFY_PRODUCTS$WIPProductsArgs<ExtArgs>
    _count?: boolean | SHOPIFY_PRODUCTSCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["sHOPIFY_PRODUCTS"]>



  export type SHOPIFY_PRODUCTSSelectScalar = {
    id?: boolean
    name?: boolean
    categoryId?: boolean
    price?: boolean
    status?: boolean
    img?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SHOPIFY_PRODUCTSOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "categoryId" | "price" | "status" | "img" | "createdAt" | "updatedAt", ExtArgs["result"]["sHOPIFY_PRODUCTS"]>
  export type SHOPIFY_PRODUCTSInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    category?: boolean | CATEGORIESDefaultArgs<ExtArgs>
    ShopifyVariants?: boolean | SHOPIFY_PRODUCTS$ShopifyVariantsArgs<ExtArgs>
    WIPProducts?: boolean | SHOPIFY_PRODUCTS$WIPProductsArgs<ExtArgs>
    _count?: boolean | SHOPIFY_PRODUCTSCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $SHOPIFY_PRODUCTSPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SHOPIFY_PRODUCTS"
    objects: {
      category: Prisma.$CATEGORIESPayload<ExtArgs>
      ShopifyVariants: Prisma.$SHOPIFY_VARIANTSPayload<ExtArgs>[]
      WIPProducts: Prisma.$WIP_PRODUCTSPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: bigint
      name: string
      categoryId: number
      price: Prisma.Decimal
      status: string | null
      img: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["sHOPIFY_PRODUCTS"]>
    composites: {}
  }

  type SHOPIFY_PRODUCTSGetPayload<S extends boolean | null | undefined | SHOPIFY_PRODUCTSDefaultArgs> = $Result.GetResult<Prisma.$SHOPIFY_PRODUCTSPayload, S>

  type SHOPIFY_PRODUCTSCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SHOPIFY_PRODUCTSFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SHOPIFY_PRODUCTSCountAggregateInputType | true
    }

  export interface SHOPIFY_PRODUCTSDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SHOPIFY_PRODUCTS'], meta: { name: 'SHOPIFY_PRODUCTS' } }
    /**
     * Find zero or one SHOPIFY_PRODUCTS that matches the filter.
     * @param {SHOPIFY_PRODUCTSFindUniqueArgs} args - Arguments to find a SHOPIFY_PRODUCTS
     * @example
     * // Get one SHOPIFY_PRODUCTS
     * const sHOPIFY_PRODUCTS = await prisma.sHOPIFY_PRODUCTS.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SHOPIFY_PRODUCTSFindUniqueArgs>(args: SelectSubset<T, SHOPIFY_PRODUCTSFindUniqueArgs<ExtArgs>>): Prisma__SHOPIFY_PRODUCTSClient<$Result.GetResult<Prisma.$SHOPIFY_PRODUCTSPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one SHOPIFY_PRODUCTS that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SHOPIFY_PRODUCTSFindUniqueOrThrowArgs} args - Arguments to find a SHOPIFY_PRODUCTS
     * @example
     * // Get one SHOPIFY_PRODUCTS
     * const sHOPIFY_PRODUCTS = await prisma.sHOPIFY_PRODUCTS.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SHOPIFY_PRODUCTSFindUniqueOrThrowArgs>(args: SelectSubset<T, SHOPIFY_PRODUCTSFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SHOPIFY_PRODUCTSClient<$Result.GetResult<Prisma.$SHOPIFY_PRODUCTSPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first SHOPIFY_PRODUCTS that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SHOPIFY_PRODUCTSFindFirstArgs} args - Arguments to find a SHOPIFY_PRODUCTS
     * @example
     * // Get one SHOPIFY_PRODUCTS
     * const sHOPIFY_PRODUCTS = await prisma.sHOPIFY_PRODUCTS.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SHOPIFY_PRODUCTSFindFirstArgs>(args?: SelectSubset<T, SHOPIFY_PRODUCTSFindFirstArgs<ExtArgs>>): Prisma__SHOPIFY_PRODUCTSClient<$Result.GetResult<Prisma.$SHOPIFY_PRODUCTSPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first SHOPIFY_PRODUCTS that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SHOPIFY_PRODUCTSFindFirstOrThrowArgs} args - Arguments to find a SHOPIFY_PRODUCTS
     * @example
     * // Get one SHOPIFY_PRODUCTS
     * const sHOPIFY_PRODUCTS = await prisma.sHOPIFY_PRODUCTS.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SHOPIFY_PRODUCTSFindFirstOrThrowArgs>(args?: SelectSubset<T, SHOPIFY_PRODUCTSFindFirstOrThrowArgs<ExtArgs>>): Prisma__SHOPIFY_PRODUCTSClient<$Result.GetResult<Prisma.$SHOPIFY_PRODUCTSPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more SHOPIFY_PRODUCTS that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SHOPIFY_PRODUCTSFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SHOPIFY_PRODUCTS
     * const sHOPIFY_PRODUCTS = await prisma.sHOPIFY_PRODUCTS.findMany()
     * 
     * // Get first 10 SHOPIFY_PRODUCTS
     * const sHOPIFY_PRODUCTS = await prisma.sHOPIFY_PRODUCTS.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sHOPIFY_PRODUCTSWithIdOnly = await prisma.sHOPIFY_PRODUCTS.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SHOPIFY_PRODUCTSFindManyArgs>(args?: SelectSubset<T, SHOPIFY_PRODUCTSFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SHOPIFY_PRODUCTSPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a SHOPIFY_PRODUCTS.
     * @param {SHOPIFY_PRODUCTSCreateArgs} args - Arguments to create a SHOPIFY_PRODUCTS.
     * @example
     * // Create one SHOPIFY_PRODUCTS
     * const SHOPIFY_PRODUCTS = await prisma.sHOPIFY_PRODUCTS.create({
     *   data: {
     *     // ... data to create a SHOPIFY_PRODUCTS
     *   }
     * })
     * 
     */
    create<T extends SHOPIFY_PRODUCTSCreateArgs>(args: SelectSubset<T, SHOPIFY_PRODUCTSCreateArgs<ExtArgs>>): Prisma__SHOPIFY_PRODUCTSClient<$Result.GetResult<Prisma.$SHOPIFY_PRODUCTSPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many SHOPIFY_PRODUCTS.
     * @param {SHOPIFY_PRODUCTSCreateManyArgs} args - Arguments to create many SHOPIFY_PRODUCTS.
     * @example
     * // Create many SHOPIFY_PRODUCTS
     * const sHOPIFY_PRODUCTS = await prisma.sHOPIFY_PRODUCTS.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SHOPIFY_PRODUCTSCreateManyArgs>(args?: SelectSubset<T, SHOPIFY_PRODUCTSCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a SHOPIFY_PRODUCTS.
     * @param {SHOPIFY_PRODUCTSDeleteArgs} args - Arguments to delete one SHOPIFY_PRODUCTS.
     * @example
     * // Delete one SHOPIFY_PRODUCTS
     * const SHOPIFY_PRODUCTS = await prisma.sHOPIFY_PRODUCTS.delete({
     *   where: {
     *     // ... filter to delete one SHOPIFY_PRODUCTS
     *   }
     * })
     * 
     */
    delete<T extends SHOPIFY_PRODUCTSDeleteArgs>(args: SelectSubset<T, SHOPIFY_PRODUCTSDeleteArgs<ExtArgs>>): Prisma__SHOPIFY_PRODUCTSClient<$Result.GetResult<Prisma.$SHOPIFY_PRODUCTSPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one SHOPIFY_PRODUCTS.
     * @param {SHOPIFY_PRODUCTSUpdateArgs} args - Arguments to update one SHOPIFY_PRODUCTS.
     * @example
     * // Update one SHOPIFY_PRODUCTS
     * const sHOPIFY_PRODUCTS = await prisma.sHOPIFY_PRODUCTS.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SHOPIFY_PRODUCTSUpdateArgs>(args: SelectSubset<T, SHOPIFY_PRODUCTSUpdateArgs<ExtArgs>>): Prisma__SHOPIFY_PRODUCTSClient<$Result.GetResult<Prisma.$SHOPIFY_PRODUCTSPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more SHOPIFY_PRODUCTS.
     * @param {SHOPIFY_PRODUCTSDeleteManyArgs} args - Arguments to filter SHOPIFY_PRODUCTS to delete.
     * @example
     * // Delete a few SHOPIFY_PRODUCTS
     * const { count } = await prisma.sHOPIFY_PRODUCTS.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SHOPIFY_PRODUCTSDeleteManyArgs>(args?: SelectSubset<T, SHOPIFY_PRODUCTSDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SHOPIFY_PRODUCTS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SHOPIFY_PRODUCTSUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SHOPIFY_PRODUCTS
     * const sHOPIFY_PRODUCTS = await prisma.sHOPIFY_PRODUCTS.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SHOPIFY_PRODUCTSUpdateManyArgs>(args: SelectSubset<T, SHOPIFY_PRODUCTSUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SHOPIFY_PRODUCTS.
     * @param {SHOPIFY_PRODUCTSUpsertArgs} args - Arguments to update or create a SHOPIFY_PRODUCTS.
     * @example
     * // Update or create a SHOPIFY_PRODUCTS
     * const sHOPIFY_PRODUCTS = await prisma.sHOPIFY_PRODUCTS.upsert({
     *   create: {
     *     // ... data to create a SHOPIFY_PRODUCTS
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SHOPIFY_PRODUCTS we want to update
     *   }
     * })
     */
    upsert<T extends SHOPIFY_PRODUCTSUpsertArgs>(args: SelectSubset<T, SHOPIFY_PRODUCTSUpsertArgs<ExtArgs>>): Prisma__SHOPIFY_PRODUCTSClient<$Result.GetResult<Prisma.$SHOPIFY_PRODUCTSPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of SHOPIFY_PRODUCTS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SHOPIFY_PRODUCTSCountArgs} args - Arguments to filter SHOPIFY_PRODUCTS to count.
     * @example
     * // Count the number of SHOPIFY_PRODUCTS
     * const count = await prisma.sHOPIFY_PRODUCTS.count({
     *   where: {
     *     // ... the filter for the SHOPIFY_PRODUCTS we want to count
     *   }
     * })
    **/
    count<T extends SHOPIFY_PRODUCTSCountArgs>(
      args?: Subset<T, SHOPIFY_PRODUCTSCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SHOPIFY_PRODUCTSCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SHOPIFY_PRODUCTS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SHOPIFY_PRODUCTSAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SHOPIFY_PRODUCTSAggregateArgs>(args: Subset<T, SHOPIFY_PRODUCTSAggregateArgs>): Prisma.PrismaPromise<GetSHOPIFY_PRODUCTSAggregateType<T>>

    /**
     * Group by SHOPIFY_PRODUCTS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SHOPIFY_PRODUCTSGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SHOPIFY_PRODUCTSGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SHOPIFY_PRODUCTSGroupByArgs['orderBy'] }
        : { orderBy?: SHOPIFY_PRODUCTSGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SHOPIFY_PRODUCTSGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSHOPIFY_PRODUCTSGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SHOPIFY_PRODUCTS model
   */
  readonly fields: SHOPIFY_PRODUCTSFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SHOPIFY_PRODUCTS.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SHOPIFY_PRODUCTSClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    category<T extends CATEGORIESDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CATEGORIESDefaultArgs<ExtArgs>>): Prisma__CATEGORIESClient<$Result.GetResult<Prisma.$CATEGORIESPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    ShopifyVariants<T extends SHOPIFY_PRODUCTS$ShopifyVariantsArgs<ExtArgs> = {}>(args?: Subset<T, SHOPIFY_PRODUCTS$ShopifyVariantsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SHOPIFY_VARIANTSPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    WIPProducts<T extends SHOPIFY_PRODUCTS$WIPProductsArgs<ExtArgs> = {}>(args?: Subset<T, SHOPIFY_PRODUCTS$WIPProductsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WIP_PRODUCTSPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SHOPIFY_PRODUCTS model
   */ 
  interface SHOPIFY_PRODUCTSFieldRefs {
    readonly id: FieldRef<"SHOPIFY_PRODUCTS", 'BigInt'>
    readonly name: FieldRef<"SHOPIFY_PRODUCTS", 'String'>
    readonly categoryId: FieldRef<"SHOPIFY_PRODUCTS", 'Int'>
    readonly price: FieldRef<"SHOPIFY_PRODUCTS", 'Decimal'>
    readonly status: FieldRef<"SHOPIFY_PRODUCTS", 'String'>
    readonly img: FieldRef<"SHOPIFY_PRODUCTS", 'String'>
    readonly createdAt: FieldRef<"SHOPIFY_PRODUCTS", 'DateTime'>
    readonly updatedAt: FieldRef<"SHOPIFY_PRODUCTS", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SHOPIFY_PRODUCTS findUnique
   */
  export type SHOPIFY_PRODUCTSFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SHOPIFY_PRODUCTS
     */
    select?: SHOPIFY_PRODUCTSSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SHOPIFY_PRODUCTS
     */
    omit?: SHOPIFY_PRODUCTSOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SHOPIFY_PRODUCTSInclude<ExtArgs> | null
    /**
     * Filter, which SHOPIFY_PRODUCTS to fetch.
     */
    where: SHOPIFY_PRODUCTSWhereUniqueInput
  }

  /**
   * SHOPIFY_PRODUCTS findUniqueOrThrow
   */
  export type SHOPIFY_PRODUCTSFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SHOPIFY_PRODUCTS
     */
    select?: SHOPIFY_PRODUCTSSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SHOPIFY_PRODUCTS
     */
    omit?: SHOPIFY_PRODUCTSOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SHOPIFY_PRODUCTSInclude<ExtArgs> | null
    /**
     * Filter, which SHOPIFY_PRODUCTS to fetch.
     */
    where: SHOPIFY_PRODUCTSWhereUniqueInput
  }

  /**
   * SHOPIFY_PRODUCTS findFirst
   */
  export type SHOPIFY_PRODUCTSFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SHOPIFY_PRODUCTS
     */
    select?: SHOPIFY_PRODUCTSSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SHOPIFY_PRODUCTS
     */
    omit?: SHOPIFY_PRODUCTSOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SHOPIFY_PRODUCTSInclude<ExtArgs> | null
    /**
     * Filter, which SHOPIFY_PRODUCTS to fetch.
     */
    where?: SHOPIFY_PRODUCTSWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SHOPIFY_PRODUCTS to fetch.
     */
    orderBy?: SHOPIFY_PRODUCTSOrderByWithRelationInput | SHOPIFY_PRODUCTSOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SHOPIFY_PRODUCTS.
     */
    cursor?: SHOPIFY_PRODUCTSWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SHOPIFY_PRODUCTS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SHOPIFY_PRODUCTS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SHOPIFY_PRODUCTS.
     */
    distinct?: SHOPIFY_PRODUCTSScalarFieldEnum | SHOPIFY_PRODUCTSScalarFieldEnum[]
  }

  /**
   * SHOPIFY_PRODUCTS findFirstOrThrow
   */
  export type SHOPIFY_PRODUCTSFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SHOPIFY_PRODUCTS
     */
    select?: SHOPIFY_PRODUCTSSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SHOPIFY_PRODUCTS
     */
    omit?: SHOPIFY_PRODUCTSOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SHOPIFY_PRODUCTSInclude<ExtArgs> | null
    /**
     * Filter, which SHOPIFY_PRODUCTS to fetch.
     */
    where?: SHOPIFY_PRODUCTSWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SHOPIFY_PRODUCTS to fetch.
     */
    orderBy?: SHOPIFY_PRODUCTSOrderByWithRelationInput | SHOPIFY_PRODUCTSOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SHOPIFY_PRODUCTS.
     */
    cursor?: SHOPIFY_PRODUCTSWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SHOPIFY_PRODUCTS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SHOPIFY_PRODUCTS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SHOPIFY_PRODUCTS.
     */
    distinct?: SHOPIFY_PRODUCTSScalarFieldEnum | SHOPIFY_PRODUCTSScalarFieldEnum[]
  }

  /**
   * SHOPIFY_PRODUCTS findMany
   */
  export type SHOPIFY_PRODUCTSFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SHOPIFY_PRODUCTS
     */
    select?: SHOPIFY_PRODUCTSSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SHOPIFY_PRODUCTS
     */
    omit?: SHOPIFY_PRODUCTSOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SHOPIFY_PRODUCTSInclude<ExtArgs> | null
    /**
     * Filter, which SHOPIFY_PRODUCTS to fetch.
     */
    where?: SHOPIFY_PRODUCTSWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SHOPIFY_PRODUCTS to fetch.
     */
    orderBy?: SHOPIFY_PRODUCTSOrderByWithRelationInput | SHOPIFY_PRODUCTSOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SHOPIFY_PRODUCTS.
     */
    cursor?: SHOPIFY_PRODUCTSWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SHOPIFY_PRODUCTS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SHOPIFY_PRODUCTS.
     */
    skip?: number
    distinct?: SHOPIFY_PRODUCTSScalarFieldEnum | SHOPIFY_PRODUCTSScalarFieldEnum[]
  }

  /**
   * SHOPIFY_PRODUCTS create
   */
  export type SHOPIFY_PRODUCTSCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SHOPIFY_PRODUCTS
     */
    select?: SHOPIFY_PRODUCTSSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SHOPIFY_PRODUCTS
     */
    omit?: SHOPIFY_PRODUCTSOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SHOPIFY_PRODUCTSInclude<ExtArgs> | null
    /**
     * The data needed to create a SHOPIFY_PRODUCTS.
     */
    data: XOR<SHOPIFY_PRODUCTSCreateInput, SHOPIFY_PRODUCTSUncheckedCreateInput>
  }

  /**
   * SHOPIFY_PRODUCTS createMany
   */
  export type SHOPIFY_PRODUCTSCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SHOPIFY_PRODUCTS.
     */
    data: SHOPIFY_PRODUCTSCreateManyInput | SHOPIFY_PRODUCTSCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SHOPIFY_PRODUCTS update
   */
  export type SHOPIFY_PRODUCTSUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SHOPIFY_PRODUCTS
     */
    select?: SHOPIFY_PRODUCTSSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SHOPIFY_PRODUCTS
     */
    omit?: SHOPIFY_PRODUCTSOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SHOPIFY_PRODUCTSInclude<ExtArgs> | null
    /**
     * The data needed to update a SHOPIFY_PRODUCTS.
     */
    data: XOR<SHOPIFY_PRODUCTSUpdateInput, SHOPIFY_PRODUCTSUncheckedUpdateInput>
    /**
     * Choose, which SHOPIFY_PRODUCTS to update.
     */
    where: SHOPIFY_PRODUCTSWhereUniqueInput
  }

  /**
   * SHOPIFY_PRODUCTS updateMany
   */
  export type SHOPIFY_PRODUCTSUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SHOPIFY_PRODUCTS.
     */
    data: XOR<SHOPIFY_PRODUCTSUpdateManyMutationInput, SHOPIFY_PRODUCTSUncheckedUpdateManyInput>
    /**
     * Filter which SHOPIFY_PRODUCTS to update
     */
    where?: SHOPIFY_PRODUCTSWhereInput
  }

  /**
   * SHOPIFY_PRODUCTS upsert
   */
  export type SHOPIFY_PRODUCTSUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SHOPIFY_PRODUCTS
     */
    select?: SHOPIFY_PRODUCTSSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SHOPIFY_PRODUCTS
     */
    omit?: SHOPIFY_PRODUCTSOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SHOPIFY_PRODUCTSInclude<ExtArgs> | null
    /**
     * The filter to search for the SHOPIFY_PRODUCTS to update in case it exists.
     */
    where: SHOPIFY_PRODUCTSWhereUniqueInput
    /**
     * In case the SHOPIFY_PRODUCTS found by the `where` argument doesn't exist, create a new SHOPIFY_PRODUCTS with this data.
     */
    create: XOR<SHOPIFY_PRODUCTSCreateInput, SHOPIFY_PRODUCTSUncheckedCreateInput>
    /**
     * In case the SHOPIFY_PRODUCTS was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SHOPIFY_PRODUCTSUpdateInput, SHOPIFY_PRODUCTSUncheckedUpdateInput>
  }

  /**
   * SHOPIFY_PRODUCTS delete
   */
  export type SHOPIFY_PRODUCTSDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SHOPIFY_PRODUCTS
     */
    select?: SHOPIFY_PRODUCTSSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SHOPIFY_PRODUCTS
     */
    omit?: SHOPIFY_PRODUCTSOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SHOPIFY_PRODUCTSInclude<ExtArgs> | null
    /**
     * Filter which SHOPIFY_PRODUCTS to delete.
     */
    where: SHOPIFY_PRODUCTSWhereUniqueInput
  }

  /**
   * SHOPIFY_PRODUCTS deleteMany
   */
  export type SHOPIFY_PRODUCTSDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SHOPIFY_PRODUCTS to delete
     */
    where?: SHOPIFY_PRODUCTSWhereInput
  }

  /**
   * SHOPIFY_PRODUCTS.ShopifyVariants
   */
  export type SHOPIFY_PRODUCTS$ShopifyVariantsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SHOPIFY_VARIANTS
     */
    select?: SHOPIFY_VARIANTSSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SHOPIFY_VARIANTS
     */
    omit?: SHOPIFY_VARIANTSOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SHOPIFY_VARIANTSInclude<ExtArgs> | null
    where?: SHOPIFY_VARIANTSWhereInput
    orderBy?: SHOPIFY_VARIANTSOrderByWithRelationInput | SHOPIFY_VARIANTSOrderByWithRelationInput[]
    cursor?: SHOPIFY_VARIANTSWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SHOPIFY_VARIANTSScalarFieldEnum | SHOPIFY_VARIANTSScalarFieldEnum[]
  }

  /**
   * SHOPIFY_PRODUCTS.WIPProducts
   */
  export type SHOPIFY_PRODUCTS$WIPProductsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WIP_PRODUCTS
     */
    select?: WIP_PRODUCTSSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WIP_PRODUCTS
     */
    omit?: WIP_PRODUCTSOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WIP_PRODUCTSInclude<ExtArgs> | null
    where?: WIP_PRODUCTSWhereInput
    orderBy?: WIP_PRODUCTSOrderByWithRelationInput | WIP_PRODUCTSOrderByWithRelationInput[]
    cursor?: WIP_PRODUCTSWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WIP_PRODUCTSScalarFieldEnum | WIP_PRODUCTSScalarFieldEnum[]
  }

  /**
   * SHOPIFY_PRODUCTS without action
   */
  export type SHOPIFY_PRODUCTSDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SHOPIFY_PRODUCTS
     */
    select?: SHOPIFY_PRODUCTSSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SHOPIFY_PRODUCTS
     */
    omit?: SHOPIFY_PRODUCTSOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SHOPIFY_PRODUCTSInclude<ExtArgs> | null
  }


  /**
   * Model RM_TRANSACTIONS
   */

  export type AggregateRM_TRANSACTIONS = {
    _count: RM_TRANSACTIONSCountAggregateOutputType | null
    _avg: RM_TRANSACTIONSAvgAggregateOutputType | null
    _sum: RM_TRANSACTIONSSumAggregateOutputType | null
    _min: RM_TRANSACTIONSMinAggregateOutputType | null
    _max: RM_TRANSACTIONSMaxAggregateOutputType | null
  }

  export type RM_TRANSACTIONSAvgAggregateOutputType = {
    id: number | null
    rawMaterialId: number | null
    quantity: number | null
    initiatedById: number | null
  }

  export type RM_TRANSACTIONSSumAggregateOutputType = {
    id: number | null
    rawMaterialId: bigint | null
    quantity: number | null
    initiatedById: number | null
  }

  export type RM_TRANSACTIONSMinAggregateOutputType = {
    id: number | null
    rawMaterialId: bigint | null
    quantity: number | null
    transactionType: $Enums.TransactionType | null
    reason: string | null
    status: string | null
    initiatedById: number | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type RM_TRANSACTIONSMaxAggregateOutputType = {
    id: number | null
    rawMaterialId: bigint | null
    quantity: number | null
    transactionType: $Enums.TransactionType | null
    reason: string | null
    status: string | null
    initiatedById: number | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type RM_TRANSACTIONSCountAggregateOutputType = {
    id: number
    rawMaterialId: number
    quantity: number
    transactionType: number
    reason: number
    status: number
    initiatedById: number
    createdAt: number
    updatedAt: number
    deletedAt: number
    _all: number
  }


  export type RM_TRANSACTIONSAvgAggregateInputType = {
    id?: true
    rawMaterialId?: true
    quantity?: true
    initiatedById?: true
  }

  export type RM_TRANSACTIONSSumAggregateInputType = {
    id?: true
    rawMaterialId?: true
    quantity?: true
    initiatedById?: true
  }

  export type RM_TRANSACTIONSMinAggregateInputType = {
    id?: true
    rawMaterialId?: true
    quantity?: true
    transactionType?: true
    reason?: true
    status?: true
    initiatedById?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type RM_TRANSACTIONSMaxAggregateInputType = {
    id?: true
    rawMaterialId?: true
    quantity?: true
    transactionType?: true
    reason?: true
    status?: true
    initiatedById?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type RM_TRANSACTIONSCountAggregateInputType = {
    id?: true
    rawMaterialId?: true
    quantity?: true
    transactionType?: true
    reason?: true
    status?: true
    initiatedById?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
    _all?: true
  }

  export type RM_TRANSACTIONSAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RM_TRANSACTIONS to aggregate.
     */
    where?: RM_TRANSACTIONSWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RM_TRANSACTIONS to fetch.
     */
    orderBy?: RM_TRANSACTIONSOrderByWithRelationInput | RM_TRANSACTIONSOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RM_TRANSACTIONSWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RM_TRANSACTIONS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RM_TRANSACTIONS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RM_TRANSACTIONS
    **/
    _count?: true | RM_TRANSACTIONSCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RM_TRANSACTIONSAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RM_TRANSACTIONSSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RM_TRANSACTIONSMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RM_TRANSACTIONSMaxAggregateInputType
  }

  export type GetRM_TRANSACTIONSAggregateType<T extends RM_TRANSACTIONSAggregateArgs> = {
        [P in keyof T & keyof AggregateRM_TRANSACTIONS]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRM_TRANSACTIONS[P]>
      : GetScalarType<T[P], AggregateRM_TRANSACTIONS[P]>
  }




  export type RM_TRANSACTIONSGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RM_TRANSACTIONSWhereInput
    orderBy?: RM_TRANSACTIONSOrderByWithAggregationInput | RM_TRANSACTIONSOrderByWithAggregationInput[]
    by: RM_TRANSACTIONSScalarFieldEnum[] | RM_TRANSACTIONSScalarFieldEnum
    having?: RM_TRANSACTIONSScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RM_TRANSACTIONSCountAggregateInputType | true
    _avg?: RM_TRANSACTIONSAvgAggregateInputType
    _sum?: RM_TRANSACTIONSSumAggregateInputType
    _min?: RM_TRANSACTIONSMinAggregateInputType
    _max?: RM_TRANSACTIONSMaxAggregateInputType
  }

  export type RM_TRANSACTIONSGroupByOutputType = {
    id: number
    rawMaterialId: bigint
    quantity: number
    transactionType: $Enums.TransactionType
    reason: string
    status: string
    initiatedById: number
    createdAt: Date
    updatedAt: Date
    deletedAt: Date | null
    _count: RM_TRANSACTIONSCountAggregateOutputType | null
    _avg: RM_TRANSACTIONSAvgAggregateOutputType | null
    _sum: RM_TRANSACTIONSSumAggregateOutputType | null
    _min: RM_TRANSACTIONSMinAggregateOutputType | null
    _max: RM_TRANSACTIONSMaxAggregateOutputType | null
  }

  type GetRM_TRANSACTIONSGroupByPayload<T extends RM_TRANSACTIONSGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RM_TRANSACTIONSGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RM_TRANSACTIONSGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RM_TRANSACTIONSGroupByOutputType[P]>
            : GetScalarType<T[P], RM_TRANSACTIONSGroupByOutputType[P]>
        }
      >
    >


  export type RM_TRANSACTIONSSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    rawMaterialId?: boolean
    quantity?: boolean
    transactionType?: boolean
    reason?: boolean
    status?: boolean
    initiatedById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    rawMaterial?: boolean | RAW_MATERIALSDefaultArgs<ExtArgs>
    initiatedBy?: boolean | EmployeeDefaultArgs<ExtArgs>
    RMQualityChecks?: boolean | RM_TRANSACTIONS$RMQualityChecksArgs<ExtArgs>
    RMWastageLogs?: boolean | RM_TRANSACTIONS$RMWastageLogsArgs<ExtArgs>
    _count?: boolean | RM_TRANSACTIONSCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["rM_TRANSACTIONS"]>



  export type RM_TRANSACTIONSSelectScalar = {
    id?: boolean
    rawMaterialId?: boolean
    quantity?: boolean
    transactionType?: boolean
    reason?: boolean
    status?: boolean
    initiatedById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
  }

  export type RM_TRANSACTIONSOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "rawMaterialId" | "quantity" | "transactionType" | "reason" | "status" | "initiatedById" | "createdAt" | "updatedAt" | "deletedAt", ExtArgs["result"]["rM_TRANSACTIONS"]>
  export type RM_TRANSACTIONSInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    rawMaterial?: boolean | RAW_MATERIALSDefaultArgs<ExtArgs>
    initiatedBy?: boolean | EmployeeDefaultArgs<ExtArgs>
    RMQualityChecks?: boolean | RM_TRANSACTIONS$RMQualityChecksArgs<ExtArgs>
    RMWastageLogs?: boolean | RM_TRANSACTIONS$RMWastageLogsArgs<ExtArgs>
    _count?: boolean | RM_TRANSACTIONSCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $RM_TRANSACTIONSPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RM_TRANSACTIONS"
    objects: {
      rawMaterial: Prisma.$RAW_MATERIALSPayload<ExtArgs>
      initiatedBy: Prisma.$EmployeePayload<ExtArgs>
      RMQualityChecks: Prisma.$RM_QCPayload<ExtArgs>[]
      RMWastageLogs: Prisma.$RM_WASTAGE_LOGSPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      rawMaterialId: bigint
      quantity: number
      transactionType: $Enums.TransactionType
      reason: string
      status: string
      initiatedById: number
      createdAt: Date
      updatedAt: Date
      deletedAt: Date | null
    }, ExtArgs["result"]["rM_TRANSACTIONS"]>
    composites: {}
  }

  type RM_TRANSACTIONSGetPayload<S extends boolean | null | undefined | RM_TRANSACTIONSDefaultArgs> = $Result.GetResult<Prisma.$RM_TRANSACTIONSPayload, S>

  type RM_TRANSACTIONSCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RM_TRANSACTIONSFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RM_TRANSACTIONSCountAggregateInputType | true
    }

  export interface RM_TRANSACTIONSDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RM_TRANSACTIONS'], meta: { name: 'RM_TRANSACTIONS' } }
    /**
     * Find zero or one RM_TRANSACTIONS that matches the filter.
     * @param {RM_TRANSACTIONSFindUniqueArgs} args - Arguments to find a RM_TRANSACTIONS
     * @example
     * // Get one RM_TRANSACTIONS
     * const rM_TRANSACTIONS = await prisma.rM_TRANSACTIONS.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RM_TRANSACTIONSFindUniqueArgs>(args: SelectSubset<T, RM_TRANSACTIONSFindUniqueArgs<ExtArgs>>): Prisma__RM_TRANSACTIONSClient<$Result.GetResult<Prisma.$RM_TRANSACTIONSPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one RM_TRANSACTIONS that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RM_TRANSACTIONSFindUniqueOrThrowArgs} args - Arguments to find a RM_TRANSACTIONS
     * @example
     * // Get one RM_TRANSACTIONS
     * const rM_TRANSACTIONS = await prisma.rM_TRANSACTIONS.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RM_TRANSACTIONSFindUniqueOrThrowArgs>(args: SelectSubset<T, RM_TRANSACTIONSFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RM_TRANSACTIONSClient<$Result.GetResult<Prisma.$RM_TRANSACTIONSPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first RM_TRANSACTIONS that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RM_TRANSACTIONSFindFirstArgs} args - Arguments to find a RM_TRANSACTIONS
     * @example
     * // Get one RM_TRANSACTIONS
     * const rM_TRANSACTIONS = await prisma.rM_TRANSACTIONS.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RM_TRANSACTIONSFindFirstArgs>(args?: SelectSubset<T, RM_TRANSACTIONSFindFirstArgs<ExtArgs>>): Prisma__RM_TRANSACTIONSClient<$Result.GetResult<Prisma.$RM_TRANSACTIONSPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first RM_TRANSACTIONS that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RM_TRANSACTIONSFindFirstOrThrowArgs} args - Arguments to find a RM_TRANSACTIONS
     * @example
     * // Get one RM_TRANSACTIONS
     * const rM_TRANSACTIONS = await prisma.rM_TRANSACTIONS.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RM_TRANSACTIONSFindFirstOrThrowArgs>(args?: SelectSubset<T, RM_TRANSACTIONSFindFirstOrThrowArgs<ExtArgs>>): Prisma__RM_TRANSACTIONSClient<$Result.GetResult<Prisma.$RM_TRANSACTIONSPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more RM_TRANSACTIONS that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RM_TRANSACTIONSFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RM_TRANSACTIONS
     * const rM_TRANSACTIONS = await prisma.rM_TRANSACTIONS.findMany()
     * 
     * // Get first 10 RM_TRANSACTIONS
     * const rM_TRANSACTIONS = await prisma.rM_TRANSACTIONS.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const rM_TRANSACTIONSWithIdOnly = await prisma.rM_TRANSACTIONS.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RM_TRANSACTIONSFindManyArgs>(args?: SelectSubset<T, RM_TRANSACTIONSFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RM_TRANSACTIONSPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a RM_TRANSACTIONS.
     * @param {RM_TRANSACTIONSCreateArgs} args - Arguments to create a RM_TRANSACTIONS.
     * @example
     * // Create one RM_TRANSACTIONS
     * const RM_TRANSACTIONS = await prisma.rM_TRANSACTIONS.create({
     *   data: {
     *     // ... data to create a RM_TRANSACTIONS
     *   }
     * })
     * 
     */
    create<T extends RM_TRANSACTIONSCreateArgs>(args: SelectSubset<T, RM_TRANSACTIONSCreateArgs<ExtArgs>>): Prisma__RM_TRANSACTIONSClient<$Result.GetResult<Prisma.$RM_TRANSACTIONSPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many RM_TRANSACTIONS.
     * @param {RM_TRANSACTIONSCreateManyArgs} args - Arguments to create many RM_TRANSACTIONS.
     * @example
     * // Create many RM_TRANSACTIONS
     * const rM_TRANSACTIONS = await prisma.rM_TRANSACTIONS.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RM_TRANSACTIONSCreateManyArgs>(args?: SelectSubset<T, RM_TRANSACTIONSCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a RM_TRANSACTIONS.
     * @param {RM_TRANSACTIONSDeleteArgs} args - Arguments to delete one RM_TRANSACTIONS.
     * @example
     * // Delete one RM_TRANSACTIONS
     * const RM_TRANSACTIONS = await prisma.rM_TRANSACTIONS.delete({
     *   where: {
     *     // ... filter to delete one RM_TRANSACTIONS
     *   }
     * })
     * 
     */
    delete<T extends RM_TRANSACTIONSDeleteArgs>(args: SelectSubset<T, RM_TRANSACTIONSDeleteArgs<ExtArgs>>): Prisma__RM_TRANSACTIONSClient<$Result.GetResult<Prisma.$RM_TRANSACTIONSPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one RM_TRANSACTIONS.
     * @param {RM_TRANSACTIONSUpdateArgs} args - Arguments to update one RM_TRANSACTIONS.
     * @example
     * // Update one RM_TRANSACTIONS
     * const rM_TRANSACTIONS = await prisma.rM_TRANSACTIONS.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RM_TRANSACTIONSUpdateArgs>(args: SelectSubset<T, RM_TRANSACTIONSUpdateArgs<ExtArgs>>): Prisma__RM_TRANSACTIONSClient<$Result.GetResult<Prisma.$RM_TRANSACTIONSPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more RM_TRANSACTIONS.
     * @param {RM_TRANSACTIONSDeleteManyArgs} args - Arguments to filter RM_TRANSACTIONS to delete.
     * @example
     * // Delete a few RM_TRANSACTIONS
     * const { count } = await prisma.rM_TRANSACTIONS.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RM_TRANSACTIONSDeleteManyArgs>(args?: SelectSubset<T, RM_TRANSACTIONSDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RM_TRANSACTIONS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RM_TRANSACTIONSUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RM_TRANSACTIONS
     * const rM_TRANSACTIONS = await prisma.rM_TRANSACTIONS.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RM_TRANSACTIONSUpdateManyArgs>(args: SelectSubset<T, RM_TRANSACTIONSUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one RM_TRANSACTIONS.
     * @param {RM_TRANSACTIONSUpsertArgs} args - Arguments to update or create a RM_TRANSACTIONS.
     * @example
     * // Update or create a RM_TRANSACTIONS
     * const rM_TRANSACTIONS = await prisma.rM_TRANSACTIONS.upsert({
     *   create: {
     *     // ... data to create a RM_TRANSACTIONS
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RM_TRANSACTIONS we want to update
     *   }
     * })
     */
    upsert<T extends RM_TRANSACTIONSUpsertArgs>(args: SelectSubset<T, RM_TRANSACTIONSUpsertArgs<ExtArgs>>): Prisma__RM_TRANSACTIONSClient<$Result.GetResult<Prisma.$RM_TRANSACTIONSPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of RM_TRANSACTIONS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RM_TRANSACTIONSCountArgs} args - Arguments to filter RM_TRANSACTIONS to count.
     * @example
     * // Count the number of RM_TRANSACTIONS
     * const count = await prisma.rM_TRANSACTIONS.count({
     *   where: {
     *     // ... the filter for the RM_TRANSACTIONS we want to count
     *   }
     * })
    **/
    count<T extends RM_TRANSACTIONSCountArgs>(
      args?: Subset<T, RM_TRANSACTIONSCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RM_TRANSACTIONSCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RM_TRANSACTIONS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RM_TRANSACTIONSAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RM_TRANSACTIONSAggregateArgs>(args: Subset<T, RM_TRANSACTIONSAggregateArgs>): Prisma.PrismaPromise<GetRM_TRANSACTIONSAggregateType<T>>

    /**
     * Group by RM_TRANSACTIONS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RM_TRANSACTIONSGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RM_TRANSACTIONSGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RM_TRANSACTIONSGroupByArgs['orderBy'] }
        : { orderBy?: RM_TRANSACTIONSGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RM_TRANSACTIONSGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRM_TRANSACTIONSGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RM_TRANSACTIONS model
   */
  readonly fields: RM_TRANSACTIONSFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RM_TRANSACTIONS.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RM_TRANSACTIONSClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    rawMaterial<T extends RAW_MATERIALSDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RAW_MATERIALSDefaultArgs<ExtArgs>>): Prisma__RAW_MATERIALSClient<$Result.GetResult<Prisma.$RAW_MATERIALSPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    initiatedBy<T extends EmployeeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EmployeeDefaultArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    RMQualityChecks<T extends RM_TRANSACTIONS$RMQualityChecksArgs<ExtArgs> = {}>(args?: Subset<T, RM_TRANSACTIONS$RMQualityChecksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RM_QCPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    RMWastageLogs<T extends RM_TRANSACTIONS$RMWastageLogsArgs<ExtArgs> = {}>(args?: Subset<T, RM_TRANSACTIONS$RMWastageLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RM_WASTAGE_LOGSPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RM_TRANSACTIONS model
   */ 
  interface RM_TRANSACTIONSFieldRefs {
    readonly id: FieldRef<"RM_TRANSACTIONS", 'Int'>
    readonly rawMaterialId: FieldRef<"RM_TRANSACTIONS", 'BigInt'>
    readonly quantity: FieldRef<"RM_TRANSACTIONS", 'Int'>
    readonly transactionType: FieldRef<"RM_TRANSACTIONS", 'TransactionType'>
    readonly reason: FieldRef<"RM_TRANSACTIONS", 'String'>
    readonly status: FieldRef<"RM_TRANSACTIONS", 'String'>
    readonly initiatedById: FieldRef<"RM_TRANSACTIONS", 'Int'>
    readonly createdAt: FieldRef<"RM_TRANSACTIONS", 'DateTime'>
    readonly updatedAt: FieldRef<"RM_TRANSACTIONS", 'DateTime'>
    readonly deletedAt: FieldRef<"RM_TRANSACTIONS", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * RM_TRANSACTIONS findUnique
   */
  export type RM_TRANSACTIONSFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RM_TRANSACTIONS
     */
    select?: RM_TRANSACTIONSSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RM_TRANSACTIONS
     */
    omit?: RM_TRANSACTIONSOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RM_TRANSACTIONSInclude<ExtArgs> | null
    /**
     * Filter, which RM_TRANSACTIONS to fetch.
     */
    where: RM_TRANSACTIONSWhereUniqueInput
  }

  /**
   * RM_TRANSACTIONS findUniqueOrThrow
   */
  export type RM_TRANSACTIONSFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RM_TRANSACTIONS
     */
    select?: RM_TRANSACTIONSSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RM_TRANSACTIONS
     */
    omit?: RM_TRANSACTIONSOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RM_TRANSACTIONSInclude<ExtArgs> | null
    /**
     * Filter, which RM_TRANSACTIONS to fetch.
     */
    where: RM_TRANSACTIONSWhereUniqueInput
  }

  /**
   * RM_TRANSACTIONS findFirst
   */
  export type RM_TRANSACTIONSFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RM_TRANSACTIONS
     */
    select?: RM_TRANSACTIONSSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RM_TRANSACTIONS
     */
    omit?: RM_TRANSACTIONSOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RM_TRANSACTIONSInclude<ExtArgs> | null
    /**
     * Filter, which RM_TRANSACTIONS to fetch.
     */
    where?: RM_TRANSACTIONSWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RM_TRANSACTIONS to fetch.
     */
    orderBy?: RM_TRANSACTIONSOrderByWithRelationInput | RM_TRANSACTIONSOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RM_TRANSACTIONS.
     */
    cursor?: RM_TRANSACTIONSWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RM_TRANSACTIONS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RM_TRANSACTIONS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RM_TRANSACTIONS.
     */
    distinct?: RM_TRANSACTIONSScalarFieldEnum | RM_TRANSACTIONSScalarFieldEnum[]
  }

  /**
   * RM_TRANSACTIONS findFirstOrThrow
   */
  export type RM_TRANSACTIONSFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RM_TRANSACTIONS
     */
    select?: RM_TRANSACTIONSSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RM_TRANSACTIONS
     */
    omit?: RM_TRANSACTIONSOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RM_TRANSACTIONSInclude<ExtArgs> | null
    /**
     * Filter, which RM_TRANSACTIONS to fetch.
     */
    where?: RM_TRANSACTIONSWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RM_TRANSACTIONS to fetch.
     */
    orderBy?: RM_TRANSACTIONSOrderByWithRelationInput | RM_TRANSACTIONSOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RM_TRANSACTIONS.
     */
    cursor?: RM_TRANSACTIONSWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RM_TRANSACTIONS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RM_TRANSACTIONS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RM_TRANSACTIONS.
     */
    distinct?: RM_TRANSACTIONSScalarFieldEnum | RM_TRANSACTIONSScalarFieldEnum[]
  }

  /**
   * RM_TRANSACTIONS findMany
   */
  export type RM_TRANSACTIONSFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RM_TRANSACTIONS
     */
    select?: RM_TRANSACTIONSSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RM_TRANSACTIONS
     */
    omit?: RM_TRANSACTIONSOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RM_TRANSACTIONSInclude<ExtArgs> | null
    /**
     * Filter, which RM_TRANSACTIONS to fetch.
     */
    where?: RM_TRANSACTIONSWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RM_TRANSACTIONS to fetch.
     */
    orderBy?: RM_TRANSACTIONSOrderByWithRelationInput | RM_TRANSACTIONSOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RM_TRANSACTIONS.
     */
    cursor?: RM_TRANSACTIONSWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RM_TRANSACTIONS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RM_TRANSACTIONS.
     */
    skip?: number
    distinct?: RM_TRANSACTIONSScalarFieldEnum | RM_TRANSACTIONSScalarFieldEnum[]
  }

  /**
   * RM_TRANSACTIONS create
   */
  export type RM_TRANSACTIONSCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RM_TRANSACTIONS
     */
    select?: RM_TRANSACTIONSSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RM_TRANSACTIONS
     */
    omit?: RM_TRANSACTIONSOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RM_TRANSACTIONSInclude<ExtArgs> | null
    /**
     * The data needed to create a RM_TRANSACTIONS.
     */
    data: XOR<RM_TRANSACTIONSCreateInput, RM_TRANSACTIONSUncheckedCreateInput>
  }

  /**
   * RM_TRANSACTIONS createMany
   */
  export type RM_TRANSACTIONSCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RM_TRANSACTIONS.
     */
    data: RM_TRANSACTIONSCreateManyInput | RM_TRANSACTIONSCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RM_TRANSACTIONS update
   */
  export type RM_TRANSACTIONSUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RM_TRANSACTIONS
     */
    select?: RM_TRANSACTIONSSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RM_TRANSACTIONS
     */
    omit?: RM_TRANSACTIONSOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RM_TRANSACTIONSInclude<ExtArgs> | null
    /**
     * The data needed to update a RM_TRANSACTIONS.
     */
    data: XOR<RM_TRANSACTIONSUpdateInput, RM_TRANSACTIONSUncheckedUpdateInput>
    /**
     * Choose, which RM_TRANSACTIONS to update.
     */
    where: RM_TRANSACTIONSWhereUniqueInput
  }

  /**
   * RM_TRANSACTIONS updateMany
   */
  export type RM_TRANSACTIONSUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RM_TRANSACTIONS.
     */
    data: XOR<RM_TRANSACTIONSUpdateManyMutationInput, RM_TRANSACTIONSUncheckedUpdateManyInput>
    /**
     * Filter which RM_TRANSACTIONS to update
     */
    where?: RM_TRANSACTIONSWhereInput
  }

  /**
   * RM_TRANSACTIONS upsert
   */
  export type RM_TRANSACTIONSUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RM_TRANSACTIONS
     */
    select?: RM_TRANSACTIONSSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RM_TRANSACTIONS
     */
    omit?: RM_TRANSACTIONSOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RM_TRANSACTIONSInclude<ExtArgs> | null
    /**
     * The filter to search for the RM_TRANSACTIONS to update in case it exists.
     */
    where: RM_TRANSACTIONSWhereUniqueInput
    /**
     * In case the RM_TRANSACTIONS found by the `where` argument doesn't exist, create a new RM_TRANSACTIONS with this data.
     */
    create: XOR<RM_TRANSACTIONSCreateInput, RM_TRANSACTIONSUncheckedCreateInput>
    /**
     * In case the RM_TRANSACTIONS was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RM_TRANSACTIONSUpdateInput, RM_TRANSACTIONSUncheckedUpdateInput>
  }

  /**
   * RM_TRANSACTIONS delete
   */
  export type RM_TRANSACTIONSDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RM_TRANSACTIONS
     */
    select?: RM_TRANSACTIONSSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RM_TRANSACTIONS
     */
    omit?: RM_TRANSACTIONSOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RM_TRANSACTIONSInclude<ExtArgs> | null
    /**
     * Filter which RM_TRANSACTIONS to delete.
     */
    where: RM_TRANSACTIONSWhereUniqueInput
  }

  /**
   * RM_TRANSACTIONS deleteMany
   */
  export type RM_TRANSACTIONSDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RM_TRANSACTIONS to delete
     */
    where?: RM_TRANSACTIONSWhereInput
  }

  /**
   * RM_TRANSACTIONS.RMQualityChecks
   */
  export type RM_TRANSACTIONS$RMQualityChecksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RM_QC
     */
    select?: RM_QCSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RM_QC
     */
    omit?: RM_QCOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RM_QCInclude<ExtArgs> | null
    where?: RM_QCWhereInput
    orderBy?: RM_QCOrderByWithRelationInput | RM_QCOrderByWithRelationInput[]
    cursor?: RM_QCWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RM_QCScalarFieldEnum | RM_QCScalarFieldEnum[]
  }

  /**
   * RM_TRANSACTIONS.RMWastageLogs
   */
  export type RM_TRANSACTIONS$RMWastageLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RM_WASTAGE_LOGS
     */
    select?: RM_WASTAGE_LOGSSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RM_WASTAGE_LOGS
     */
    omit?: RM_WASTAGE_LOGSOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RM_WASTAGE_LOGSInclude<ExtArgs> | null
    where?: RM_WASTAGE_LOGSWhereInput
    orderBy?: RM_WASTAGE_LOGSOrderByWithRelationInput | RM_WASTAGE_LOGSOrderByWithRelationInput[]
    cursor?: RM_WASTAGE_LOGSWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RM_WASTAGE_LOGSScalarFieldEnum | RM_WASTAGE_LOGSScalarFieldEnum[]
  }

  /**
   * RM_TRANSACTIONS without action
   */
  export type RM_TRANSACTIONSDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RM_TRANSACTIONS
     */
    select?: RM_TRANSACTIONSSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RM_TRANSACTIONS
     */
    omit?: RM_TRANSACTIONSOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RM_TRANSACTIONSInclude<ExtArgs> | null
  }


  /**
   * Model RM_QC
   */

  export type AggregateRM_QC = {
    _count: RM_QCCountAggregateOutputType | null
    _avg: RM_QCAvgAggregateOutputType | null
    _sum: RM_QCSumAggregateOutputType | null
    _min: RM_QCMinAggregateOutputType | null
    _max: RM_QCMaxAggregateOutputType | null
  }

  export type RM_QCAvgAggregateOutputType = {
    id: number | null
    transactionId: number | null
    rawMaterialId: number | null
    checkedById: number | null
    doneById: number | null
  }

  export type RM_QCSumAggregateOutputType = {
    id: number | null
    transactionId: number | null
    rawMaterialId: bigint | null
    checkedById: number | null
    doneById: number | null
  }

  export type RM_QCMinAggregateOutputType = {
    id: number | null
    transactionId: number | null
    rawMaterialId: bigint | null
    quality_status: $Enums.QualityStatus | null
    checkedById: number | null
    doneById: number | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type RM_QCMaxAggregateOutputType = {
    id: number | null
    transactionId: number | null
    rawMaterialId: bigint | null
    quality_status: $Enums.QualityStatus | null
    checkedById: number | null
    doneById: number | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type RM_QCCountAggregateOutputType = {
    id: number
    transactionId: number
    rawMaterialId: number
    quality_status: number
    checkedById: number
    doneById: number
    createdAt: number
    updatedAt: number
    deletedAt: number
    _all: number
  }


  export type RM_QCAvgAggregateInputType = {
    id?: true
    transactionId?: true
    rawMaterialId?: true
    checkedById?: true
    doneById?: true
  }

  export type RM_QCSumAggregateInputType = {
    id?: true
    transactionId?: true
    rawMaterialId?: true
    checkedById?: true
    doneById?: true
  }

  export type RM_QCMinAggregateInputType = {
    id?: true
    transactionId?: true
    rawMaterialId?: true
    quality_status?: true
    checkedById?: true
    doneById?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type RM_QCMaxAggregateInputType = {
    id?: true
    transactionId?: true
    rawMaterialId?: true
    quality_status?: true
    checkedById?: true
    doneById?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type RM_QCCountAggregateInputType = {
    id?: true
    transactionId?: true
    rawMaterialId?: true
    quality_status?: true
    checkedById?: true
    doneById?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
    _all?: true
  }

  export type RM_QCAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RM_QC to aggregate.
     */
    where?: RM_QCWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RM_QCS to fetch.
     */
    orderBy?: RM_QCOrderByWithRelationInput | RM_QCOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RM_QCWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RM_QCS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RM_QCS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RM_QCS
    **/
    _count?: true | RM_QCCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RM_QCAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RM_QCSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RM_QCMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RM_QCMaxAggregateInputType
  }

  export type GetRM_QCAggregateType<T extends RM_QCAggregateArgs> = {
        [P in keyof T & keyof AggregateRM_QC]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRM_QC[P]>
      : GetScalarType<T[P], AggregateRM_QC[P]>
  }




  export type RM_QCGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RM_QCWhereInput
    orderBy?: RM_QCOrderByWithAggregationInput | RM_QCOrderByWithAggregationInput[]
    by: RM_QCScalarFieldEnum[] | RM_QCScalarFieldEnum
    having?: RM_QCScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RM_QCCountAggregateInputType | true
    _avg?: RM_QCAvgAggregateInputType
    _sum?: RM_QCSumAggregateInputType
    _min?: RM_QCMinAggregateInputType
    _max?: RM_QCMaxAggregateInputType
  }

  export type RM_QCGroupByOutputType = {
    id: number
    transactionId: number
    rawMaterialId: bigint
    quality_status: $Enums.QualityStatus
    checkedById: number
    doneById: number
    createdAt: Date
    updatedAt: Date
    deletedAt: Date | null
    _count: RM_QCCountAggregateOutputType | null
    _avg: RM_QCAvgAggregateOutputType | null
    _sum: RM_QCSumAggregateOutputType | null
    _min: RM_QCMinAggregateOutputType | null
    _max: RM_QCMaxAggregateOutputType | null
  }

  type GetRM_QCGroupByPayload<T extends RM_QCGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RM_QCGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RM_QCGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RM_QCGroupByOutputType[P]>
            : GetScalarType<T[P], RM_QCGroupByOutputType[P]>
        }
      >
    >


  export type RM_QCSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    transactionId?: boolean
    rawMaterialId?: boolean
    quality_status?: boolean
    checkedById?: boolean
    doneById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    rawMaterial?: boolean | RAW_MATERIALSDefaultArgs<ExtArgs>
    transaction?: boolean | RM_TRANSACTIONSDefaultArgs<ExtArgs>
    checkedBy?: boolean | EmployeeDefaultArgs<ExtArgs>
    doneBy?: boolean | EmployeeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["rM_QC"]>



  export type RM_QCSelectScalar = {
    id?: boolean
    transactionId?: boolean
    rawMaterialId?: boolean
    quality_status?: boolean
    checkedById?: boolean
    doneById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
  }

  export type RM_QCOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "transactionId" | "rawMaterialId" | "quality_status" | "checkedById" | "doneById" | "createdAt" | "updatedAt" | "deletedAt", ExtArgs["result"]["rM_QC"]>
  export type RM_QCInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    rawMaterial?: boolean | RAW_MATERIALSDefaultArgs<ExtArgs>
    transaction?: boolean | RM_TRANSACTIONSDefaultArgs<ExtArgs>
    checkedBy?: boolean | EmployeeDefaultArgs<ExtArgs>
    doneBy?: boolean | EmployeeDefaultArgs<ExtArgs>
  }

  export type $RM_QCPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RM_QC"
    objects: {
      rawMaterial: Prisma.$RAW_MATERIALSPayload<ExtArgs>
      transaction: Prisma.$RM_TRANSACTIONSPayload<ExtArgs>
      checkedBy: Prisma.$EmployeePayload<ExtArgs>
      doneBy: Prisma.$EmployeePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      transactionId: number
      rawMaterialId: bigint
      quality_status: $Enums.QualityStatus
      checkedById: number
      doneById: number
      createdAt: Date
      updatedAt: Date
      deletedAt: Date | null
    }, ExtArgs["result"]["rM_QC"]>
    composites: {}
  }

  type RM_QCGetPayload<S extends boolean | null | undefined | RM_QCDefaultArgs> = $Result.GetResult<Prisma.$RM_QCPayload, S>

  type RM_QCCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RM_QCFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RM_QCCountAggregateInputType | true
    }

  export interface RM_QCDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RM_QC'], meta: { name: 'RM_QC' } }
    /**
     * Find zero or one RM_QC that matches the filter.
     * @param {RM_QCFindUniqueArgs} args - Arguments to find a RM_QC
     * @example
     * // Get one RM_QC
     * const rM_QC = await prisma.rM_QC.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RM_QCFindUniqueArgs>(args: SelectSubset<T, RM_QCFindUniqueArgs<ExtArgs>>): Prisma__RM_QCClient<$Result.GetResult<Prisma.$RM_QCPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one RM_QC that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RM_QCFindUniqueOrThrowArgs} args - Arguments to find a RM_QC
     * @example
     * // Get one RM_QC
     * const rM_QC = await prisma.rM_QC.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RM_QCFindUniqueOrThrowArgs>(args: SelectSubset<T, RM_QCFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RM_QCClient<$Result.GetResult<Prisma.$RM_QCPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first RM_QC that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RM_QCFindFirstArgs} args - Arguments to find a RM_QC
     * @example
     * // Get one RM_QC
     * const rM_QC = await prisma.rM_QC.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RM_QCFindFirstArgs>(args?: SelectSubset<T, RM_QCFindFirstArgs<ExtArgs>>): Prisma__RM_QCClient<$Result.GetResult<Prisma.$RM_QCPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first RM_QC that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RM_QCFindFirstOrThrowArgs} args - Arguments to find a RM_QC
     * @example
     * // Get one RM_QC
     * const rM_QC = await prisma.rM_QC.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RM_QCFindFirstOrThrowArgs>(args?: SelectSubset<T, RM_QCFindFirstOrThrowArgs<ExtArgs>>): Prisma__RM_QCClient<$Result.GetResult<Prisma.$RM_QCPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more RM_QCS that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RM_QCFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RM_QCS
     * const rM_QCS = await prisma.rM_QC.findMany()
     * 
     * // Get first 10 RM_QCS
     * const rM_QCS = await prisma.rM_QC.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const rM_QCWithIdOnly = await prisma.rM_QC.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RM_QCFindManyArgs>(args?: SelectSubset<T, RM_QCFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RM_QCPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a RM_QC.
     * @param {RM_QCCreateArgs} args - Arguments to create a RM_QC.
     * @example
     * // Create one RM_QC
     * const RM_QC = await prisma.rM_QC.create({
     *   data: {
     *     // ... data to create a RM_QC
     *   }
     * })
     * 
     */
    create<T extends RM_QCCreateArgs>(args: SelectSubset<T, RM_QCCreateArgs<ExtArgs>>): Prisma__RM_QCClient<$Result.GetResult<Prisma.$RM_QCPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many RM_QCS.
     * @param {RM_QCCreateManyArgs} args - Arguments to create many RM_QCS.
     * @example
     * // Create many RM_QCS
     * const rM_QC = await prisma.rM_QC.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RM_QCCreateManyArgs>(args?: SelectSubset<T, RM_QCCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a RM_QC.
     * @param {RM_QCDeleteArgs} args - Arguments to delete one RM_QC.
     * @example
     * // Delete one RM_QC
     * const RM_QC = await prisma.rM_QC.delete({
     *   where: {
     *     // ... filter to delete one RM_QC
     *   }
     * })
     * 
     */
    delete<T extends RM_QCDeleteArgs>(args: SelectSubset<T, RM_QCDeleteArgs<ExtArgs>>): Prisma__RM_QCClient<$Result.GetResult<Prisma.$RM_QCPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one RM_QC.
     * @param {RM_QCUpdateArgs} args - Arguments to update one RM_QC.
     * @example
     * // Update one RM_QC
     * const rM_QC = await prisma.rM_QC.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RM_QCUpdateArgs>(args: SelectSubset<T, RM_QCUpdateArgs<ExtArgs>>): Prisma__RM_QCClient<$Result.GetResult<Prisma.$RM_QCPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more RM_QCS.
     * @param {RM_QCDeleteManyArgs} args - Arguments to filter RM_QCS to delete.
     * @example
     * // Delete a few RM_QCS
     * const { count } = await prisma.rM_QC.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RM_QCDeleteManyArgs>(args?: SelectSubset<T, RM_QCDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RM_QCS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RM_QCUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RM_QCS
     * const rM_QC = await prisma.rM_QC.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RM_QCUpdateManyArgs>(args: SelectSubset<T, RM_QCUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one RM_QC.
     * @param {RM_QCUpsertArgs} args - Arguments to update or create a RM_QC.
     * @example
     * // Update or create a RM_QC
     * const rM_QC = await prisma.rM_QC.upsert({
     *   create: {
     *     // ... data to create a RM_QC
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RM_QC we want to update
     *   }
     * })
     */
    upsert<T extends RM_QCUpsertArgs>(args: SelectSubset<T, RM_QCUpsertArgs<ExtArgs>>): Prisma__RM_QCClient<$Result.GetResult<Prisma.$RM_QCPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of RM_QCS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RM_QCCountArgs} args - Arguments to filter RM_QCS to count.
     * @example
     * // Count the number of RM_QCS
     * const count = await prisma.rM_QC.count({
     *   where: {
     *     // ... the filter for the RM_QCS we want to count
     *   }
     * })
    **/
    count<T extends RM_QCCountArgs>(
      args?: Subset<T, RM_QCCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RM_QCCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RM_QC.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RM_QCAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RM_QCAggregateArgs>(args: Subset<T, RM_QCAggregateArgs>): Prisma.PrismaPromise<GetRM_QCAggregateType<T>>

    /**
     * Group by RM_QC.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RM_QCGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RM_QCGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RM_QCGroupByArgs['orderBy'] }
        : { orderBy?: RM_QCGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RM_QCGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRM_QCGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RM_QC model
   */
  readonly fields: RM_QCFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RM_QC.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RM_QCClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    rawMaterial<T extends RAW_MATERIALSDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RAW_MATERIALSDefaultArgs<ExtArgs>>): Prisma__RAW_MATERIALSClient<$Result.GetResult<Prisma.$RAW_MATERIALSPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    transaction<T extends RM_TRANSACTIONSDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RM_TRANSACTIONSDefaultArgs<ExtArgs>>): Prisma__RM_TRANSACTIONSClient<$Result.GetResult<Prisma.$RM_TRANSACTIONSPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    checkedBy<T extends EmployeeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EmployeeDefaultArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    doneBy<T extends EmployeeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EmployeeDefaultArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RM_QC model
   */ 
  interface RM_QCFieldRefs {
    readonly id: FieldRef<"RM_QC", 'Int'>
    readonly transactionId: FieldRef<"RM_QC", 'Int'>
    readonly rawMaterialId: FieldRef<"RM_QC", 'BigInt'>
    readonly quality_status: FieldRef<"RM_QC", 'QualityStatus'>
    readonly checkedById: FieldRef<"RM_QC", 'Int'>
    readonly doneById: FieldRef<"RM_QC", 'Int'>
    readonly createdAt: FieldRef<"RM_QC", 'DateTime'>
    readonly updatedAt: FieldRef<"RM_QC", 'DateTime'>
    readonly deletedAt: FieldRef<"RM_QC", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * RM_QC findUnique
   */
  export type RM_QCFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RM_QC
     */
    select?: RM_QCSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RM_QC
     */
    omit?: RM_QCOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RM_QCInclude<ExtArgs> | null
    /**
     * Filter, which RM_QC to fetch.
     */
    where: RM_QCWhereUniqueInput
  }

  /**
   * RM_QC findUniqueOrThrow
   */
  export type RM_QCFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RM_QC
     */
    select?: RM_QCSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RM_QC
     */
    omit?: RM_QCOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RM_QCInclude<ExtArgs> | null
    /**
     * Filter, which RM_QC to fetch.
     */
    where: RM_QCWhereUniqueInput
  }

  /**
   * RM_QC findFirst
   */
  export type RM_QCFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RM_QC
     */
    select?: RM_QCSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RM_QC
     */
    omit?: RM_QCOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RM_QCInclude<ExtArgs> | null
    /**
     * Filter, which RM_QC to fetch.
     */
    where?: RM_QCWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RM_QCS to fetch.
     */
    orderBy?: RM_QCOrderByWithRelationInput | RM_QCOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RM_QCS.
     */
    cursor?: RM_QCWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RM_QCS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RM_QCS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RM_QCS.
     */
    distinct?: RM_QCScalarFieldEnum | RM_QCScalarFieldEnum[]
  }

  /**
   * RM_QC findFirstOrThrow
   */
  export type RM_QCFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RM_QC
     */
    select?: RM_QCSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RM_QC
     */
    omit?: RM_QCOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RM_QCInclude<ExtArgs> | null
    /**
     * Filter, which RM_QC to fetch.
     */
    where?: RM_QCWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RM_QCS to fetch.
     */
    orderBy?: RM_QCOrderByWithRelationInput | RM_QCOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RM_QCS.
     */
    cursor?: RM_QCWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RM_QCS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RM_QCS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RM_QCS.
     */
    distinct?: RM_QCScalarFieldEnum | RM_QCScalarFieldEnum[]
  }

  /**
   * RM_QC findMany
   */
  export type RM_QCFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RM_QC
     */
    select?: RM_QCSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RM_QC
     */
    omit?: RM_QCOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RM_QCInclude<ExtArgs> | null
    /**
     * Filter, which RM_QCS to fetch.
     */
    where?: RM_QCWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RM_QCS to fetch.
     */
    orderBy?: RM_QCOrderByWithRelationInput | RM_QCOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RM_QCS.
     */
    cursor?: RM_QCWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RM_QCS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RM_QCS.
     */
    skip?: number
    distinct?: RM_QCScalarFieldEnum | RM_QCScalarFieldEnum[]
  }

  /**
   * RM_QC create
   */
  export type RM_QCCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RM_QC
     */
    select?: RM_QCSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RM_QC
     */
    omit?: RM_QCOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RM_QCInclude<ExtArgs> | null
    /**
     * The data needed to create a RM_QC.
     */
    data: XOR<RM_QCCreateInput, RM_QCUncheckedCreateInput>
  }

  /**
   * RM_QC createMany
   */
  export type RM_QCCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RM_QCS.
     */
    data: RM_QCCreateManyInput | RM_QCCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RM_QC update
   */
  export type RM_QCUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RM_QC
     */
    select?: RM_QCSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RM_QC
     */
    omit?: RM_QCOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RM_QCInclude<ExtArgs> | null
    /**
     * The data needed to update a RM_QC.
     */
    data: XOR<RM_QCUpdateInput, RM_QCUncheckedUpdateInput>
    /**
     * Choose, which RM_QC to update.
     */
    where: RM_QCWhereUniqueInput
  }

  /**
   * RM_QC updateMany
   */
  export type RM_QCUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RM_QCS.
     */
    data: XOR<RM_QCUpdateManyMutationInput, RM_QCUncheckedUpdateManyInput>
    /**
     * Filter which RM_QCS to update
     */
    where?: RM_QCWhereInput
  }

  /**
   * RM_QC upsert
   */
  export type RM_QCUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RM_QC
     */
    select?: RM_QCSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RM_QC
     */
    omit?: RM_QCOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RM_QCInclude<ExtArgs> | null
    /**
     * The filter to search for the RM_QC to update in case it exists.
     */
    where: RM_QCWhereUniqueInput
    /**
     * In case the RM_QC found by the `where` argument doesn't exist, create a new RM_QC with this data.
     */
    create: XOR<RM_QCCreateInput, RM_QCUncheckedCreateInput>
    /**
     * In case the RM_QC was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RM_QCUpdateInput, RM_QCUncheckedUpdateInput>
  }

  /**
   * RM_QC delete
   */
  export type RM_QCDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RM_QC
     */
    select?: RM_QCSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RM_QC
     */
    omit?: RM_QCOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RM_QCInclude<ExtArgs> | null
    /**
     * Filter which RM_QC to delete.
     */
    where: RM_QCWhereUniqueInput
  }

  /**
   * RM_QC deleteMany
   */
  export type RM_QCDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RM_QCS to delete
     */
    where?: RM_QCWhereInput
  }

  /**
   * RM_QC without action
   */
  export type RM_QCDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RM_QC
     */
    select?: RM_QCSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RM_QC
     */
    omit?: RM_QCOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RM_QCInclude<ExtArgs> | null
  }


  /**
   * Model RM_WASTAGE_LOGS
   */

  export type AggregateRM_WASTAGE_LOGS = {
    _count: RM_WASTAGE_LOGSCountAggregateOutputType | null
    _avg: RM_WASTAGE_LOGSAvgAggregateOutputType | null
    _sum: RM_WASTAGE_LOGSSumAggregateOutputType | null
    _min: RM_WASTAGE_LOGSMinAggregateOutputType | null
    _max: RM_WASTAGE_LOGSMaxAggregateOutputType | null
  }

  export type RM_WASTAGE_LOGSAvgAggregateOutputType = {
    id: number | null
    transactionId: number | null
    rawMaterialId: number | null
    quantity: number | null
  }

  export type RM_WASTAGE_LOGSSumAggregateOutputType = {
    id: number | null
    transactionId: number | null
    rawMaterialId: bigint | null
    quantity: number | null
  }

  export type RM_WASTAGE_LOGSMinAggregateOutputType = {
    id: number | null
    transactionId: number | null
    rawMaterialId: bigint | null
    quantity: number | null
    reason: string | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type RM_WASTAGE_LOGSMaxAggregateOutputType = {
    id: number | null
    transactionId: number | null
    rawMaterialId: bigint | null
    quantity: number | null
    reason: string | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type RM_WASTAGE_LOGSCountAggregateOutputType = {
    id: number
    transactionId: number
    rawMaterialId: number
    quantity: number
    reason: number
    createdAt: number
    updatedAt: number
    deletedAt: number
    _all: number
  }


  export type RM_WASTAGE_LOGSAvgAggregateInputType = {
    id?: true
    transactionId?: true
    rawMaterialId?: true
    quantity?: true
  }

  export type RM_WASTAGE_LOGSSumAggregateInputType = {
    id?: true
    transactionId?: true
    rawMaterialId?: true
    quantity?: true
  }

  export type RM_WASTAGE_LOGSMinAggregateInputType = {
    id?: true
    transactionId?: true
    rawMaterialId?: true
    quantity?: true
    reason?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type RM_WASTAGE_LOGSMaxAggregateInputType = {
    id?: true
    transactionId?: true
    rawMaterialId?: true
    quantity?: true
    reason?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type RM_WASTAGE_LOGSCountAggregateInputType = {
    id?: true
    transactionId?: true
    rawMaterialId?: true
    quantity?: true
    reason?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
    _all?: true
  }

  export type RM_WASTAGE_LOGSAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RM_WASTAGE_LOGS to aggregate.
     */
    where?: RM_WASTAGE_LOGSWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RM_WASTAGE_LOGS to fetch.
     */
    orderBy?: RM_WASTAGE_LOGSOrderByWithRelationInput | RM_WASTAGE_LOGSOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RM_WASTAGE_LOGSWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RM_WASTAGE_LOGS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RM_WASTAGE_LOGS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RM_WASTAGE_LOGS
    **/
    _count?: true | RM_WASTAGE_LOGSCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RM_WASTAGE_LOGSAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RM_WASTAGE_LOGSSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RM_WASTAGE_LOGSMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RM_WASTAGE_LOGSMaxAggregateInputType
  }

  export type GetRM_WASTAGE_LOGSAggregateType<T extends RM_WASTAGE_LOGSAggregateArgs> = {
        [P in keyof T & keyof AggregateRM_WASTAGE_LOGS]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRM_WASTAGE_LOGS[P]>
      : GetScalarType<T[P], AggregateRM_WASTAGE_LOGS[P]>
  }




  export type RM_WASTAGE_LOGSGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RM_WASTAGE_LOGSWhereInput
    orderBy?: RM_WASTAGE_LOGSOrderByWithAggregationInput | RM_WASTAGE_LOGSOrderByWithAggregationInput[]
    by: RM_WASTAGE_LOGSScalarFieldEnum[] | RM_WASTAGE_LOGSScalarFieldEnum
    having?: RM_WASTAGE_LOGSScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RM_WASTAGE_LOGSCountAggregateInputType | true
    _avg?: RM_WASTAGE_LOGSAvgAggregateInputType
    _sum?: RM_WASTAGE_LOGSSumAggregateInputType
    _min?: RM_WASTAGE_LOGSMinAggregateInputType
    _max?: RM_WASTAGE_LOGSMaxAggregateInputType
  }

  export type RM_WASTAGE_LOGSGroupByOutputType = {
    id: number
    transactionId: number
    rawMaterialId: bigint
    quantity: number
    reason: string
    createdAt: Date
    updatedAt: Date
    deletedAt: Date | null
    _count: RM_WASTAGE_LOGSCountAggregateOutputType | null
    _avg: RM_WASTAGE_LOGSAvgAggregateOutputType | null
    _sum: RM_WASTAGE_LOGSSumAggregateOutputType | null
    _min: RM_WASTAGE_LOGSMinAggregateOutputType | null
    _max: RM_WASTAGE_LOGSMaxAggregateOutputType | null
  }

  type GetRM_WASTAGE_LOGSGroupByPayload<T extends RM_WASTAGE_LOGSGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RM_WASTAGE_LOGSGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RM_WASTAGE_LOGSGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RM_WASTAGE_LOGSGroupByOutputType[P]>
            : GetScalarType<T[P], RM_WASTAGE_LOGSGroupByOutputType[P]>
        }
      >
    >


  export type RM_WASTAGE_LOGSSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    transactionId?: boolean
    rawMaterialId?: boolean
    quantity?: boolean
    reason?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    rawMaterial?: boolean | RAW_MATERIALSDefaultArgs<ExtArgs>
    transaction?: boolean | RM_TRANSACTIONSDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["rM_WASTAGE_LOGS"]>



  export type RM_WASTAGE_LOGSSelectScalar = {
    id?: boolean
    transactionId?: boolean
    rawMaterialId?: boolean
    quantity?: boolean
    reason?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
  }

  export type RM_WASTAGE_LOGSOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "transactionId" | "rawMaterialId" | "quantity" | "reason" | "createdAt" | "updatedAt" | "deletedAt", ExtArgs["result"]["rM_WASTAGE_LOGS"]>
  export type RM_WASTAGE_LOGSInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    rawMaterial?: boolean | RAW_MATERIALSDefaultArgs<ExtArgs>
    transaction?: boolean | RM_TRANSACTIONSDefaultArgs<ExtArgs>
  }

  export type $RM_WASTAGE_LOGSPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RM_WASTAGE_LOGS"
    objects: {
      rawMaterial: Prisma.$RAW_MATERIALSPayload<ExtArgs>
      transaction: Prisma.$RM_TRANSACTIONSPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      transactionId: number
      rawMaterialId: bigint
      quantity: number
      reason: string
      createdAt: Date
      updatedAt: Date
      deletedAt: Date | null
    }, ExtArgs["result"]["rM_WASTAGE_LOGS"]>
    composites: {}
  }

  type RM_WASTAGE_LOGSGetPayload<S extends boolean | null | undefined | RM_WASTAGE_LOGSDefaultArgs> = $Result.GetResult<Prisma.$RM_WASTAGE_LOGSPayload, S>

  type RM_WASTAGE_LOGSCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RM_WASTAGE_LOGSFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RM_WASTAGE_LOGSCountAggregateInputType | true
    }

  export interface RM_WASTAGE_LOGSDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RM_WASTAGE_LOGS'], meta: { name: 'RM_WASTAGE_LOGS' } }
    /**
     * Find zero or one RM_WASTAGE_LOGS that matches the filter.
     * @param {RM_WASTAGE_LOGSFindUniqueArgs} args - Arguments to find a RM_WASTAGE_LOGS
     * @example
     * // Get one RM_WASTAGE_LOGS
     * const rM_WASTAGE_LOGS = await prisma.rM_WASTAGE_LOGS.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RM_WASTAGE_LOGSFindUniqueArgs>(args: SelectSubset<T, RM_WASTAGE_LOGSFindUniqueArgs<ExtArgs>>): Prisma__RM_WASTAGE_LOGSClient<$Result.GetResult<Prisma.$RM_WASTAGE_LOGSPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one RM_WASTAGE_LOGS that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RM_WASTAGE_LOGSFindUniqueOrThrowArgs} args - Arguments to find a RM_WASTAGE_LOGS
     * @example
     * // Get one RM_WASTAGE_LOGS
     * const rM_WASTAGE_LOGS = await prisma.rM_WASTAGE_LOGS.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RM_WASTAGE_LOGSFindUniqueOrThrowArgs>(args: SelectSubset<T, RM_WASTAGE_LOGSFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RM_WASTAGE_LOGSClient<$Result.GetResult<Prisma.$RM_WASTAGE_LOGSPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first RM_WASTAGE_LOGS that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RM_WASTAGE_LOGSFindFirstArgs} args - Arguments to find a RM_WASTAGE_LOGS
     * @example
     * // Get one RM_WASTAGE_LOGS
     * const rM_WASTAGE_LOGS = await prisma.rM_WASTAGE_LOGS.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RM_WASTAGE_LOGSFindFirstArgs>(args?: SelectSubset<T, RM_WASTAGE_LOGSFindFirstArgs<ExtArgs>>): Prisma__RM_WASTAGE_LOGSClient<$Result.GetResult<Prisma.$RM_WASTAGE_LOGSPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first RM_WASTAGE_LOGS that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RM_WASTAGE_LOGSFindFirstOrThrowArgs} args - Arguments to find a RM_WASTAGE_LOGS
     * @example
     * // Get one RM_WASTAGE_LOGS
     * const rM_WASTAGE_LOGS = await prisma.rM_WASTAGE_LOGS.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RM_WASTAGE_LOGSFindFirstOrThrowArgs>(args?: SelectSubset<T, RM_WASTAGE_LOGSFindFirstOrThrowArgs<ExtArgs>>): Prisma__RM_WASTAGE_LOGSClient<$Result.GetResult<Prisma.$RM_WASTAGE_LOGSPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more RM_WASTAGE_LOGS that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RM_WASTAGE_LOGSFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RM_WASTAGE_LOGS
     * const rM_WASTAGE_LOGS = await prisma.rM_WASTAGE_LOGS.findMany()
     * 
     * // Get first 10 RM_WASTAGE_LOGS
     * const rM_WASTAGE_LOGS = await prisma.rM_WASTAGE_LOGS.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const rM_WASTAGE_LOGSWithIdOnly = await prisma.rM_WASTAGE_LOGS.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RM_WASTAGE_LOGSFindManyArgs>(args?: SelectSubset<T, RM_WASTAGE_LOGSFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RM_WASTAGE_LOGSPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a RM_WASTAGE_LOGS.
     * @param {RM_WASTAGE_LOGSCreateArgs} args - Arguments to create a RM_WASTAGE_LOGS.
     * @example
     * // Create one RM_WASTAGE_LOGS
     * const RM_WASTAGE_LOGS = await prisma.rM_WASTAGE_LOGS.create({
     *   data: {
     *     // ... data to create a RM_WASTAGE_LOGS
     *   }
     * })
     * 
     */
    create<T extends RM_WASTAGE_LOGSCreateArgs>(args: SelectSubset<T, RM_WASTAGE_LOGSCreateArgs<ExtArgs>>): Prisma__RM_WASTAGE_LOGSClient<$Result.GetResult<Prisma.$RM_WASTAGE_LOGSPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many RM_WASTAGE_LOGS.
     * @param {RM_WASTAGE_LOGSCreateManyArgs} args - Arguments to create many RM_WASTAGE_LOGS.
     * @example
     * // Create many RM_WASTAGE_LOGS
     * const rM_WASTAGE_LOGS = await prisma.rM_WASTAGE_LOGS.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RM_WASTAGE_LOGSCreateManyArgs>(args?: SelectSubset<T, RM_WASTAGE_LOGSCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a RM_WASTAGE_LOGS.
     * @param {RM_WASTAGE_LOGSDeleteArgs} args - Arguments to delete one RM_WASTAGE_LOGS.
     * @example
     * // Delete one RM_WASTAGE_LOGS
     * const RM_WASTAGE_LOGS = await prisma.rM_WASTAGE_LOGS.delete({
     *   where: {
     *     // ... filter to delete one RM_WASTAGE_LOGS
     *   }
     * })
     * 
     */
    delete<T extends RM_WASTAGE_LOGSDeleteArgs>(args: SelectSubset<T, RM_WASTAGE_LOGSDeleteArgs<ExtArgs>>): Prisma__RM_WASTAGE_LOGSClient<$Result.GetResult<Prisma.$RM_WASTAGE_LOGSPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one RM_WASTAGE_LOGS.
     * @param {RM_WASTAGE_LOGSUpdateArgs} args - Arguments to update one RM_WASTAGE_LOGS.
     * @example
     * // Update one RM_WASTAGE_LOGS
     * const rM_WASTAGE_LOGS = await prisma.rM_WASTAGE_LOGS.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RM_WASTAGE_LOGSUpdateArgs>(args: SelectSubset<T, RM_WASTAGE_LOGSUpdateArgs<ExtArgs>>): Prisma__RM_WASTAGE_LOGSClient<$Result.GetResult<Prisma.$RM_WASTAGE_LOGSPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more RM_WASTAGE_LOGS.
     * @param {RM_WASTAGE_LOGSDeleteManyArgs} args - Arguments to filter RM_WASTAGE_LOGS to delete.
     * @example
     * // Delete a few RM_WASTAGE_LOGS
     * const { count } = await prisma.rM_WASTAGE_LOGS.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RM_WASTAGE_LOGSDeleteManyArgs>(args?: SelectSubset<T, RM_WASTAGE_LOGSDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RM_WASTAGE_LOGS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RM_WASTAGE_LOGSUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RM_WASTAGE_LOGS
     * const rM_WASTAGE_LOGS = await prisma.rM_WASTAGE_LOGS.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RM_WASTAGE_LOGSUpdateManyArgs>(args: SelectSubset<T, RM_WASTAGE_LOGSUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one RM_WASTAGE_LOGS.
     * @param {RM_WASTAGE_LOGSUpsertArgs} args - Arguments to update or create a RM_WASTAGE_LOGS.
     * @example
     * // Update or create a RM_WASTAGE_LOGS
     * const rM_WASTAGE_LOGS = await prisma.rM_WASTAGE_LOGS.upsert({
     *   create: {
     *     // ... data to create a RM_WASTAGE_LOGS
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RM_WASTAGE_LOGS we want to update
     *   }
     * })
     */
    upsert<T extends RM_WASTAGE_LOGSUpsertArgs>(args: SelectSubset<T, RM_WASTAGE_LOGSUpsertArgs<ExtArgs>>): Prisma__RM_WASTAGE_LOGSClient<$Result.GetResult<Prisma.$RM_WASTAGE_LOGSPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of RM_WASTAGE_LOGS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RM_WASTAGE_LOGSCountArgs} args - Arguments to filter RM_WASTAGE_LOGS to count.
     * @example
     * // Count the number of RM_WASTAGE_LOGS
     * const count = await prisma.rM_WASTAGE_LOGS.count({
     *   where: {
     *     // ... the filter for the RM_WASTAGE_LOGS we want to count
     *   }
     * })
    **/
    count<T extends RM_WASTAGE_LOGSCountArgs>(
      args?: Subset<T, RM_WASTAGE_LOGSCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RM_WASTAGE_LOGSCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RM_WASTAGE_LOGS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RM_WASTAGE_LOGSAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RM_WASTAGE_LOGSAggregateArgs>(args: Subset<T, RM_WASTAGE_LOGSAggregateArgs>): Prisma.PrismaPromise<GetRM_WASTAGE_LOGSAggregateType<T>>

    /**
     * Group by RM_WASTAGE_LOGS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RM_WASTAGE_LOGSGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RM_WASTAGE_LOGSGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RM_WASTAGE_LOGSGroupByArgs['orderBy'] }
        : { orderBy?: RM_WASTAGE_LOGSGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RM_WASTAGE_LOGSGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRM_WASTAGE_LOGSGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RM_WASTAGE_LOGS model
   */
  readonly fields: RM_WASTAGE_LOGSFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RM_WASTAGE_LOGS.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RM_WASTAGE_LOGSClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    rawMaterial<T extends RAW_MATERIALSDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RAW_MATERIALSDefaultArgs<ExtArgs>>): Prisma__RAW_MATERIALSClient<$Result.GetResult<Prisma.$RAW_MATERIALSPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    transaction<T extends RM_TRANSACTIONSDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RM_TRANSACTIONSDefaultArgs<ExtArgs>>): Prisma__RM_TRANSACTIONSClient<$Result.GetResult<Prisma.$RM_TRANSACTIONSPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RM_WASTAGE_LOGS model
   */ 
  interface RM_WASTAGE_LOGSFieldRefs {
    readonly id: FieldRef<"RM_WASTAGE_LOGS", 'Int'>
    readonly transactionId: FieldRef<"RM_WASTAGE_LOGS", 'Int'>
    readonly rawMaterialId: FieldRef<"RM_WASTAGE_LOGS", 'BigInt'>
    readonly quantity: FieldRef<"RM_WASTAGE_LOGS", 'Int'>
    readonly reason: FieldRef<"RM_WASTAGE_LOGS", 'String'>
    readonly createdAt: FieldRef<"RM_WASTAGE_LOGS", 'DateTime'>
    readonly updatedAt: FieldRef<"RM_WASTAGE_LOGS", 'DateTime'>
    readonly deletedAt: FieldRef<"RM_WASTAGE_LOGS", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * RM_WASTAGE_LOGS findUnique
   */
  export type RM_WASTAGE_LOGSFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RM_WASTAGE_LOGS
     */
    select?: RM_WASTAGE_LOGSSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RM_WASTAGE_LOGS
     */
    omit?: RM_WASTAGE_LOGSOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RM_WASTAGE_LOGSInclude<ExtArgs> | null
    /**
     * Filter, which RM_WASTAGE_LOGS to fetch.
     */
    where: RM_WASTAGE_LOGSWhereUniqueInput
  }

  /**
   * RM_WASTAGE_LOGS findUniqueOrThrow
   */
  export type RM_WASTAGE_LOGSFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RM_WASTAGE_LOGS
     */
    select?: RM_WASTAGE_LOGSSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RM_WASTAGE_LOGS
     */
    omit?: RM_WASTAGE_LOGSOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RM_WASTAGE_LOGSInclude<ExtArgs> | null
    /**
     * Filter, which RM_WASTAGE_LOGS to fetch.
     */
    where: RM_WASTAGE_LOGSWhereUniqueInput
  }

  /**
   * RM_WASTAGE_LOGS findFirst
   */
  export type RM_WASTAGE_LOGSFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RM_WASTAGE_LOGS
     */
    select?: RM_WASTAGE_LOGSSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RM_WASTAGE_LOGS
     */
    omit?: RM_WASTAGE_LOGSOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RM_WASTAGE_LOGSInclude<ExtArgs> | null
    /**
     * Filter, which RM_WASTAGE_LOGS to fetch.
     */
    where?: RM_WASTAGE_LOGSWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RM_WASTAGE_LOGS to fetch.
     */
    orderBy?: RM_WASTAGE_LOGSOrderByWithRelationInput | RM_WASTAGE_LOGSOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RM_WASTAGE_LOGS.
     */
    cursor?: RM_WASTAGE_LOGSWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RM_WASTAGE_LOGS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RM_WASTAGE_LOGS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RM_WASTAGE_LOGS.
     */
    distinct?: RM_WASTAGE_LOGSScalarFieldEnum | RM_WASTAGE_LOGSScalarFieldEnum[]
  }

  /**
   * RM_WASTAGE_LOGS findFirstOrThrow
   */
  export type RM_WASTAGE_LOGSFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RM_WASTAGE_LOGS
     */
    select?: RM_WASTAGE_LOGSSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RM_WASTAGE_LOGS
     */
    omit?: RM_WASTAGE_LOGSOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RM_WASTAGE_LOGSInclude<ExtArgs> | null
    /**
     * Filter, which RM_WASTAGE_LOGS to fetch.
     */
    where?: RM_WASTAGE_LOGSWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RM_WASTAGE_LOGS to fetch.
     */
    orderBy?: RM_WASTAGE_LOGSOrderByWithRelationInput | RM_WASTAGE_LOGSOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RM_WASTAGE_LOGS.
     */
    cursor?: RM_WASTAGE_LOGSWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RM_WASTAGE_LOGS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RM_WASTAGE_LOGS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RM_WASTAGE_LOGS.
     */
    distinct?: RM_WASTAGE_LOGSScalarFieldEnum | RM_WASTAGE_LOGSScalarFieldEnum[]
  }

  /**
   * RM_WASTAGE_LOGS findMany
   */
  export type RM_WASTAGE_LOGSFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RM_WASTAGE_LOGS
     */
    select?: RM_WASTAGE_LOGSSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RM_WASTAGE_LOGS
     */
    omit?: RM_WASTAGE_LOGSOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RM_WASTAGE_LOGSInclude<ExtArgs> | null
    /**
     * Filter, which RM_WASTAGE_LOGS to fetch.
     */
    where?: RM_WASTAGE_LOGSWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RM_WASTAGE_LOGS to fetch.
     */
    orderBy?: RM_WASTAGE_LOGSOrderByWithRelationInput | RM_WASTAGE_LOGSOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RM_WASTAGE_LOGS.
     */
    cursor?: RM_WASTAGE_LOGSWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RM_WASTAGE_LOGS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RM_WASTAGE_LOGS.
     */
    skip?: number
    distinct?: RM_WASTAGE_LOGSScalarFieldEnum | RM_WASTAGE_LOGSScalarFieldEnum[]
  }

  /**
   * RM_WASTAGE_LOGS create
   */
  export type RM_WASTAGE_LOGSCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RM_WASTAGE_LOGS
     */
    select?: RM_WASTAGE_LOGSSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RM_WASTAGE_LOGS
     */
    omit?: RM_WASTAGE_LOGSOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RM_WASTAGE_LOGSInclude<ExtArgs> | null
    /**
     * The data needed to create a RM_WASTAGE_LOGS.
     */
    data: XOR<RM_WASTAGE_LOGSCreateInput, RM_WASTAGE_LOGSUncheckedCreateInput>
  }

  /**
   * RM_WASTAGE_LOGS createMany
   */
  export type RM_WASTAGE_LOGSCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RM_WASTAGE_LOGS.
     */
    data: RM_WASTAGE_LOGSCreateManyInput | RM_WASTAGE_LOGSCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RM_WASTAGE_LOGS update
   */
  export type RM_WASTAGE_LOGSUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RM_WASTAGE_LOGS
     */
    select?: RM_WASTAGE_LOGSSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RM_WASTAGE_LOGS
     */
    omit?: RM_WASTAGE_LOGSOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RM_WASTAGE_LOGSInclude<ExtArgs> | null
    /**
     * The data needed to update a RM_WASTAGE_LOGS.
     */
    data: XOR<RM_WASTAGE_LOGSUpdateInput, RM_WASTAGE_LOGSUncheckedUpdateInput>
    /**
     * Choose, which RM_WASTAGE_LOGS to update.
     */
    where: RM_WASTAGE_LOGSWhereUniqueInput
  }

  /**
   * RM_WASTAGE_LOGS updateMany
   */
  export type RM_WASTAGE_LOGSUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RM_WASTAGE_LOGS.
     */
    data: XOR<RM_WASTAGE_LOGSUpdateManyMutationInput, RM_WASTAGE_LOGSUncheckedUpdateManyInput>
    /**
     * Filter which RM_WASTAGE_LOGS to update
     */
    where?: RM_WASTAGE_LOGSWhereInput
  }

  /**
   * RM_WASTAGE_LOGS upsert
   */
  export type RM_WASTAGE_LOGSUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RM_WASTAGE_LOGS
     */
    select?: RM_WASTAGE_LOGSSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RM_WASTAGE_LOGS
     */
    omit?: RM_WASTAGE_LOGSOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RM_WASTAGE_LOGSInclude<ExtArgs> | null
    /**
     * The filter to search for the RM_WASTAGE_LOGS to update in case it exists.
     */
    where: RM_WASTAGE_LOGSWhereUniqueInput
    /**
     * In case the RM_WASTAGE_LOGS found by the `where` argument doesn't exist, create a new RM_WASTAGE_LOGS with this data.
     */
    create: XOR<RM_WASTAGE_LOGSCreateInput, RM_WASTAGE_LOGSUncheckedCreateInput>
    /**
     * In case the RM_WASTAGE_LOGS was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RM_WASTAGE_LOGSUpdateInput, RM_WASTAGE_LOGSUncheckedUpdateInput>
  }

  /**
   * RM_WASTAGE_LOGS delete
   */
  export type RM_WASTAGE_LOGSDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RM_WASTAGE_LOGS
     */
    select?: RM_WASTAGE_LOGSSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RM_WASTAGE_LOGS
     */
    omit?: RM_WASTAGE_LOGSOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RM_WASTAGE_LOGSInclude<ExtArgs> | null
    /**
     * Filter which RM_WASTAGE_LOGS to delete.
     */
    where: RM_WASTAGE_LOGSWhereUniqueInput
  }

  /**
   * RM_WASTAGE_LOGS deleteMany
   */
  export type RM_WASTAGE_LOGSDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RM_WASTAGE_LOGS to delete
     */
    where?: RM_WASTAGE_LOGSWhereInput
  }

  /**
   * RM_WASTAGE_LOGS without action
   */
  export type RM_WASTAGE_LOGSDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RM_WASTAGE_LOGS
     */
    select?: RM_WASTAGE_LOGSSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RM_WASTAGE_LOGS
     */
    omit?: RM_WASTAGE_LOGSOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RM_WASTAGE_LOGSInclude<ExtArgs> | null
  }


  /**
   * Model Employee
   */

  export type AggregateEmployee = {
    _count: EmployeeCountAggregateOutputType | null
    _avg: EmployeeAvgAggregateOutputType | null
    _sum: EmployeeSumAggregateOutputType | null
    _min: EmployeeMinAggregateOutputType | null
    _max: EmployeeMaxAggregateOutputType | null
  }

  export type EmployeeAvgAggregateOutputType = {
    id: number | null
  }

  export type EmployeeSumAggregateOutputType = {
    id: number | null
  }

  export type EmployeeMinAggregateOutputType = {
    id: number | null
    name: string | null
    role: $Enums.Roles | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type EmployeeMaxAggregateOutputType = {
    id: number | null
    name: string | null
    role: $Enums.Roles | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type EmployeeCountAggregateOutputType = {
    id: number
    name: number
    role: number
    createdAt: number
    updatedAt: number
    deletedAt: number
    _all: number
  }


  export type EmployeeAvgAggregateInputType = {
    id?: true
  }

  export type EmployeeSumAggregateInputType = {
    id?: true
  }

  export type EmployeeMinAggregateInputType = {
    id?: true
    name?: true
    role?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type EmployeeMaxAggregateInputType = {
    id?: true
    name?: true
    role?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type EmployeeCountAggregateInputType = {
    id?: true
    name?: true
    role?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
    _all?: true
  }

  export type EmployeeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Employee to aggregate.
     */
    where?: EmployeeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Employees to fetch.
     */
    orderBy?: EmployeeOrderByWithRelationInput | EmployeeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EmployeeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Employees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Employees.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Employees
    **/
    _count?: true | EmployeeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EmployeeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EmployeeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EmployeeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EmployeeMaxAggregateInputType
  }

  export type GetEmployeeAggregateType<T extends EmployeeAggregateArgs> = {
        [P in keyof T & keyof AggregateEmployee]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEmployee[P]>
      : GetScalarType<T[P], AggregateEmployee[P]>
  }




  export type EmployeeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmployeeWhereInput
    orderBy?: EmployeeOrderByWithAggregationInput | EmployeeOrderByWithAggregationInput[]
    by: EmployeeScalarFieldEnum[] | EmployeeScalarFieldEnum
    having?: EmployeeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EmployeeCountAggregateInputType | true
    _avg?: EmployeeAvgAggregateInputType
    _sum?: EmployeeSumAggregateInputType
    _min?: EmployeeMinAggregateInputType
    _max?: EmployeeMaxAggregateInputType
  }

  export type EmployeeGroupByOutputType = {
    id: number
    name: string
    role: $Enums.Roles
    createdAt: Date
    updatedAt: Date
    deletedAt: Date | null
    _count: EmployeeCountAggregateOutputType | null
    _avg: EmployeeAvgAggregateOutputType | null
    _sum: EmployeeSumAggregateOutputType | null
    _min: EmployeeMinAggregateOutputType | null
    _max: EmployeeMaxAggregateOutputType | null
  }

  type GetEmployeeGroupByPayload<T extends EmployeeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EmployeeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EmployeeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EmployeeGroupByOutputType[P]>
            : GetScalarType<T[P], EmployeeGroupByOutputType[P]>
        }
      >
    >


  export type EmployeeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    role?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    RM_QC?: boolean | Employee$RM_QCArgs<ExtArgs>
    RM_QC2?: boolean | Employee$RM_QC2Args<ExtArgs>
    RMTransactions?: boolean | Employee$RMTransactionsArgs<ExtArgs>
    WIPTransactions?: boolean | Employee$WIPTransactionsArgs<ExtArgs>
    FGTransactions?: boolean | Employee$FGTransactionsArgs<ExtArgs>
    AuditLogs?: boolean | Employee$AuditLogsArgs<ExtArgs>
    _count?: boolean | EmployeeCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["employee"]>



  export type EmployeeSelectScalar = {
    id?: boolean
    name?: boolean
    role?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
  }

  export type EmployeeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "role" | "createdAt" | "updatedAt" | "deletedAt", ExtArgs["result"]["employee"]>
  export type EmployeeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    RM_QC?: boolean | Employee$RM_QCArgs<ExtArgs>
    RM_QC2?: boolean | Employee$RM_QC2Args<ExtArgs>
    RMTransactions?: boolean | Employee$RMTransactionsArgs<ExtArgs>
    WIPTransactions?: boolean | Employee$WIPTransactionsArgs<ExtArgs>
    FGTransactions?: boolean | Employee$FGTransactionsArgs<ExtArgs>
    AuditLogs?: boolean | Employee$AuditLogsArgs<ExtArgs>
    _count?: boolean | EmployeeCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $EmployeePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Employee"
    objects: {
      RM_QC: Prisma.$RM_QCPayload<ExtArgs>[]
      RM_QC2: Prisma.$RM_QCPayload<ExtArgs>[]
      RMTransactions: Prisma.$RM_TRANSACTIONSPayload<ExtArgs>[]
      WIPTransactions: Prisma.$WIP_TRANSACTIONSPayload<ExtArgs>[]
      FGTransactions: Prisma.$FG_TRANSACTIONSPayload<ExtArgs>[]
      AuditLogs: Prisma.$AuditLogsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      role: $Enums.Roles
      createdAt: Date
      updatedAt: Date
      deletedAt: Date | null
    }, ExtArgs["result"]["employee"]>
    composites: {}
  }

  type EmployeeGetPayload<S extends boolean | null | undefined | EmployeeDefaultArgs> = $Result.GetResult<Prisma.$EmployeePayload, S>

  type EmployeeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<EmployeeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: EmployeeCountAggregateInputType | true
    }

  export interface EmployeeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Employee'], meta: { name: 'Employee' } }
    /**
     * Find zero or one Employee that matches the filter.
     * @param {EmployeeFindUniqueArgs} args - Arguments to find a Employee
     * @example
     * // Get one Employee
     * const employee = await prisma.employee.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EmployeeFindUniqueArgs>(args: SelectSubset<T, EmployeeFindUniqueArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Employee that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {EmployeeFindUniqueOrThrowArgs} args - Arguments to find a Employee
     * @example
     * // Get one Employee
     * const employee = await prisma.employee.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EmployeeFindUniqueOrThrowArgs>(args: SelectSubset<T, EmployeeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Employee that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeFindFirstArgs} args - Arguments to find a Employee
     * @example
     * // Get one Employee
     * const employee = await prisma.employee.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EmployeeFindFirstArgs>(args?: SelectSubset<T, EmployeeFindFirstArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Employee that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeFindFirstOrThrowArgs} args - Arguments to find a Employee
     * @example
     * // Get one Employee
     * const employee = await prisma.employee.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EmployeeFindFirstOrThrowArgs>(args?: SelectSubset<T, EmployeeFindFirstOrThrowArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Employees that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Employees
     * const employees = await prisma.employee.findMany()
     * 
     * // Get first 10 Employees
     * const employees = await prisma.employee.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const employeeWithIdOnly = await prisma.employee.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EmployeeFindManyArgs>(args?: SelectSubset<T, EmployeeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Employee.
     * @param {EmployeeCreateArgs} args - Arguments to create a Employee.
     * @example
     * // Create one Employee
     * const Employee = await prisma.employee.create({
     *   data: {
     *     // ... data to create a Employee
     *   }
     * })
     * 
     */
    create<T extends EmployeeCreateArgs>(args: SelectSubset<T, EmployeeCreateArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Employees.
     * @param {EmployeeCreateManyArgs} args - Arguments to create many Employees.
     * @example
     * // Create many Employees
     * const employee = await prisma.employee.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EmployeeCreateManyArgs>(args?: SelectSubset<T, EmployeeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Employee.
     * @param {EmployeeDeleteArgs} args - Arguments to delete one Employee.
     * @example
     * // Delete one Employee
     * const Employee = await prisma.employee.delete({
     *   where: {
     *     // ... filter to delete one Employee
     *   }
     * })
     * 
     */
    delete<T extends EmployeeDeleteArgs>(args: SelectSubset<T, EmployeeDeleteArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Employee.
     * @param {EmployeeUpdateArgs} args - Arguments to update one Employee.
     * @example
     * // Update one Employee
     * const employee = await prisma.employee.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EmployeeUpdateArgs>(args: SelectSubset<T, EmployeeUpdateArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Employees.
     * @param {EmployeeDeleteManyArgs} args - Arguments to filter Employees to delete.
     * @example
     * // Delete a few Employees
     * const { count } = await prisma.employee.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EmployeeDeleteManyArgs>(args?: SelectSubset<T, EmployeeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Employees.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Employees
     * const employee = await prisma.employee.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EmployeeUpdateManyArgs>(args: SelectSubset<T, EmployeeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Employee.
     * @param {EmployeeUpsertArgs} args - Arguments to update or create a Employee.
     * @example
     * // Update or create a Employee
     * const employee = await prisma.employee.upsert({
     *   create: {
     *     // ... data to create a Employee
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Employee we want to update
     *   }
     * })
     */
    upsert<T extends EmployeeUpsertArgs>(args: SelectSubset<T, EmployeeUpsertArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Employees.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeCountArgs} args - Arguments to filter Employees to count.
     * @example
     * // Count the number of Employees
     * const count = await prisma.employee.count({
     *   where: {
     *     // ... the filter for the Employees we want to count
     *   }
     * })
    **/
    count<T extends EmployeeCountArgs>(
      args?: Subset<T, EmployeeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EmployeeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Employee.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EmployeeAggregateArgs>(args: Subset<T, EmployeeAggregateArgs>): Prisma.PrismaPromise<GetEmployeeAggregateType<T>>

    /**
     * Group by Employee.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EmployeeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EmployeeGroupByArgs['orderBy'] }
        : { orderBy?: EmployeeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EmployeeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEmployeeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Employee model
   */
  readonly fields: EmployeeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Employee.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EmployeeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    RM_QC<T extends Employee$RM_QCArgs<ExtArgs> = {}>(args?: Subset<T, Employee$RM_QCArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RM_QCPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    RM_QC2<T extends Employee$RM_QC2Args<ExtArgs> = {}>(args?: Subset<T, Employee$RM_QC2Args<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RM_QCPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    RMTransactions<T extends Employee$RMTransactionsArgs<ExtArgs> = {}>(args?: Subset<T, Employee$RMTransactionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RM_TRANSACTIONSPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    WIPTransactions<T extends Employee$WIPTransactionsArgs<ExtArgs> = {}>(args?: Subset<T, Employee$WIPTransactionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WIP_TRANSACTIONSPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    FGTransactions<T extends Employee$FGTransactionsArgs<ExtArgs> = {}>(args?: Subset<T, Employee$FGTransactionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FG_TRANSACTIONSPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    AuditLogs<T extends Employee$AuditLogsArgs<ExtArgs> = {}>(args?: Subset<T, Employee$AuditLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogsPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Employee model
   */ 
  interface EmployeeFieldRefs {
    readonly id: FieldRef<"Employee", 'Int'>
    readonly name: FieldRef<"Employee", 'String'>
    readonly role: FieldRef<"Employee", 'Roles'>
    readonly createdAt: FieldRef<"Employee", 'DateTime'>
    readonly updatedAt: FieldRef<"Employee", 'DateTime'>
    readonly deletedAt: FieldRef<"Employee", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Employee findUnique
   */
  export type EmployeeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    /**
     * Filter, which Employee to fetch.
     */
    where: EmployeeWhereUniqueInput
  }

  /**
   * Employee findUniqueOrThrow
   */
  export type EmployeeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    /**
     * Filter, which Employee to fetch.
     */
    where: EmployeeWhereUniqueInput
  }

  /**
   * Employee findFirst
   */
  export type EmployeeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    /**
     * Filter, which Employee to fetch.
     */
    where?: EmployeeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Employees to fetch.
     */
    orderBy?: EmployeeOrderByWithRelationInput | EmployeeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Employees.
     */
    cursor?: EmployeeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Employees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Employees.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Employees.
     */
    distinct?: EmployeeScalarFieldEnum | EmployeeScalarFieldEnum[]
  }

  /**
   * Employee findFirstOrThrow
   */
  export type EmployeeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    /**
     * Filter, which Employee to fetch.
     */
    where?: EmployeeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Employees to fetch.
     */
    orderBy?: EmployeeOrderByWithRelationInput | EmployeeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Employees.
     */
    cursor?: EmployeeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Employees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Employees.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Employees.
     */
    distinct?: EmployeeScalarFieldEnum | EmployeeScalarFieldEnum[]
  }

  /**
   * Employee findMany
   */
  export type EmployeeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    /**
     * Filter, which Employees to fetch.
     */
    where?: EmployeeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Employees to fetch.
     */
    orderBy?: EmployeeOrderByWithRelationInput | EmployeeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Employees.
     */
    cursor?: EmployeeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Employees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Employees.
     */
    skip?: number
    distinct?: EmployeeScalarFieldEnum | EmployeeScalarFieldEnum[]
  }

  /**
   * Employee create
   */
  export type EmployeeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    /**
     * The data needed to create a Employee.
     */
    data: XOR<EmployeeCreateInput, EmployeeUncheckedCreateInput>
  }

  /**
   * Employee createMany
   */
  export type EmployeeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Employees.
     */
    data: EmployeeCreateManyInput | EmployeeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Employee update
   */
  export type EmployeeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    /**
     * The data needed to update a Employee.
     */
    data: XOR<EmployeeUpdateInput, EmployeeUncheckedUpdateInput>
    /**
     * Choose, which Employee to update.
     */
    where: EmployeeWhereUniqueInput
  }

  /**
   * Employee updateMany
   */
  export type EmployeeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Employees.
     */
    data: XOR<EmployeeUpdateManyMutationInput, EmployeeUncheckedUpdateManyInput>
    /**
     * Filter which Employees to update
     */
    where?: EmployeeWhereInput
  }

  /**
   * Employee upsert
   */
  export type EmployeeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    /**
     * The filter to search for the Employee to update in case it exists.
     */
    where: EmployeeWhereUniqueInput
    /**
     * In case the Employee found by the `where` argument doesn't exist, create a new Employee with this data.
     */
    create: XOR<EmployeeCreateInput, EmployeeUncheckedCreateInput>
    /**
     * In case the Employee was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EmployeeUpdateInput, EmployeeUncheckedUpdateInput>
  }

  /**
   * Employee delete
   */
  export type EmployeeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    /**
     * Filter which Employee to delete.
     */
    where: EmployeeWhereUniqueInput
  }

  /**
   * Employee deleteMany
   */
  export type EmployeeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Employees to delete
     */
    where?: EmployeeWhereInput
  }

  /**
   * Employee.RM_QC
   */
  export type Employee$RM_QCArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RM_QC
     */
    select?: RM_QCSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RM_QC
     */
    omit?: RM_QCOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RM_QCInclude<ExtArgs> | null
    where?: RM_QCWhereInput
    orderBy?: RM_QCOrderByWithRelationInput | RM_QCOrderByWithRelationInput[]
    cursor?: RM_QCWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RM_QCScalarFieldEnum | RM_QCScalarFieldEnum[]
  }

  /**
   * Employee.RM_QC2
   */
  export type Employee$RM_QC2Args<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RM_QC
     */
    select?: RM_QCSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RM_QC
     */
    omit?: RM_QCOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RM_QCInclude<ExtArgs> | null
    where?: RM_QCWhereInput
    orderBy?: RM_QCOrderByWithRelationInput | RM_QCOrderByWithRelationInput[]
    cursor?: RM_QCWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RM_QCScalarFieldEnum | RM_QCScalarFieldEnum[]
  }

  /**
   * Employee.RMTransactions
   */
  export type Employee$RMTransactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RM_TRANSACTIONS
     */
    select?: RM_TRANSACTIONSSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RM_TRANSACTIONS
     */
    omit?: RM_TRANSACTIONSOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RM_TRANSACTIONSInclude<ExtArgs> | null
    where?: RM_TRANSACTIONSWhereInput
    orderBy?: RM_TRANSACTIONSOrderByWithRelationInput | RM_TRANSACTIONSOrderByWithRelationInput[]
    cursor?: RM_TRANSACTIONSWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RM_TRANSACTIONSScalarFieldEnum | RM_TRANSACTIONSScalarFieldEnum[]
  }

  /**
   * Employee.WIPTransactions
   */
  export type Employee$WIPTransactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WIP_TRANSACTIONS
     */
    select?: WIP_TRANSACTIONSSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WIP_TRANSACTIONS
     */
    omit?: WIP_TRANSACTIONSOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WIP_TRANSACTIONSInclude<ExtArgs> | null
    where?: WIP_TRANSACTIONSWhereInput
    orderBy?: WIP_TRANSACTIONSOrderByWithRelationInput | WIP_TRANSACTIONSOrderByWithRelationInput[]
    cursor?: WIP_TRANSACTIONSWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WIP_TRANSACTIONSScalarFieldEnum | WIP_TRANSACTIONSScalarFieldEnum[]
  }

  /**
   * Employee.FGTransactions
   */
  export type Employee$FGTransactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FG_TRANSACTIONS
     */
    select?: FG_TRANSACTIONSSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FG_TRANSACTIONS
     */
    omit?: FG_TRANSACTIONSOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FG_TRANSACTIONSInclude<ExtArgs> | null
    where?: FG_TRANSACTIONSWhereInput
    orderBy?: FG_TRANSACTIONSOrderByWithRelationInput | FG_TRANSACTIONSOrderByWithRelationInput[]
    cursor?: FG_TRANSACTIONSWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FG_TRANSACTIONSScalarFieldEnum | FG_TRANSACTIONSScalarFieldEnum[]
  }

  /**
   * Employee.AuditLogs
   */
  export type Employee$AuditLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLogs
     */
    select?: AuditLogsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLogs
     */
    omit?: AuditLogsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogsInclude<ExtArgs> | null
    where?: AuditLogsWhereInput
    orderBy?: AuditLogsOrderByWithRelationInput | AuditLogsOrderByWithRelationInput[]
    cursor?: AuditLogsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AuditLogsScalarFieldEnum | AuditLogsScalarFieldEnum[]
  }

  /**
   * Employee without action
   */
  export type EmployeeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
  }


  /**
   * Model WIP
   */

  export type AggregateWIP = {
    _count: WIPCountAggregateOutputType | null
    _avg: WIPAvgAggregateOutputType | null
    _sum: WIPSumAggregateOutputType | null
    _min: WIPMinAggregateOutputType | null
    _max: WIPMaxAggregateOutputType | null
  }

  export type WIPAvgAggregateOutputType = {
    id: number | null
    orderId: number | null
  }

  export type WIPSumAggregateOutputType = {
    id: number | null
    orderId: number | null
  }

  export type WIPMinAggregateOutputType = {
    id: number | null
    orderId: number | null
    status: $Enums.Status | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type WIPMaxAggregateOutputType = {
    id: number | null
    orderId: number | null
    status: $Enums.Status | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type WIPCountAggregateOutputType = {
    id: number
    orderId: number
    status: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type WIPAvgAggregateInputType = {
    id?: true
    orderId?: true
  }

  export type WIPSumAggregateInputType = {
    id?: true
    orderId?: true
  }

  export type WIPMinAggregateInputType = {
    id?: true
    orderId?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type WIPMaxAggregateInputType = {
    id?: true
    orderId?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type WIPCountAggregateInputType = {
    id?: true
    orderId?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type WIPAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WIP to aggregate.
     */
    where?: WIPWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WIPS to fetch.
     */
    orderBy?: WIPOrderByWithRelationInput | WIPOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WIPWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WIPS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WIPS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned WIPS
    **/
    _count?: true | WIPCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: WIPAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: WIPSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WIPMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WIPMaxAggregateInputType
  }

  export type GetWIPAggregateType<T extends WIPAggregateArgs> = {
        [P in keyof T & keyof AggregateWIP]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWIP[P]>
      : GetScalarType<T[P], AggregateWIP[P]>
  }




  export type WIPGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WIPWhereInput
    orderBy?: WIPOrderByWithAggregationInput | WIPOrderByWithAggregationInput[]
    by: WIPScalarFieldEnum[] | WIPScalarFieldEnum
    having?: WIPScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WIPCountAggregateInputType | true
    _avg?: WIPAvgAggregateInputType
    _sum?: WIPSumAggregateInputType
    _min?: WIPMinAggregateInputType
    _max?: WIPMaxAggregateInputType
  }

  export type WIPGroupByOutputType = {
    id: number
    orderId: number
    status: $Enums.Status
    createdAt: Date
    updatedAt: Date
    _count: WIPCountAggregateOutputType | null
    _avg: WIPAvgAggregateOutputType | null
    _sum: WIPSumAggregateOutputType | null
    _min: WIPMinAggregateOutputType | null
    _max: WIPMaxAggregateOutputType | null
  }

  type GetWIPGroupByPayload<T extends WIPGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WIPGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WIPGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WIPGroupByOutputType[P]>
            : GetScalarType<T[P], WIPGroupByOutputType[P]>
        }
      >
    >


  export type WIPSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orderId?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    WIPTransactions?: boolean | WIP$WIPTransactionsArgs<ExtArgs>
    WIPQCs?: boolean | WIP$WIPQCsArgs<ExtArgs>
    WIPWastageLogs?: boolean | WIP$WIPWastageLogsArgs<ExtArgs>
    wipProducts?: boolean | WIP$wipProductsArgs<ExtArgs>
    WIPMaterials?: boolean | WIP$WIPMaterialsArgs<ExtArgs>
    _count?: boolean | WIPCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["wIP"]>



  export type WIPSelectScalar = {
    id?: boolean
    orderId?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type WIPOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "orderId" | "status" | "createdAt" | "updatedAt", ExtArgs["result"]["wIP"]>
  export type WIPInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    WIPTransactions?: boolean | WIP$WIPTransactionsArgs<ExtArgs>
    WIPQCs?: boolean | WIP$WIPQCsArgs<ExtArgs>
    WIPWastageLogs?: boolean | WIP$WIPWastageLogsArgs<ExtArgs>
    wipProducts?: boolean | WIP$wipProductsArgs<ExtArgs>
    WIPMaterials?: boolean | WIP$WIPMaterialsArgs<ExtArgs>
    _count?: boolean | WIPCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $WIPPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "WIP"
    objects: {
      WIPTransactions: Prisma.$WIP_TRANSACTIONSPayload<ExtArgs>[]
      WIPQCs: Prisma.$WIP_QCPayload<ExtArgs>[]
      WIPWastageLogs: Prisma.$WIP_WASTAGE_LOGSPayload<ExtArgs>[]
      wipProducts: Prisma.$WIP_PRODUCTSPayload<ExtArgs>[]
      WIPMaterials: Prisma.$WIPRawMaterialPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      orderId: number
      status: $Enums.Status
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["wIP"]>
    composites: {}
  }

  type WIPGetPayload<S extends boolean | null | undefined | WIPDefaultArgs> = $Result.GetResult<Prisma.$WIPPayload, S>

  type WIPCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<WIPFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: WIPCountAggregateInputType | true
    }

  export interface WIPDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['WIP'], meta: { name: 'WIP' } }
    /**
     * Find zero or one WIP that matches the filter.
     * @param {WIPFindUniqueArgs} args - Arguments to find a WIP
     * @example
     * // Get one WIP
     * const wIP = await prisma.wIP.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WIPFindUniqueArgs>(args: SelectSubset<T, WIPFindUniqueArgs<ExtArgs>>): Prisma__WIPClient<$Result.GetResult<Prisma.$WIPPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one WIP that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {WIPFindUniqueOrThrowArgs} args - Arguments to find a WIP
     * @example
     * // Get one WIP
     * const wIP = await prisma.wIP.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WIPFindUniqueOrThrowArgs>(args: SelectSubset<T, WIPFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WIPClient<$Result.GetResult<Prisma.$WIPPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first WIP that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WIPFindFirstArgs} args - Arguments to find a WIP
     * @example
     * // Get one WIP
     * const wIP = await prisma.wIP.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WIPFindFirstArgs>(args?: SelectSubset<T, WIPFindFirstArgs<ExtArgs>>): Prisma__WIPClient<$Result.GetResult<Prisma.$WIPPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first WIP that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WIPFindFirstOrThrowArgs} args - Arguments to find a WIP
     * @example
     * // Get one WIP
     * const wIP = await prisma.wIP.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WIPFindFirstOrThrowArgs>(args?: SelectSubset<T, WIPFindFirstOrThrowArgs<ExtArgs>>): Prisma__WIPClient<$Result.GetResult<Prisma.$WIPPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more WIPS that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WIPFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all WIPS
     * const wIPS = await prisma.wIP.findMany()
     * 
     * // Get first 10 WIPS
     * const wIPS = await prisma.wIP.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const wIPWithIdOnly = await prisma.wIP.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends WIPFindManyArgs>(args?: SelectSubset<T, WIPFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WIPPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a WIP.
     * @param {WIPCreateArgs} args - Arguments to create a WIP.
     * @example
     * // Create one WIP
     * const WIP = await prisma.wIP.create({
     *   data: {
     *     // ... data to create a WIP
     *   }
     * })
     * 
     */
    create<T extends WIPCreateArgs>(args: SelectSubset<T, WIPCreateArgs<ExtArgs>>): Prisma__WIPClient<$Result.GetResult<Prisma.$WIPPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many WIPS.
     * @param {WIPCreateManyArgs} args - Arguments to create many WIPS.
     * @example
     * // Create many WIPS
     * const wIP = await prisma.wIP.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WIPCreateManyArgs>(args?: SelectSubset<T, WIPCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a WIP.
     * @param {WIPDeleteArgs} args - Arguments to delete one WIP.
     * @example
     * // Delete one WIP
     * const WIP = await prisma.wIP.delete({
     *   where: {
     *     // ... filter to delete one WIP
     *   }
     * })
     * 
     */
    delete<T extends WIPDeleteArgs>(args: SelectSubset<T, WIPDeleteArgs<ExtArgs>>): Prisma__WIPClient<$Result.GetResult<Prisma.$WIPPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one WIP.
     * @param {WIPUpdateArgs} args - Arguments to update one WIP.
     * @example
     * // Update one WIP
     * const wIP = await prisma.wIP.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WIPUpdateArgs>(args: SelectSubset<T, WIPUpdateArgs<ExtArgs>>): Prisma__WIPClient<$Result.GetResult<Prisma.$WIPPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more WIPS.
     * @param {WIPDeleteManyArgs} args - Arguments to filter WIPS to delete.
     * @example
     * // Delete a few WIPS
     * const { count } = await prisma.wIP.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WIPDeleteManyArgs>(args?: SelectSubset<T, WIPDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WIPS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WIPUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many WIPS
     * const wIP = await prisma.wIP.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WIPUpdateManyArgs>(args: SelectSubset<T, WIPUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one WIP.
     * @param {WIPUpsertArgs} args - Arguments to update or create a WIP.
     * @example
     * // Update or create a WIP
     * const wIP = await prisma.wIP.upsert({
     *   create: {
     *     // ... data to create a WIP
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the WIP we want to update
     *   }
     * })
     */
    upsert<T extends WIPUpsertArgs>(args: SelectSubset<T, WIPUpsertArgs<ExtArgs>>): Prisma__WIPClient<$Result.GetResult<Prisma.$WIPPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of WIPS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WIPCountArgs} args - Arguments to filter WIPS to count.
     * @example
     * // Count the number of WIPS
     * const count = await prisma.wIP.count({
     *   where: {
     *     // ... the filter for the WIPS we want to count
     *   }
     * })
    **/
    count<T extends WIPCountArgs>(
      args?: Subset<T, WIPCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WIPCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a WIP.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WIPAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WIPAggregateArgs>(args: Subset<T, WIPAggregateArgs>): Prisma.PrismaPromise<GetWIPAggregateType<T>>

    /**
     * Group by WIP.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WIPGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WIPGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WIPGroupByArgs['orderBy'] }
        : { orderBy?: WIPGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WIPGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWIPGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the WIP model
   */
  readonly fields: WIPFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for WIP.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WIPClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    WIPTransactions<T extends WIP$WIPTransactionsArgs<ExtArgs> = {}>(args?: Subset<T, WIP$WIPTransactionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WIP_TRANSACTIONSPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    WIPQCs<T extends WIP$WIPQCsArgs<ExtArgs> = {}>(args?: Subset<T, WIP$WIPQCsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WIP_QCPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    WIPWastageLogs<T extends WIP$WIPWastageLogsArgs<ExtArgs> = {}>(args?: Subset<T, WIP$WIPWastageLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WIP_WASTAGE_LOGSPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    wipProducts<T extends WIP$wipProductsArgs<ExtArgs> = {}>(args?: Subset<T, WIP$wipProductsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WIP_PRODUCTSPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    WIPMaterials<T extends WIP$WIPMaterialsArgs<ExtArgs> = {}>(args?: Subset<T, WIP$WIPMaterialsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WIPRawMaterialPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the WIP model
   */ 
  interface WIPFieldRefs {
    readonly id: FieldRef<"WIP", 'Int'>
    readonly orderId: FieldRef<"WIP", 'Int'>
    readonly status: FieldRef<"WIP", 'Status'>
    readonly createdAt: FieldRef<"WIP", 'DateTime'>
    readonly updatedAt: FieldRef<"WIP", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * WIP findUnique
   */
  export type WIPFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WIP
     */
    select?: WIPSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WIP
     */
    omit?: WIPOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WIPInclude<ExtArgs> | null
    /**
     * Filter, which WIP to fetch.
     */
    where: WIPWhereUniqueInput
  }

  /**
   * WIP findUniqueOrThrow
   */
  export type WIPFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WIP
     */
    select?: WIPSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WIP
     */
    omit?: WIPOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WIPInclude<ExtArgs> | null
    /**
     * Filter, which WIP to fetch.
     */
    where: WIPWhereUniqueInput
  }

  /**
   * WIP findFirst
   */
  export type WIPFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WIP
     */
    select?: WIPSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WIP
     */
    omit?: WIPOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WIPInclude<ExtArgs> | null
    /**
     * Filter, which WIP to fetch.
     */
    where?: WIPWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WIPS to fetch.
     */
    orderBy?: WIPOrderByWithRelationInput | WIPOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WIPS.
     */
    cursor?: WIPWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WIPS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WIPS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WIPS.
     */
    distinct?: WIPScalarFieldEnum | WIPScalarFieldEnum[]
  }

  /**
   * WIP findFirstOrThrow
   */
  export type WIPFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WIP
     */
    select?: WIPSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WIP
     */
    omit?: WIPOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WIPInclude<ExtArgs> | null
    /**
     * Filter, which WIP to fetch.
     */
    where?: WIPWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WIPS to fetch.
     */
    orderBy?: WIPOrderByWithRelationInput | WIPOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WIPS.
     */
    cursor?: WIPWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WIPS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WIPS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WIPS.
     */
    distinct?: WIPScalarFieldEnum | WIPScalarFieldEnum[]
  }

  /**
   * WIP findMany
   */
  export type WIPFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WIP
     */
    select?: WIPSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WIP
     */
    omit?: WIPOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WIPInclude<ExtArgs> | null
    /**
     * Filter, which WIPS to fetch.
     */
    where?: WIPWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WIPS to fetch.
     */
    orderBy?: WIPOrderByWithRelationInput | WIPOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing WIPS.
     */
    cursor?: WIPWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WIPS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WIPS.
     */
    skip?: number
    distinct?: WIPScalarFieldEnum | WIPScalarFieldEnum[]
  }

  /**
   * WIP create
   */
  export type WIPCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WIP
     */
    select?: WIPSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WIP
     */
    omit?: WIPOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WIPInclude<ExtArgs> | null
    /**
     * The data needed to create a WIP.
     */
    data: XOR<WIPCreateInput, WIPUncheckedCreateInput>
  }

  /**
   * WIP createMany
   */
  export type WIPCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many WIPS.
     */
    data: WIPCreateManyInput | WIPCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * WIP update
   */
  export type WIPUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WIP
     */
    select?: WIPSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WIP
     */
    omit?: WIPOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WIPInclude<ExtArgs> | null
    /**
     * The data needed to update a WIP.
     */
    data: XOR<WIPUpdateInput, WIPUncheckedUpdateInput>
    /**
     * Choose, which WIP to update.
     */
    where: WIPWhereUniqueInput
  }

  /**
   * WIP updateMany
   */
  export type WIPUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update WIPS.
     */
    data: XOR<WIPUpdateManyMutationInput, WIPUncheckedUpdateManyInput>
    /**
     * Filter which WIPS to update
     */
    where?: WIPWhereInput
  }

  /**
   * WIP upsert
   */
  export type WIPUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WIP
     */
    select?: WIPSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WIP
     */
    omit?: WIPOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WIPInclude<ExtArgs> | null
    /**
     * The filter to search for the WIP to update in case it exists.
     */
    where: WIPWhereUniqueInput
    /**
     * In case the WIP found by the `where` argument doesn't exist, create a new WIP with this data.
     */
    create: XOR<WIPCreateInput, WIPUncheckedCreateInput>
    /**
     * In case the WIP was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WIPUpdateInput, WIPUncheckedUpdateInput>
  }

  /**
   * WIP delete
   */
  export type WIPDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WIP
     */
    select?: WIPSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WIP
     */
    omit?: WIPOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WIPInclude<ExtArgs> | null
    /**
     * Filter which WIP to delete.
     */
    where: WIPWhereUniqueInput
  }

  /**
   * WIP deleteMany
   */
  export type WIPDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WIPS to delete
     */
    where?: WIPWhereInput
  }

  /**
   * WIP.WIPTransactions
   */
  export type WIP$WIPTransactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WIP_TRANSACTIONS
     */
    select?: WIP_TRANSACTIONSSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WIP_TRANSACTIONS
     */
    omit?: WIP_TRANSACTIONSOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WIP_TRANSACTIONSInclude<ExtArgs> | null
    where?: WIP_TRANSACTIONSWhereInput
    orderBy?: WIP_TRANSACTIONSOrderByWithRelationInput | WIP_TRANSACTIONSOrderByWithRelationInput[]
    cursor?: WIP_TRANSACTIONSWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WIP_TRANSACTIONSScalarFieldEnum | WIP_TRANSACTIONSScalarFieldEnum[]
  }

  /**
   * WIP.WIPQCs
   */
  export type WIP$WIPQCsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WIP_QC
     */
    select?: WIP_QCSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WIP_QC
     */
    omit?: WIP_QCOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WIP_QCInclude<ExtArgs> | null
    where?: WIP_QCWhereInput
    orderBy?: WIP_QCOrderByWithRelationInput | WIP_QCOrderByWithRelationInput[]
    cursor?: WIP_QCWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WIP_QCScalarFieldEnum | WIP_QCScalarFieldEnum[]
  }

  /**
   * WIP.WIPWastageLogs
   */
  export type WIP$WIPWastageLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WIP_WASTAGE_LOGS
     */
    select?: WIP_WASTAGE_LOGSSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WIP_WASTAGE_LOGS
     */
    omit?: WIP_WASTAGE_LOGSOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WIP_WASTAGE_LOGSInclude<ExtArgs> | null
    where?: WIP_WASTAGE_LOGSWhereInput
    orderBy?: WIP_WASTAGE_LOGSOrderByWithRelationInput | WIP_WASTAGE_LOGSOrderByWithRelationInput[]
    cursor?: WIP_WASTAGE_LOGSWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WIP_WASTAGE_LOGSScalarFieldEnum | WIP_WASTAGE_LOGSScalarFieldEnum[]
  }

  /**
   * WIP.wipProducts
   */
  export type WIP$wipProductsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WIP_PRODUCTS
     */
    select?: WIP_PRODUCTSSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WIP_PRODUCTS
     */
    omit?: WIP_PRODUCTSOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WIP_PRODUCTSInclude<ExtArgs> | null
    where?: WIP_PRODUCTSWhereInput
    orderBy?: WIP_PRODUCTSOrderByWithRelationInput | WIP_PRODUCTSOrderByWithRelationInput[]
    cursor?: WIP_PRODUCTSWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WIP_PRODUCTSScalarFieldEnum | WIP_PRODUCTSScalarFieldEnum[]
  }

  /**
   * WIP.WIPMaterials
   */
  export type WIP$WIPMaterialsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WIPRawMaterial
     */
    select?: WIPRawMaterialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WIPRawMaterial
     */
    omit?: WIPRawMaterialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WIPRawMaterialInclude<ExtArgs> | null
    where?: WIPRawMaterialWhereInput
    orderBy?: WIPRawMaterialOrderByWithRelationInput | WIPRawMaterialOrderByWithRelationInput[]
    cursor?: WIPRawMaterialWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WIPRawMaterialScalarFieldEnum | WIPRawMaterialScalarFieldEnum[]
  }

  /**
   * WIP without action
   */
  export type WIPDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WIP
     */
    select?: WIPSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WIP
     */
    omit?: WIPOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WIPInclude<ExtArgs> | null
  }


  /**
   * Model WIP_PRODUCTS
   */

  export type AggregateWIP_PRODUCTS = {
    _count: WIP_PRODUCTSCountAggregateOutputType | null
    _avg: WIP_PRODUCTSAvgAggregateOutputType | null
    _sum: WIP_PRODUCTSSumAggregateOutputType | null
    _min: WIP_PRODUCTSMinAggregateOutputType | null
    _max: WIP_PRODUCTSMaxAggregateOutputType | null
  }

  export type WIP_PRODUCTSAvgAggregateOutputType = {
    id: number | null
    wipId: number | null
    productId: number | null
    quantity: number | null
  }

  export type WIP_PRODUCTSSumAggregateOutputType = {
    id: number | null
    wipId: number | null
    productId: bigint | null
    quantity: number | null
  }

  export type WIP_PRODUCTSMinAggregateOutputType = {
    id: number | null
    wipId: number | null
    productId: bigint | null
    quantity: number | null
  }

  export type WIP_PRODUCTSMaxAggregateOutputType = {
    id: number | null
    wipId: number | null
    productId: bigint | null
    quantity: number | null
  }

  export type WIP_PRODUCTSCountAggregateOutputType = {
    id: number
    wipId: number
    productId: number
    quantity: number
    _all: number
  }


  export type WIP_PRODUCTSAvgAggregateInputType = {
    id?: true
    wipId?: true
    productId?: true
    quantity?: true
  }

  export type WIP_PRODUCTSSumAggregateInputType = {
    id?: true
    wipId?: true
    productId?: true
    quantity?: true
  }

  export type WIP_PRODUCTSMinAggregateInputType = {
    id?: true
    wipId?: true
    productId?: true
    quantity?: true
  }

  export type WIP_PRODUCTSMaxAggregateInputType = {
    id?: true
    wipId?: true
    productId?: true
    quantity?: true
  }

  export type WIP_PRODUCTSCountAggregateInputType = {
    id?: true
    wipId?: true
    productId?: true
    quantity?: true
    _all?: true
  }

  export type WIP_PRODUCTSAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WIP_PRODUCTS to aggregate.
     */
    where?: WIP_PRODUCTSWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WIP_PRODUCTS to fetch.
     */
    orderBy?: WIP_PRODUCTSOrderByWithRelationInput | WIP_PRODUCTSOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WIP_PRODUCTSWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WIP_PRODUCTS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WIP_PRODUCTS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned WIP_PRODUCTS
    **/
    _count?: true | WIP_PRODUCTSCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: WIP_PRODUCTSAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: WIP_PRODUCTSSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WIP_PRODUCTSMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WIP_PRODUCTSMaxAggregateInputType
  }

  export type GetWIP_PRODUCTSAggregateType<T extends WIP_PRODUCTSAggregateArgs> = {
        [P in keyof T & keyof AggregateWIP_PRODUCTS]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWIP_PRODUCTS[P]>
      : GetScalarType<T[P], AggregateWIP_PRODUCTS[P]>
  }




  export type WIP_PRODUCTSGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WIP_PRODUCTSWhereInput
    orderBy?: WIP_PRODUCTSOrderByWithAggregationInput | WIP_PRODUCTSOrderByWithAggregationInput[]
    by: WIP_PRODUCTSScalarFieldEnum[] | WIP_PRODUCTSScalarFieldEnum
    having?: WIP_PRODUCTSScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WIP_PRODUCTSCountAggregateInputType | true
    _avg?: WIP_PRODUCTSAvgAggregateInputType
    _sum?: WIP_PRODUCTSSumAggregateInputType
    _min?: WIP_PRODUCTSMinAggregateInputType
    _max?: WIP_PRODUCTSMaxAggregateInputType
  }

  export type WIP_PRODUCTSGroupByOutputType = {
    id: number
    wipId: number
    productId: bigint
    quantity: number
    _count: WIP_PRODUCTSCountAggregateOutputType | null
    _avg: WIP_PRODUCTSAvgAggregateOutputType | null
    _sum: WIP_PRODUCTSSumAggregateOutputType | null
    _min: WIP_PRODUCTSMinAggregateOutputType | null
    _max: WIP_PRODUCTSMaxAggregateOutputType | null
  }

  type GetWIP_PRODUCTSGroupByPayload<T extends WIP_PRODUCTSGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WIP_PRODUCTSGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WIP_PRODUCTSGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WIP_PRODUCTSGroupByOutputType[P]>
            : GetScalarType<T[P], WIP_PRODUCTSGroupByOutputType[P]>
        }
      >
    >


  export type WIP_PRODUCTSSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    wipId?: boolean
    productId?: boolean
    quantity?: boolean
    wip?: boolean | WIPDefaultArgs<ExtArgs>
    product?: boolean | SHOPIFY_PRODUCTSDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["wIP_PRODUCTS"]>



  export type WIP_PRODUCTSSelectScalar = {
    id?: boolean
    wipId?: boolean
    productId?: boolean
    quantity?: boolean
  }

  export type WIP_PRODUCTSOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "wipId" | "productId" | "quantity", ExtArgs["result"]["wIP_PRODUCTS"]>
  export type WIP_PRODUCTSInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    wip?: boolean | WIPDefaultArgs<ExtArgs>
    product?: boolean | SHOPIFY_PRODUCTSDefaultArgs<ExtArgs>
  }

  export type $WIP_PRODUCTSPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "WIP_PRODUCTS"
    objects: {
      wip: Prisma.$WIPPayload<ExtArgs>
      product: Prisma.$SHOPIFY_PRODUCTSPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      wipId: number
      productId: bigint
      quantity: number
    }, ExtArgs["result"]["wIP_PRODUCTS"]>
    composites: {}
  }

  type WIP_PRODUCTSGetPayload<S extends boolean | null | undefined | WIP_PRODUCTSDefaultArgs> = $Result.GetResult<Prisma.$WIP_PRODUCTSPayload, S>

  type WIP_PRODUCTSCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<WIP_PRODUCTSFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: WIP_PRODUCTSCountAggregateInputType | true
    }

  export interface WIP_PRODUCTSDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['WIP_PRODUCTS'], meta: { name: 'WIP_PRODUCTS' } }
    /**
     * Find zero or one WIP_PRODUCTS that matches the filter.
     * @param {WIP_PRODUCTSFindUniqueArgs} args - Arguments to find a WIP_PRODUCTS
     * @example
     * // Get one WIP_PRODUCTS
     * const wIP_PRODUCTS = await prisma.wIP_PRODUCTS.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WIP_PRODUCTSFindUniqueArgs>(args: SelectSubset<T, WIP_PRODUCTSFindUniqueArgs<ExtArgs>>): Prisma__WIP_PRODUCTSClient<$Result.GetResult<Prisma.$WIP_PRODUCTSPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one WIP_PRODUCTS that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {WIP_PRODUCTSFindUniqueOrThrowArgs} args - Arguments to find a WIP_PRODUCTS
     * @example
     * // Get one WIP_PRODUCTS
     * const wIP_PRODUCTS = await prisma.wIP_PRODUCTS.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WIP_PRODUCTSFindUniqueOrThrowArgs>(args: SelectSubset<T, WIP_PRODUCTSFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WIP_PRODUCTSClient<$Result.GetResult<Prisma.$WIP_PRODUCTSPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first WIP_PRODUCTS that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WIP_PRODUCTSFindFirstArgs} args - Arguments to find a WIP_PRODUCTS
     * @example
     * // Get one WIP_PRODUCTS
     * const wIP_PRODUCTS = await prisma.wIP_PRODUCTS.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WIP_PRODUCTSFindFirstArgs>(args?: SelectSubset<T, WIP_PRODUCTSFindFirstArgs<ExtArgs>>): Prisma__WIP_PRODUCTSClient<$Result.GetResult<Prisma.$WIP_PRODUCTSPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first WIP_PRODUCTS that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WIP_PRODUCTSFindFirstOrThrowArgs} args - Arguments to find a WIP_PRODUCTS
     * @example
     * // Get one WIP_PRODUCTS
     * const wIP_PRODUCTS = await prisma.wIP_PRODUCTS.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WIP_PRODUCTSFindFirstOrThrowArgs>(args?: SelectSubset<T, WIP_PRODUCTSFindFirstOrThrowArgs<ExtArgs>>): Prisma__WIP_PRODUCTSClient<$Result.GetResult<Prisma.$WIP_PRODUCTSPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more WIP_PRODUCTS that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WIP_PRODUCTSFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all WIP_PRODUCTS
     * const wIP_PRODUCTS = await prisma.wIP_PRODUCTS.findMany()
     * 
     * // Get first 10 WIP_PRODUCTS
     * const wIP_PRODUCTS = await prisma.wIP_PRODUCTS.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const wIP_PRODUCTSWithIdOnly = await prisma.wIP_PRODUCTS.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends WIP_PRODUCTSFindManyArgs>(args?: SelectSubset<T, WIP_PRODUCTSFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WIP_PRODUCTSPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a WIP_PRODUCTS.
     * @param {WIP_PRODUCTSCreateArgs} args - Arguments to create a WIP_PRODUCTS.
     * @example
     * // Create one WIP_PRODUCTS
     * const WIP_PRODUCTS = await prisma.wIP_PRODUCTS.create({
     *   data: {
     *     // ... data to create a WIP_PRODUCTS
     *   }
     * })
     * 
     */
    create<T extends WIP_PRODUCTSCreateArgs>(args: SelectSubset<T, WIP_PRODUCTSCreateArgs<ExtArgs>>): Prisma__WIP_PRODUCTSClient<$Result.GetResult<Prisma.$WIP_PRODUCTSPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many WIP_PRODUCTS.
     * @param {WIP_PRODUCTSCreateManyArgs} args - Arguments to create many WIP_PRODUCTS.
     * @example
     * // Create many WIP_PRODUCTS
     * const wIP_PRODUCTS = await prisma.wIP_PRODUCTS.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WIP_PRODUCTSCreateManyArgs>(args?: SelectSubset<T, WIP_PRODUCTSCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a WIP_PRODUCTS.
     * @param {WIP_PRODUCTSDeleteArgs} args - Arguments to delete one WIP_PRODUCTS.
     * @example
     * // Delete one WIP_PRODUCTS
     * const WIP_PRODUCTS = await prisma.wIP_PRODUCTS.delete({
     *   where: {
     *     // ... filter to delete one WIP_PRODUCTS
     *   }
     * })
     * 
     */
    delete<T extends WIP_PRODUCTSDeleteArgs>(args: SelectSubset<T, WIP_PRODUCTSDeleteArgs<ExtArgs>>): Prisma__WIP_PRODUCTSClient<$Result.GetResult<Prisma.$WIP_PRODUCTSPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one WIP_PRODUCTS.
     * @param {WIP_PRODUCTSUpdateArgs} args - Arguments to update one WIP_PRODUCTS.
     * @example
     * // Update one WIP_PRODUCTS
     * const wIP_PRODUCTS = await prisma.wIP_PRODUCTS.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WIP_PRODUCTSUpdateArgs>(args: SelectSubset<T, WIP_PRODUCTSUpdateArgs<ExtArgs>>): Prisma__WIP_PRODUCTSClient<$Result.GetResult<Prisma.$WIP_PRODUCTSPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more WIP_PRODUCTS.
     * @param {WIP_PRODUCTSDeleteManyArgs} args - Arguments to filter WIP_PRODUCTS to delete.
     * @example
     * // Delete a few WIP_PRODUCTS
     * const { count } = await prisma.wIP_PRODUCTS.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WIP_PRODUCTSDeleteManyArgs>(args?: SelectSubset<T, WIP_PRODUCTSDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WIP_PRODUCTS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WIP_PRODUCTSUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many WIP_PRODUCTS
     * const wIP_PRODUCTS = await prisma.wIP_PRODUCTS.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WIP_PRODUCTSUpdateManyArgs>(args: SelectSubset<T, WIP_PRODUCTSUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one WIP_PRODUCTS.
     * @param {WIP_PRODUCTSUpsertArgs} args - Arguments to update or create a WIP_PRODUCTS.
     * @example
     * // Update or create a WIP_PRODUCTS
     * const wIP_PRODUCTS = await prisma.wIP_PRODUCTS.upsert({
     *   create: {
     *     // ... data to create a WIP_PRODUCTS
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the WIP_PRODUCTS we want to update
     *   }
     * })
     */
    upsert<T extends WIP_PRODUCTSUpsertArgs>(args: SelectSubset<T, WIP_PRODUCTSUpsertArgs<ExtArgs>>): Prisma__WIP_PRODUCTSClient<$Result.GetResult<Prisma.$WIP_PRODUCTSPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of WIP_PRODUCTS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WIP_PRODUCTSCountArgs} args - Arguments to filter WIP_PRODUCTS to count.
     * @example
     * // Count the number of WIP_PRODUCTS
     * const count = await prisma.wIP_PRODUCTS.count({
     *   where: {
     *     // ... the filter for the WIP_PRODUCTS we want to count
     *   }
     * })
    **/
    count<T extends WIP_PRODUCTSCountArgs>(
      args?: Subset<T, WIP_PRODUCTSCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WIP_PRODUCTSCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a WIP_PRODUCTS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WIP_PRODUCTSAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WIP_PRODUCTSAggregateArgs>(args: Subset<T, WIP_PRODUCTSAggregateArgs>): Prisma.PrismaPromise<GetWIP_PRODUCTSAggregateType<T>>

    /**
     * Group by WIP_PRODUCTS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WIP_PRODUCTSGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WIP_PRODUCTSGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WIP_PRODUCTSGroupByArgs['orderBy'] }
        : { orderBy?: WIP_PRODUCTSGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WIP_PRODUCTSGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWIP_PRODUCTSGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the WIP_PRODUCTS model
   */
  readonly fields: WIP_PRODUCTSFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for WIP_PRODUCTS.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WIP_PRODUCTSClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    wip<T extends WIPDefaultArgs<ExtArgs> = {}>(args?: Subset<T, WIPDefaultArgs<ExtArgs>>): Prisma__WIPClient<$Result.GetResult<Prisma.$WIPPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    product<T extends SHOPIFY_PRODUCTSDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SHOPIFY_PRODUCTSDefaultArgs<ExtArgs>>): Prisma__SHOPIFY_PRODUCTSClient<$Result.GetResult<Prisma.$SHOPIFY_PRODUCTSPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the WIP_PRODUCTS model
   */ 
  interface WIP_PRODUCTSFieldRefs {
    readonly id: FieldRef<"WIP_PRODUCTS", 'Int'>
    readonly wipId: FieldRef<"WIP_PRODUCTS", 'Int'>
    readonly productId: FieldRef<"WIP_PRODUCTS", 'BigInt'>
    readonly quantity: FieldRef<"WIP_PRODUCTS", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * WIP_PRODUCTS findUnique
   */
  export type WIP_PRODUCTSFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WIP_PRODUCTS
     */
    select?: WIP_PRODUCTSSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WIP_PRODUCTS
     */
    omit?: WIP_PRODUCTSOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WIP_PRODUCTSInclude<ExtArgs> | null
    /**
     * Filter, which WIP_PRODUCTS to fetch.
     */
    where: WIP_PRODUCTSWhereUniqueInput
  }

  /**
   * WIP_PRODUCTS findUniqueOrThrow
   */
  export type WIP_PRODUCTSFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WIP_PRODUCTS
     */
    select?: WIP_PRODUCTSSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WIP_PRODUCTS
     */
    omit?: WIP_PRODUCTSOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WIP_PRODUCTSInclude<ExtArgs> | null
    /**
     * Filter, which WIP_PRODUCTS to fetch.
     */
    where: WIP_PRODUCTSWhereUniqueInput
  }

  /**
   * WIP_PRODUCTS findFirst
   */
  export type WIP_PRODUCTSFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WIP_PRODUCTS
     */
    select?: WIP_PRODUCTSSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WIP_PRODUCTS
     */
    omit?: WIP_PRODUCTSOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WIP_PRODUCTSInclude<ExtArgs> | null
    /**
     * Filter, which WIP_PRODUCTS to fetch.
     */
    where?: WIP_PRODUCTSWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WIP_PRODUCTS to fetch.
     */
    orderBy?: WIP_PRODUCTSOrderByWithRelationInput | WIP_PRODUCTSOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WIP_PRODUCTS.
     */
    cursor?: WIP_PRODUCTSWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WIP_PRODUCTS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WIP_PRODUCTS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WIP_PRODUCTS.
     */
    distinct?: WIP_PRODUCTSScalarFieldEnum | WIP_PRODUCTSScalarFieldEnum[]
  }

  /**
   * WIP_PRODUCTS findFirstOrThrow
   */
  export type WIP_PRODUCTSFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WIP_PRODUCTS
     */
    select?: WIP_PRODUCTSSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WIP_PRODUCTS
     */
    omit?: WIP_PRODUCTSOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WIP_PRODUCTSInclude<ExtArgs> | null
    /**
     * Filter, which WIP_PRODUCTS to fetch.
     */
    where?: WIP_PRODUCTSWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WIP_PRODUCTS to fetch.
     */
    orderBy?: WIP_PRODUCTSOrderByWithRelationInput | WIP_PRODUCTSOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WIP_PRODUCTS.
     */
    cursor?: WIP_PRODUCTSWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WIP_PRODUCTS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WIP_PRODUCTS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WIP_PRODUCTS.
     */
    distinct?: WIP_PRODUCTSScalarFieldEnum | WIP_PRODUCTSScalarFieldEnum[]
  }

  /**
   * WIP_PRODUCTS findMany
   */
  export type WIP_PRODUCTSFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WIP_PRODUCTS
     */
    select?: WIP_PRODUCTSSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WIP_PRODUCTS
     */
    omit?: WIP_PRODUCTSOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WIP_PRODUCTSInclude<ExtArgs> | null
    /**
     * Filter, which WIP_PRODUCTS to fetch.
     */
    where?: WIP_PRODUCTSWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WIP_PRODUCTS to fetch.
     */
    orderBy?: WIP_PRODUCTSOrderByWithRelationInput | WIP_PRODUCTSOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing WIP_PRODUCTS.
     */
    cursor?: WIP_PRODUCTSWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WIP_PRODUCTS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WIP_PRODUCTS.
     */
    skip?: number
    distinct?: WIP_PRODUCTSScalarFieldEnum | WIP_PRODUCTSScalarFieldEnum[]
  }

  /**
   * WIP_PRODUCTS create
   */
  export type WIP_PRODUCTSCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WIP_PRODUCTS
     */
    select?: WIP_PRODUCTSSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WIP_PRODUCTS
     */
    omit?: WIP_PRODUCTSOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WIP_PRODUCTSInclude<ExtArgs> | null
    /**
     * The data needed to create a WIP_PRODUCTS.
     */
    data: XOR<WIP_PRODUCTSCreateInput, WIP_PRODUCTSUncheckedCreateInput>
  }

  /**
   * WIP_PRODUCTS createMany
   */
  export type WIP_PRODUCTSCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many WIP_PRODUCTS.
     */
    data: WIP_PRODUCTSCreateManyInput | WIP_PRODUCTSCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * WIP_PRODUCTS update
   */
  export type WIP_PRODUCTSUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WIP_PRODUCTS
     */
    select?: WIP_PRODUCTSSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WIP_PRODUCTS
     */
    omit?: WIP_PRODUCTSOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WIP_PRODUCTSInclude<ExtArgs> | null
    /**
     * The data needed to update a WIP_PRODUCTS.
     */
    data: XOR<WIP_PRODUCTSUpdateInput, WIP_PRODUCTSUncheckedUpdateInput>
    /**
     * Choose, which WIP_PRODUCTS to update.
     */
    where: WIP_PRODUCTSWhereUniqueInput
  }

  /**
   * WIP_PRODUCTS updateMany
   */
  export type WIP_PRODUCTSUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update WIP_PRODUCTS.
     */
    data: XOR<WIP_PRODUCTSUpdateManyMutationInput, WIP_PRODUCTSUncheckedUpdateManyInput>
    /**
     * Filter which WIP_PRODUCTS to update
     */
    where?: WIP_PRODUCTSWhereInput
  }

  /**
   * WIP_PRODUCTS upsert
   */
  export type WIP_PRODUCTSUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WIP_PRODUCTS
     */
    select?: WIP_PRODUCTSSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WIP_PRODUCTS
     */
    omit?: WIP_PRODUCTSOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WIP_PRODUCTSInclude<ExtArgs> | null
    /**
     * The filter to search for the WIP_PRODUCTS to update in case it exists.
     */
    where: WIP_PRODUCTSWhereUniqueInput
    /**
     * In case the WIP_PRODUCTS found by the `where` argument doesn't exist, create a new WIP_PRODUCTS with this data.
     */
    create: XOR<WIP_PRODUCTSCreateInput, WIP_PRODUCTSUncheckedCreateInput>
    /**
     * In case the WIP_PRODUCTS was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WIP_PRODUCTSUpdateInput, WIP_PRODUCTSUncheckedUpdateInput>
  }

  /**
   * WIP_PRODUCTS delete
   */
  export type WIP_PRODUCTSDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WIP_PRODUCTS
     */
    select?: WIP_PRODUCTSSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WIP_PRODUCTS
     */
    omit?: WIP_PRODUCTSOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WIP_PRODUCTSInclude<ExtArgs> | null
    /**
     * Filter which WIP_PRODUCTS to delete.
     */
    where: WIP_PRODUCTSWhereUniqueInput
  }

  /**
   * WIP_PRODUCTS deleteMany
   */
  export type WIP_PRODUCTSDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WIP_PRODUCTS to delete
     */
    where?: WIP_PRODUCTSWhereInput
  }

  /**
   * WIP_PRODUCTS without action
   */
  export type WIP_PRODUCTSDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WIP_PRODUCTS
     */
    select?: WIP_PRODUCTSSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WIP_PRODUCTS
     */
    omit?: WIP_PRODUCTSOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WIP_PRODUCTSInclude<ExtArgs> | null
  }


  /**
   * Model WIPRawMaterial
   */

  export type AggregateWIPRawMaterial = {
    _count: WIPRawMaterialCountAggregateOutputType | null
    _avg: WIPRawMaterialAvgAggregateOutputType | null
    _sum: WIPRawMaterialSumAggregateOutputType | null
    _min: WIPRawMaterialMinAggregateOutputType | null
    _max: WIPRawMaterialMaxAggregateOutputType | null
  }

  export type WIPRawMaterialAvgAggregateOutputType = {
    id: number | null
    wipId: number | null
    rawMaterialId: number | null
    quantity: number | null
  }

  export type WIPRawMaterialSumAggregateOutputType = {
    id: number | null
    wipId: number | null
    rawMaterialId: bigint | null
    quantity: number | null
  }

  export type WIPRawMaterialMinAggregateOutputType = {
    id: number | null
    wipId: number | null
    rawMaterialId: bigint | null
    quantity: number | null
  }

  export type WIPRawMaterialMaxAggregateOutputType = {
    id: number | null
    wipId: number | null
    rawMaterialId: bigint | null
    quantity: number | null
  }

  export type WIPRawMaterialCountAggregateOutputType = {
    id: number
    wipId: number
    rawMaterialId: number
    quantity: number
    _all: number
  }


  export type WIPRawMaterialAvgAggregateInputType = {
    id?: true
    wipId?: true
    rawMaterialId?: true
    quantity?: true
  }

  export type WIPRawMaterialSumAggregateInputType = {
    id?: true
    wipId?: true
    rawMaterialId?: true
    quantity?: true
  }

  export type WIPRawMaterialMinAggregateInputType = {
    id?: true
    wipId?: true
    rawMaterialId?: true
    quantity?: true
  }

  export type WIPRawMaterialMaxAggregateInputType = {
    id?: true
    wipId?: true
    rawMaterialId?: true
    quantity?: true
  }

  export type WIPRawMaterialCountAggregateInputType = {
    id?: true
    wipId?: true
    rawMaterialId?: true
    quantity?: true
    _all?: true
  }

  export type WIPRawMaterialAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WIPRawMaterial to aggregate.
     */
    where?: WIPRawMaterialWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WIPRawMaterials to fetch.
     */
    orderBy?: WIPRawMaterialOrderByWithRelationInput | WIPRawMaterialOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WIPRawMaterialWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WIPRawMaterials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WIPRawMaterials.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned WIPRawMaterials
    **/
    _count?: true | WIPRawMaterialCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: WIPRawMaterialAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: WIPRawMaterialSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WIPRawMaterialMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WIPRawMaterialMaxAggregateInputType
  }

  export type GetWIPRawMaterialAggregateType<T extends WIPRawMaterialAggregateArgs> = {
        [P in keyof T & keyof AggregateWIPRawMaterial]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWIPRawMaterial[P]>
      : GetScalarType<T[P], AggregateWIPRawMaterial[P]>
  }




  export type WIPRawMaterialGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WIPRawMaterialWhereInput
    orderBy?: WIPRawMaterialOrderByWithAggregationInput | WIPRawMaterialOrderByWithAggregationInput[]
    by: WIPRawMaterialScalarFieldEnum[] | WIPRawMaterialScalarFieldEnum
    having?: WIPRawMaterialScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WIPRawMaterialCountAggregateInputType | true
    _avg?: WIPRawMaterialAvgAggregateInputType
    _sum?: WIPRawMaterialSumAggregateInputType
    _min?: WIPRawMaterialMinAggregateInputType
    _max?: WIPRawMaterialMaxAggregateInputType
  }

  export type WIPRawMaterialGroupByOutputType = {
    id: number
    wipId: number
    rawMaterialId: bigint
    quantity: number
    _count: WIPRawMaterialCountAggregateOutputType | null
    _avg: WIPRawMaterialAvgAggregateOutputType | null
    _sum: WIPRawMaterialSumAggregateOutputType | null
    _min: WIPRawMaterialMinAggregateOutputType | null
    _max: WIPRawMaterialMaxAggregateOutputType | null
  }

  type GetWIPRawMaterialGroupByPayload<T extends WIPRawMaterialGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WIPRawMaterialGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WIPRawMaterialGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WIPRawMaterialGroupByOutputType[P]>
            : GetScalarType<T[P], WIPRawMaterialGroupByOutputType[P]>
        }
      >
    >


  export type WIPRawMaterialSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    wipId?: boolean
    rawMaterialId?: boolean
    quantity?: boolean
    wip?: boolean | WIPDefaultArgs<ExtArgs>
    rawMaterial?: boolean | RAW_MATERIALSDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["wIPRawMaterial"]>



  export type WIPRawMaterialSelectScalar = {
    id?: boolean
    wipId?: boolean
    rawMaterialId?: boolean
    quantity?: boolean
  }

  export type WIPRawMaterialOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "wipId" | "rawMaterialId" | "quantity", ExtArgs["result"]["wIPRawMaterial"]>
  export type WIPRawMaterialInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    wip?: boolean | WIPDefaultArgs<ExtArgs>
    rawMaterial?: boolean | RAW_MATERIALSDefaultArgs<ExtArgs>
  }

  export type $WIPRawMaterialPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "WIPRawMaterial"
    objects: {
      wip: Prisma.$WIPPayload<ExtArgs>
      rawMaterial: Prisma.$RAW_MATERIALSPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      wipId: number
      rawMaterialId: bigint
      quantity: number
    }, ExtArgs["result"]["wIPRawMaterial"]>
    composites: {}
  }

  type WIPRawMaterialGetPayload<S extends boolean | null | undefined | WIPRawMaterialDefaultArgs> = $Result.GetResult<Prisma.$WIPRawMaterialPayload, S>

  type WIPRawMaterialCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<WIPRawMaterialFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: WIPRawMaterialCountAggregateInputType | true
    }

  export interface WIPRawMaterialDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['WIPRawMaterial'], meta: { name: 'WIPRawMaterial' } }
    /**
     * Find zero or one WIPRawMaterial that matches the filter.
     * @param {WIPRawMaterialFindUniqueArgs} args - Arguments to find a WIPRawMaterial
     * @example
     * // Get one WIPRawMaterial
     * const wIPRawMaterial = await prisma.wIPRawMaterial.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WIPRawMaterialFindUniqueArgs>(args: SelectSubset<T, WIPRawMaterialFindUniqueArgs<ExtArgs>>): Prisma__WIPRawMaterialClient<$Result.GetResult<Prisma.$WIPRawMaterialPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one WIPRawMaterial that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {WIPRawMaterialFindUniqueOrThrowArgs} args - Arguments to find a WIPRawMaterial
     * @example
     * // Get one WIPRawMaterial
     * const wIPRawMaterial = await prisma.wIPRawMaterial.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WIPRawMaterialFindUniqueOrThrowArgs>(args: SelectSubset<T, WIPRawMaterialFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WIPRawMaterialClient<$Result.GetResult<Prisma.$WIPRawMaterialPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first WIPRawMaterial that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WIPRawMaterialFindFirstArgs} args - Arguments to find a WIPRawMaterial
     * @example
     * // Get one WIPRawMaterial
     * const wIPRawMaterial = await prisma.wIPRawMaterial.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WIPRawMaterialFindFirstArgs>(args?: SelectSubset<T, WIPRawMaterialFindFirstArgs<ExtArgs>>): Prisma__WIPRawMaterialClient<$Result.GetResult<Prisma.$WIPRawMaterialPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first WIPRawMaterial that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WIPRawMaterialFindFirstOrThrowArgs} args - Arguments to find a WIPRawMaterial
     * @example
     * // Get one WIPRawMaterial
     * const wIPRawMaterial = await prisma.wIPRawMaterial.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WIPRawMaterialFindFirstOrThrowArgs>(args?: SelectSubset<T, WIPRawMaterialFindFirstOrThrowArgs<ExtArgs>>): Prisma__WIPRawMaterialClient<$Result.GetResult<Prisma.$WIPRawMaterialPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more WIPRawMaterials that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WIPRawMaterialFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all WIPRawMaterials
     * const wIPRawMaterials = await prisma.wIPRawMaterial.findMany()
     * 
     * // Get first 10 WIPRawMaterials
     * const wIPRawMaterials = await prisma.wIPRawMaterial.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const wIPRawMaterialWithIdOnly = await prisma.wIPRawMaterial.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends WIPRawMaterialFindManyArgs>(args?: SelectSubset<T, WIPRawMaterialFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WIPRawMaterialPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a WIPRawMaterial.
     * @param {WIPRawMaterialCreateArgs} args - Arguments to create a WIPRawMaterial.
     * @example
     * // Create one WIPRawMaterial
     * const WIPRawMaterial = await prisma.wIPRawMaterial.create({
     *   data: {
     *     // ... data to create a WIPRawMaterial
     *   }
     * })
     * 
     */
    create<T extends WIPRawMaterialCreateArgs>(args: SelectSubset<T, WIPRawMaterialCreateArgs<ExtArgs>>): Prisma__WIPRawMaterialClient<$Result.GetResult<Prisma.$WIPRawMaterialPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many WIPRawMaterials.
     * @param {WIPRawMaterialCreateManyArgs} args - Arguments to create many WIPRawMaterials.
     * @example
     * // Create many WIPRawMaterials
     * const wIPRawMaterial = await prisma.wIPRawMaterial.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WIPRawMaterialCreateManyArgs>(args?: SelectSubset<T, WIPRawMaterialCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a WIPRawMaterial.
     * @param {WIPRawMaterialDeleteArgs} args - Arguments to delete one WIPRawMaterial.
     * @example
     * // Delete one WIPRawMaterial
     * const WIPRawMaterial = await prisma.wIPRawMaterial.delete({
     *   where: {
     *     // ... filter to delete one WIPRawMaterial
     *   }
     * })
     * 
     */
    delete<T extends WIPRawMaterialDeleteArgs>(args: SelectSubset<T, WIPRawMaterialDeleteArgs<ExtArgs>>): Prisma__WIPRawMaterialClient<$Result.GetResult<Prisma.$WIPRawMaterialPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one WIPRawMaterial.
     * @param {WIPRawMaterialUpdateArgs} args - Arguments to update one WIPRawMaterial.
     * @example
     * // Update one WIPRawMaterial
     * const wIPRawMaterial = await prisma.wIPRawMaterial.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WIPRawMaterialUpdateArgs>(args: SelectSubset<T, WIPRawMaterialUpdateArgs<ExtArgs>>): Prisma__WIPRawMaterialClient<$Result.GetResult<Prisma.$WIPRawMaterialPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more WIPRawMaterials.
     * @param {WIPRawMaterialDeleteManyArgs} args - Arguments to filter WIPRawMaterials to delete.
     * @example
     * // Delete a few WIPRawMaterials
     * const { count } = await prisma.wIPRawMaterial.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WIPRawMaterialDeleteManyArgs>(args?: SelectSubset<T, WIPRawMaterialDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WIPRawMaterials.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WIPRawMaterialUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many WIPRawMaterials
     * const wIPRawMaterial = await prisma.wIPRawMaterial.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WIPRawMaterialUpdateManyArgs>(args: SelectSubset<T, WIPRawMaterialUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one WIPRawMaterial.
     * @param {WIPRawMaterialUpsertArgs} args - Arguments to update or create a WIPRawMaterial.
     * @example
     * // Update or create a WIPRawMaterial
     * const wIPRawMaterial = await prisma.wIPRawMaterial.upsert({
     *   create: {
     *     // ... data to create a WIPRawMaterial
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the WIPRawMaterial we want to update
     *   }
     * })
     */
    upsert<T extends WIPRawMaterialUpsertArgs>(args: SelectSubset<T, WIPRawMaterialUpsertArgs<ExtArgs>>): Prisma__WIPRawMaterialClient<$Result.GetResult<Prisma.$WIPRawMaterialPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of WIPRawMaterials.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WIPRawMaterialCountArgs} args - Arguments to filter WIPRawMaterials to count.
     * @example
     * // Count the number of WIPRawMaterials
     * const count = await prisma.wIPRawMaterial.count({
     *   where: {
     *     // ... the filter for the WIPRawMaterials we want to count
     *   }
     * })
    **/
    count<T extends WIPRawMaterialCountArgs>(
      args?: Subset<T, WIPRawMaterialCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WIPRawMaterialCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a WIPRawMaterial.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WIPRawMaterialAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WIPRawMaterialAggregateArgs>(args: Subset<T, WIPRawMaterialAggregateArgs>): Prisma.PrismaPromise<GetWIPRawMaterialAggregateType<T>>

    /**
     * Group by WIPRawMaterial.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WIPRawMaterialGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WIPRawMaterialGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WIPRawMaterialGroupByArgs['orderBy'] }
        : { orderBy?: WIPRawMaterialGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WIPRawMaterialGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWIPRawMaterialGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the WIPRawMaterial model
   */
  readonly fields: WIPRawMaterialFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for WIPRawMaterial.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WIPRawMaterialClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    wip<T extends WIPDefaultArgs<ExtArgs> = {}>(args?: Subset<T, WIPDefaultArgs<ExtArgs>>): Prisma__WIPClient<$Result.GetResult<Prisma.$WIPPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    rawMaterial<T extends RAW_MATERIALSDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RAW_MATERIALSDefaultArgs<ExtArgs>>): Prisma__RAW_MATERIALSClient<$Result.GetResult<Prisma.$RAW_MATERIALSPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the WIPRawMaterial model
   */ 
  interface WIPRawMaterialFieldRefs {
    readonly id: FieldRef<"WIPRawMaterial", 'Int'>
    readonly wipId: FieldRef<"WIPRawMaterial", 'Int'>
    readonly rawMaterialId: FieldRef<"WIPRawMaterial", 'BigInt'>
    readonly quantity: FieldRef<"WIPRawMaterial", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * WIPRawMaterial findUnique
   */
  export type WIPRawMaterialFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WIPRawMaterial
     */
    select?: WIPRawMaterialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WIPRawMaterial
     */
    omit?: WIPRawMaterialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WIPRawMaterialInclude<ExtArgs> | null
    /**
     * Filter, which WIPRawMaterial to fetch.
     */
    where: WIPRawMaterialWhereUniqueInput
  }

  /**
   * WIPRawMaterial findUniqueOrThrow
   */
  export type WIPRawMaterialFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WIPRawMaterial
     */
    select?: WIPRawMaterialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WIPRawMaterial
     */
    omit?: WIPRawMaterialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WIPRawMaterialInclude<ExtArgs> | null
    /**
     * Filter, which WIPRawMaterial to fetch.
     */
    where: WIPRawMaterialWhereUniqueInput
  }

  /**
   * WIPRawMaterial findFirst
   */
  export type WIPRawMaterialFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WIPRawMaterial
     */
    select?: WIPRawMaterialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WIPRawMaterial
     */
    omit?: WIPRawMaterialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WIPRawMaterialInclude<ExtArgs> | null
    /**
     * Filter, which WIPRawMaterial to fetch.
     */
    where?: WIPRawMaterialWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WIPRawMaterials to fetch.
     */
    orderBy?: WIPRawMaterialOrderByWithRelationInput | WIPRawMaterialOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WIPRawMaterials.
     */
    cursor?: WIPRawMaterialWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WIPRawMaterials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WIPRawMaterials.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WIPRawMaterials.
     */
    distinct?: WIPRawMaterialScalarFieldEnum | WIPRawMaterialScalarFieldEnum[]
  }

  /**
   * WIPRawMaterial findFirstOrThrow
   */
  export type WIPRawMaterialFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WIPRawMaterial
     */
    select?: WIPRawMaterialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WIPRawMaterial
     */
    omit?: WIPRawMaterialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WIPRawMaterialInclude<ExtArgs> | null
    /**
     * Filter, which WIPRawMaterial to fetch.
     */
    where?: WIPRawMaterialWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WIPRawMaterials to fetch.
     */
    orderBy?: WIPRawMaterialOrderByWithRelationInput | WIPRawMaterialOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WIPRawMaterials.
     */
    cursor?: WIPRawMaterialWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WIPRawMaterials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WIPRawMaterials.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WIPRawMaterials.
     */
    distinct?: WIPRawMaterialScalarFieldEnum | WIPRawMaterialScalarFieldEnum[]
  }

  /**
   * WIPRawMaterial findMany
   */
  export type WIPRawMaterialFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WIPRawMaterial
     */
    select?: WIPRawMaterialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WIPRawMaterial
     */
    omit?: WIPRawMaterialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WIPRawMaterialInclude<ExtArgs> | null
    /**
     * Filter, which WIPRawMaterials to fetch.
     */
    where?: WIPRawMaterialWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WIPRawMaterials to fetch.
     */
    orderBy?: WIPRawMaterialOrderByWithRelationInput | WIPRawMaterialOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing WIPRawMaterials.
     */
    cursor?: WIPRawMaterialWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WIPRawMaterials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WIPRawMaterials.
     */
    skip?: number
    distinct?: WIPRawMaterialScalarFieldEnum | WIPRawMaterialScalarFieldEnum[]
  }

  /**
   * WIPRawMaterial create
   */
  export type WIPRawMaterialCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WIPRawMaterial
     */
    select?: WIPRawMaterialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WIPRawMaterial
     */
    omit?: WIPRawMaterialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WIPRawMaterialInclude<ExtArgs> | null
    /**
     * The data needed to create a WIPRawMaterial.
     */
    data: XOR<WIPRawMaterialCreateInput, WIPRawMaterialUncheckedCreateInput>
  }

  /**
   * WIPRawMaterial createMany
   */
  export type WIPRawMaterialCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many WIPRawMaterials.
     */
    data: WIPRawMaterialCreateManyInput | WIPRawMaterialCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * WIPRawMaterial update
   */
  export type WIPRawMaterialUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WIPRawMaterial
     */
    select?: WIPRawMaterialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WIPRawMaterial
     */
    omit?: WIPRawMaterialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WIPRawMaterialInclude<ExtArgs> | null
    /**
     * The data needed to update a WIPRawMaterial.
     */
    data: XOR<WIPRawMaterialUpdateInput, WIPRawMaterialUncheckedUpdateInput>
    /**
     * Choose, which WIPRawMaterial to update.
     */
    where: WIPRawMaterialWhereUniqueInput
  }

  /**
   * WIPRawMaterial updateMany
   */
  export type WIPRawMaterialUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update WIPRawMaterials.
     */
    data: XOR<WIPRawMaterialUpdateManyMutationInput, WIPRawMaterialUncheckedUpdateManyInput>
    /**
     * Filter which WIPRawMaterials to update
     */
    where?: WIPRawMaterialWhereInput
  }

  /**
   * WIPRawMaterial upsert
   */
  export type WIPRawMaterialUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WIPRawMaterial
     */
    select?: WIPRawMaterialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WIPRawMaterial
     */
    omit?: WIPRawMaterialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WIPRawMaterialInclude<ExtArgs> | null
    /**
     * The filter to search for the WIPRawMaterial to update in case it exists.
     */
    where: WIPRawMaterialWhereUniqueInput
    /**
     * In case the WIPRawMaterial found by the `where` argument doesn't exist, create a new WIPRawMaterial with this data.
     */
    create: XOR<WIPRawMaterialCreateInput, WIPRawMaterialUncheckedCreateInput>
    /**
     * In case the WIPRawMaterial was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WIPRawMaterialUpdateInput, WIPRawMaterialUncheckedUpdateInput>
  }

  /**
   * WIPRawMaterial delete
   */
  export type WIPRawMaterialDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WIPRawMaterial
     */
    select?: WIPRawMaterialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WIPRawMaterial
     */
    omit?: WIPRawMaterialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WIPRawMaterialInclude<ExtArgs> | null
    /**
     * Filter which WIPRawMaterial to delete.
     */
    where: WIPRawMaterialWhereUniqueInput
  }

  /**
   * WIPRawMaterial deleteMany
   */
  export type WIPRawMaterialDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WIPRawMaterials to delete
     */
    where?: WIPRawMaterialWhereInput
  }

  /**
   * WIPRawMaterial without action
   */
  export type WIPRawMaterialDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WIPRawMaterial
     */
    select?: WIPRawMaterialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WIPRawMaterial
     */
    omit?: WIPRawMaterialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WIPRawMaterialInclude<ExtArgs> | null
  }


  /**
   * Model FG
   */

  export type AggregateFG = {
    _count: FGCountAggregateOutputType | null
    _avg: FGAvgAggregateOutputType | null
    _sum: FGSumAggregateOutputType | null
    _min: FGMinAggregateOutputType | null
    _max: FGMaxAggregateOutputType | null
  }

  export type FGAvgAggregateOutputType = {
    id: number | null
    orderId: number | null
    price: Decimal | null
  }

  export type FGSumAggregateOutputType = {
    id: number | null
    orderId: number | null
    price: Decimal | null
  }

  export type FGMinAggregateOutputType = {
    id: number | null
    orderId: number | null
    customerName: string | null
    price: Decimal | null
    status: $Enums.Status | null
    createdAt: Date | null
    deliveryDate: Date | null
  }

  export type FGMaxAggregateOutputType = {
    id: number | null
    orderId: number | null
    customerName: string | null
    price: Decimal | null
    status: $Enums.Status | null
    createdAt: Date | null
    deliveryDate: Date | null
  }

  export type FGCountAggregateOutputType = {
    id: number
    orderId: number
    customerName: number
    price: number
    status: number
    createdAt: number
    deliveryDate: number
    _all: number
  }


  export type FGAvgAggregateInputType = {
    id?: true
    orderId?: true
    price?: true
  }

  export type FGSumAggregateInputType = {
    id?: true
    orderId?: true
    price?: true
  }

  export type FGMinAggregateInputType = {
    id?: true
    orderId?: true
    customerName?: true
    price?: true
    status?: true
    createdAt?: true
    deliveryDate?: true
  }

  export type FGMaxAggregateInputType = {
    id?: true
    orderId?: true
    customerName?: true
    price?: true
    status?: true
    createdAt?: true
    deliveryDate?: true
  }

  export type FGCountAggregateInputType = {
    id?: true
    orderId?: true
    customerName?: true
    price?: true
    status?: true
    createdAt?: true
    deliveryDate?: true
    _all?: true
  }

  export type FGAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FG to aggregate.
     */
    where?: FGWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FGS to fetch.
     */
    orderBy?: FGOrderByWithRelationInput | FGOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FGWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FGS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FGS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FGS
    **/
    _count?: true | FGCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FGAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FGSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FGMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FGMaxAggregateInputType
  }

  export type GetFGAggregateType<T extends FGAggregateArgs> = {
        [P in keyof T & keyof AggregateFG]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFG[P]>
      : GetScalarType<T[P], AggregateFG[P]>
  }




  export type FGGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FGWhereInput
    orderBy?: FGOrderByWithAggregationInput | FGOrderByWithAggregationInput[]
    by: FGScalarFieldEnum[] | FGScalarFieldEnum
    having?: FGScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FGCountAggregateInputType | true
    _avg?: FGAvgAggregateInputType
    _sum?: FGSumAggregateInputType
    _min?: FGMinAggregateInputType
    _max?: FGMaxAggregateInputType
  }

  export type FGGroupByOutputType = {
    id: number
    orderId: number
    customerName: string
    price: Decimal
    status: $Enums.Status
    createdAt: Date
    deliveryDate: Date
    _count: FGCountAggregateOutputType | null
    _avg: FGAvgAggregateOutputType | null
    _sum: FGSumAggregateOutputType | null
    _min: FGMinAggregateOutputType | null
    _max: FGMaxAggregateOutputType | null
  }

  type GetFGGroupByPayload<T extends FGGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FGGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FGGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FGGroupByOutputType[P]>
            : GetScalarType<T[P], FGGroupByOutputType[P]>
        }
      >
    >


  export type FGSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orderId?: boolean
    customerName?: boolean
    price?: boolean
    status?: boolean
    createdAt?: boolean
    deliveryDate?: boolean
    FGTransactions?: boolean | FG$FGTransactionsArgs<ExtArgs>
    FGQCs?: boolean | FG$FGQCsArgs<ExtArgs>
    FGWastageLogs?: boolean | FG$FGWastageLogsArgs<ExtArgs>
    fgProducts?: boolean | FG$fgProductsArgs<ExtArgs>
    _count?: boolean | FGCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["fG"]>



  export type FGSelectScalar = {
    id?: boolean
    orderId?: boolean
    customerName?: boolean
    price?: boolean
    status?: boolean
    createdAt?: boolean
    deliveryDate?: boolean
  }

  export type FGOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "orderId" | "customerName" | "price" | "status" | "createdAt" | "deliveryDate", ExtArgs["result"]["fG"]>
  export type FGInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    FGTransactions?: boolean | FG$FGTransactionsArgs<ExtArgs>
    FGQCs?: boolean | FG$FGQCsArgs<ExtArgs>
    FGWastageLogs?: boolean | FG$FGWastageLogsArgs<ExtArgs>
    fgProducts?: boolean | FG$fgProductsArgs<ExtArgs>
    _count?: boolean | FGCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $FGPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "FG"
    objects: {
      FGTransactions: Prisma.$FG_TRANSACTIONSPayload<ExtArgs>[]
      FGQCs: Prisma.$FG_QCPayload<ExtArgs>[]
      FGWastageLogs: Prisma.$FG_WASTAGE_LOGSPayload<ExtArgs>[]
      fgProducts: Prisma.$FG_PRODUCTSPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      orderId: number
      customerName: string
      price: Prisma.Decimal
      status: $Enums.Status
      createdAt: Date
      deliveryDate: Date
    }, ExtArgs["result"]["fG"]>
    composites: {}
  }

  type FGGetPayload<S extends boolean | null | undefined | FGDefaultArgs> = $Result.GetResult<Prisma.$FGPayload, S>

  type FGCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<FGFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FGCountAggregateInputType | true
    }

  export interface FGDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['FG'], meta: { name: 'FG' } }
    /**
     * Find zero or one FG that matches the filter.
     * @param {FGFindUniqueArgs} args - Arguments to find a FG
     * @example
     * // Get one FG
     * const fG = await prisma.fG.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FGFindUniqueArgs>(args: SelectSubset<T, FGFindUniqueArgs<ExtArgs>>): Prisma__FGClient<$Result.GetResult<Prisma.$FGPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one FG that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FGFindUniqueOrThrowArgs} args - Arguments to find a FG
     * @example
     * // Get one FG
     * const fG = await prisma.fG.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FGFindUniqueOrThrowArgs>(args: SelectSubset<T, FGFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FGClient<$Result.GetResult<Prisma.$FGPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first FG that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FGFindFirstArgs} args - Arguments to find a FG
     * @example
     * // Get one FG
     * const fG = await prisma.fG.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FGFindFirstArgs>(args?: SelectSubset<T, FGFindFirstArgs<ExtArgs>>): Prisma__FGClient<$Result.GetResult<Prisma.$FGPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first FG that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FGFindFirstOrThrowArgs} args - Arguments to find a FG
     * @example
     * // Get one FG
     * const fG = await prisma.fG.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FGFindFirstOrThrowArgs>(args?: SelectSubset<T, FGFindFirstOrThrowArgs<ExtArgs>>): Prisma__FGClient<$Result.GetResult<Prisma.$FGPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more FGS that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FGFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FGS
     * const fGS = await prisma.fG.findMany()
     * 
     * // Get first 10 FGS
     * const fGS = await prisma.fG.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const fGWithIdOnly = await prisma.fG.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FGFindManyArgs>(args?: SelectSubset<T, FGFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FGPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a FG.
     * @param {FGCreateArgs} args - Arguments to create a FG.
     * @example
     * // Create one FG
     * const FG = await prisma.fG.create({
     *   data: {
     *     // ... data to create a FG
     *   }
     * })
     * 
     */
    create<T extends FGCreateArgs>(args: SelectSubset<T, FGCreateArgs<ExtArgs>>): Prisma__FGClient<$Result.GetResult<Prisma.$FGPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many FGS.
     * @param {FGCreateManyArgs} args - Arguments to create many FGS.
     * @example
     * // Create many FGS
     * const fG = await prisma.fG.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FGCreateManyArgs>(args?: SelectSubset<T, FGCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a FG.
     * @param {FGDeleteArgs} args - Arguments to delete one FG.
     * @example
     * // Delete one FG
     * const FG = await prisma.fG.delete({
     *   where: {
     *     // ... filter to delete one FG
     *   }
     * })
     * 
     */
    delete<T extends FGDeleteArgs>(args: SelectSubset<T, FGDeleteArgs<ExtArgs>>): Prisma__FGClient<$Result.GetResult<Prisma.$FGPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one FG.
     * @param {FGUpdateArgs} args - Arguments to update one FG.
     * @example
     * // Update one FG
     * const fG = await prisma.fG.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FGUpdateArgs>(args: SelectSubset<T, FGUpdateArgs<ExtArgs>>): Prisma__FGClient<$Result.GetResult<Prisma.$FGPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more FGS.
     * @param {FGDeleteManyArgs} args - Arguments to filter FGS to delete.
     * @example
     * // Delete a few FGS
     * const { count } = await prisma.fG.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FGDeleteManyArgs>(args?: SelectSubset<T, FGDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FGS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FGUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FGS
     * const fG = await prisma.fG.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FGUpdateManyArgs>(args: SelectSubset<T, FGUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one FG.
     * @param {FGUpsertArgs} args - Arguments to update or create a FG.
     * @example
     * // Update or create a FG
     * const fG = await prisma.fG.upsert({
     *   create: {
     *     // ... data to create a FG
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FG we want to update
     *   }
     * })
     */
    upsert<T extends FGUpsertArgs>(args: SelectSubset<T, FGUpsertArgs<ExtArgs>>): Prisma__FGClient<$Result.GetResult<Prisma.$FGPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of FGS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FGCountArgs} args - Arguments to filter FGS to count.
     * @example
     * // Count the number of FGS
     * const count = await prisma.fG.count({
     *   where: {
     *     // ... the filter for the FGS we want to count
     *   }
     * })
    **/
    count<T extends FGCountArgs>(
      args?: Subset<T, FGCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FGCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FG.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FGAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FGAggregateArgs>(args: Subset<T, FGAggregateArgs>): Prisma.PrismaPromise<GetFGAggregateType<T>>

    /**
     * Group by FG.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FGGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FGGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FGGroupByArgs['orderBy'] }
        : { orderBy?: FGGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FGGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFGGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the FG model
   */
  readonly fields: FGFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for FG.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FGClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    FGTransactions<T extends FG$FGTransactionsArgs<ExtArgs> = {}>(args?: Subset<T, FG$FGTransactionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FG_TRANSACTIONSPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    FGQCs<T extends FG$FGQCsArgs<ExtArgs> = {}>(args?: Subset<T, FG$FGQCsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FG_QCPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    FGWastageLogs<T extends FG$FGWastageLogsArgs<ExtArgs> = {}>(args?: Subset<T, FG$FGWastageLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FG_WASTAGE_LOGSPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    fgProducts<T extends FG$fgProductsArgs<ExtArgs> = {}>(args?: Subset<T, FG$fgProductsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FG_PRODUCTSPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the FG model
   */ 
  interface FGFieldRefs {
    readonly id: FieldRef<"FG", 'Int'>
    readonly orderId: FieldRef<"FG", 'Int'>
    readonly customerName: FieldRef<"FG", 'String'>
    readonly price: FieldRef<"FG", 'Decimal'>
    readonly status: FieldRef<"FG", 'Status'>
    readonly createdAt: FieldRef<"FG", 'DateTime'>
    readonly deliveryDate: FieldRef<"FG", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * FG findUnique
   */
  export type FGFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FG
     */
    select?: FGSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FG
     */
    omit?: FGOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FGInclude<ExtArgs> | null
    /**
     * Filter, which FG to fetch.
     */
    where: FGWhereUniqueInput
  }

  /**
   * FG findUniqueOrThrow
   */
  export type FGFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FG
     */
    select?: FGSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FG
     */
    omit?: FGOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FGInclude<ExtArgs> | null
    /**
     * Filter, which FG to fetch.
     */
    where: FGWhereUniqueInput
  }

  /**
   * FG findFirst
   */
  export type FGFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FG
     */
    select?: FGSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FG
     */
    omit?: FGOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FGInclude<ExtArgs> | null
    /**
     * Filter, which FG to fetch.
     */
    where?: FGWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FGS to fetch.
     */
    orderBy?: FGOrderByWithRelationInput | FGOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FGS.
     */
    cursor?: FGWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FGS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FGS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FGS.
     */
    distinct?: FGScalarFieldEnum | FGScalarFieldEnum[]
  }

  /**
   * FG findFirstOrThrow
   */
  export type FGFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FG
     */
    select?: FGSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FG
     */
    omit?: FGOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FGInclude<ExtArgs> | null
    /**
     * Filter, which FG to fetch.
     */
    where?: FGWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FGS to fetch.
     */
    orderBy?: FGOrderByWithRelationInput | FGOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FGS.
     */
    cursor?: FGWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FGS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FGS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FGS.
     */
    distinct?: FGScalarFieldEnum | FGScalarFieldEnum[]
  }

  /**
   * FG findMany
   */
  export type FGFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FG
     */
    select?: FGSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FG
     */
    omit?: FGOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FGInclude<ExtArgs> | null
    /**
     * Filter, which FGS to fetch.
     */
    where?: FGWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FGS to fetch.
     */
    orderBy?: FGOrderByWithRelationInput | FGOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FGS.
     */
    cursor?: FGWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FGS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FGS.
     */
    skip?: number
    distinct?: FGScalarFieldEnum | FGScalarFieldEnum[]
  }

  /**
   * FG create
   */
  export type FGCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FG
     */
    select?: FGSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FG
     */
    omit?: FGOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FGInclude<ExtArgs> | null
    /**
     * The data needed to create a FG.
     */
    data: XOR<FGCreateInput, FGUncheckedCreateInput>
  }

  /**
   * FG createMany
   */
  export type FGCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many FGS.
     */
    data: FGCreateManyInput | FGCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * FG update
   */
  export type FGUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FG
     */
    select?: FGSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FG
     */
    omit?: FGOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FGInclude<ExtArgs> | null
    /**
     * The data needed to update a FG.
     */
    data: XOR<FGUpdateInput, FGUncheckedUpdateInput>
    /**
     * Choose, which FG to update.
     */
    where: FGWhereUniqueInput
  }

  /**
   * FG updateMany
   */
  export type FGUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update FGS.
     */
    data: XOR<FGUpdateManyMutationInput, FGUncheckedUpdateManyInput>
    /**
     * Filter which FGS to update
     */
    where?: FGWhereInput
  }

  /**
   * FG upsert
   */
  export type FGUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FG
     */
    select?: FGSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FG
     */
    omit?: FGOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FGInclude<ExtArgs> | null
    /**
     * The filter to search for the FG to update in case it exists.
     */
    where: FGWhereUniqueInput
    /**
     * In case the FG found by the `where` argument doesn't exist, create a new FG with this data.
     */
    create: XOR<FGCreateInput, FGUncheckedCreateInput>
    /**
     * In case the FG was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FGUpdateInput, FGUncheckedUpdateInput>
  }

  /**
   * FG delete
   */
  export type FGDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FG
     */
    select?: FGSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FG
     */
    omit?: FGOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FGInclude<ExtArgs> | null
    /**
     * Filter which FG to delete.
     */
    where: FGWhereUniqueInput
  }

  /**
   * FG deleteMany
   */
  export type FGDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FGS to delete
     */
    where?: FGWhereInput
  }

  /**
   * FG.FGTransactions
   */
  export type FG$FGTransactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FG_TRANSACTIONS
     */
    select?: FG_TRANSACTIONSSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FG_TRANSACTIONS
     */
    omit?: FG_TRANSACTIONSOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FG_TRANSACTIONSInclude<ExtArgs> | null
    where?: FG_TRANSACTIONSWhereInput
    orderBy?: FG_TRANSACTIONSOrderByWithRelationInput | FG_TRANSACTIONSOrderByWithRelationInput[]
    cursor?: FG_TRANSACTIONSWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FG_TRANSACTIONSScalarFieldEnum | FG_TRANSACTIONSScalarFieldEnum[]
  }

  /**
   * FG.FGQCs
   */
  export type FG$FGQCsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FG_QC
     */
    select?: FG_QCSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FG_QC
     */
    omit?: FG_QCOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FG_QCInclude<ExtArgs> | null
    where?: FG_QCWhereInput
    orderBy?: FG_QCOrderByWithRelationInput | FG_QCOrderByWithRelationInput[]
    cursor?: FG_QCWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FG_QCScalarFieldEnum | FG_QCScalarFieldEnum[]
  }

  /**
   * FG.FGWastageLogs
   */
  export type FG$FGWastageLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FG_WASTAGE_LOGS
     */
    select?: FG_WASTAGE_LOGSSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FG_WASTAGE_LOGS
     */
    omit?: FG_WASTAGE_LOGSOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FG_WASTAGE_LOGSInclude<ExtArgs> | null
    where?: FG_WASTAGE_LOGSWhereInput
    orderBy?: FG_WASTAGE_LOGSOrderByWithRelationInput | FG_WASTAGE_LOGSOrderByWithRelationInput[]
    cursor?: FG_WASTAGE_LOGSWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FG_WASTAGE_LOGSScalarFieldEnum | FG_WASTAGE_LOGSScalarFieldEnum[]
  }

  /**
   * FG.fgProducts
   */
  export type FG$fgProductsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FG_PRODUCTS
     */
    select?: FG_PRODUCTSSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FG_PRODUCTS
     */
    omit?: FG_PRODUCTSOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FG_PRODUCTSInclude<ExtArgs> | null
    where?: FG_PRODUCTSWhereInput
    orderBy?: FG_PRODUCTSOrderByWithRelationInput | FG_PRODUCTSOrderByWithRelationInput[]
    cursor?: FG_PRODUCTSWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FG_PRODUCTSScalarFieldEnum | FG_PRODUCTSScalarFieldEnum[]
  }

  /**
   * FG without action
   */
  export type FGDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FG
     */
    select?: FGSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FG
     */
    omit?: FGOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FGInclude<ExtArgs> | null
  }


  /**
   * Model FG_PRODUCTS
   */

  export type AggregateFG_PRODUCTS = {
    _count: FG_PRODUCTSCountAggregateOutputType | null
    _avg: FG_PRODUCTSAvgAggregateOutputType | null
    _sum: FG_PRODUCTSSumAggregateOutputType | null
    _min: FG_PRODUCTSMinAggregateOutputType | null
    _max: FG_PRODUCTSMaxAggregateOutputType | null
  }

  export type FG_PRODUCTSAvgAggregateOutputType = {
    id: number | null
    fgId: number | null
    productId: number | null
    quantity: number | null
  }

  export type FG_PRODUCTSSumAggregateOutputType = {
    id: number | null
    fgId: number | null
    productId: number | null
    quantity: number | null
  }

  export type FG_PRODUCTSMinAggregateOutputType = {
    id: number | null
    fgId: number | null
    productId: number | null
    quantity: number | null
  }

  export type FG_PRODUCTSMaxAggregateOutputType = {
    id: number | null
    fgId: number | null
    productId: number | null
    quantity: number | null
  }

  export type FG_PRODUCTSCountAggregateOutputType = {
    id: number
    fgId: number
    productId: number
    quantity: number
    _all: number
  }


  export type FG_PRODUCTSAvgAggregateInputType = {
    id?: true
    fgId?: true
    productId?: true
    quantity?: true
  }

  export type FG_PRODUCTSSumAggregateInputType = {
    id?: true
    fgId?: true
    productId?: true
    quantity?: true
  }

  export type FG_PRODUCTSMinAggregateInputType = {
    id?: true
    fgId?: true
    productId?: true
    quantity?: true
  }

  export type FG_PRODUCTSMaxAggregateInputType = {
    id?: true
    fgId?: true
    productId?: true
    quantity?: true
  }

  export type FG_PRODUCTSCountAggregateInputType = {
    id?: true
    fgId?: true
    productId?: true
    quantity?: true
    _all?: true
  }

  export type FG_PRODUCTSAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FG_PRODUCTS to aggregate.
     */
    where?: FG_PRODUCTSWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FG_PRODUCTS to fetch.
     */
    orderBy?: FG_PRODUCTSOrderByWithRelationInput | FG_PRODUCTSOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FG_PRODUCTSWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FG_PRODUCTS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FG_PRODUCTS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FG_PRODUCTS
    **/
    _count?: true | FG_PRODUCTSCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FG_PRODUCTSAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FG_PRODUCTSSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FG_PRODUCTSMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FG_PRODUCTSMaxAggregateInputType
  }

  export type GetFG_PRODUCTSAggregateType<T extends FG_PRODUCTSAggregateArgs> = {
        [P in keyof T & keyof AggregateFG_PRODUCTS]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFG_PRODUCTS[P]>
      : GetScalarType<T[P], AggregateFG_PRODUCTS[P]>
  }




  export type FG_PRODUCTSGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FG_PRODUCTSWhereInput
    orderBy?: FG_PRODUCTSOrderByWithAggregationInput | FG_PRODUCTSOrderByWithAggregationInput[]
    by: FG_PRODUCTSScalarFieldEnum[] | FG_PRODUCTSScalarFieldEnum
    having?: FG_PRODUCTSScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FG_PRODUCTSCountAggregateInputType | true
    _avg?: FG_PRODUCTSAvgAggregateInputType
    _sum?: FG_PRODUCTSSumAggregateInputType
    _min?: FG_PRODUCTSMinAggregateInputType
    _max?: FG_PRODUCTSMaxAggregateInputType
  }

  export type FG_PRODUCTSGroupByOutputType = {
    id: number
    fgId: number
    productId: number
    quantity: number
    _count: FG_PRODUCTSCountAggregateOutputType | null
    _avg: FG_PRODUCTSAvgAggregateOutputType | null
    _sum: FG_PRODUCTSSumAggregateOutputType | null
    _min: FG_PRODUCTSMinAggregateOutputType | null
    _max: FG_PRODUCTSMaxAggregateOutputType | null
  }

  type GetFG_PRODUCTSGroupByPayload<T extends FG_PRODUCTSGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FG_PRODUCTSGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FG_PRODUCTSGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FG_PRODUCTSGroupByOutputType[P]>
            : GetScalarType<T[P], FG_PRODUCTSGroupByOutputType[P]>
        }
      >
    >


  export type FG_PRODUCTSSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    fgId?: boolean
    productId?: boolean
    quantity?: boolean
    fg?: boolean | FGDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["fG_PRODUCTS"]>



  export type FG_PRODUCTSSelectScalar = {
    id?: boolean
    fgId?: boolean
    productId?: boolean
    quantity?: boolean
  }

  export type FG_PRODUCTSOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "fgId" | "productId" | "quantity", ExtArgs["result"]["fG_PRODUCTS"]>
  export type FG_PRODUCTSInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    fg?: boolean | FGDefaultArgs<ExtArgs>
  }

  export type $FG_PRODUCTSPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "FG_PRODUCTS"
    objects: {
      fg: Prisma.$FGPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      fgId: number
      productId: number
      quantity: number
    }, ExtArgs["result"]["fG_PRODUCTS"]>
    composites: {}
  }

  type FG_PRODUCTSGetPayload<S extends boolean | null | undefined | FG_PRODUCTSDefaultArgs> = $Result.GetResult<Prisma.$FG_PRODUCTSPayload, S>

  type FG_PRODUCTSCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<FG_PRODUCTSFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FG_PRODUCTSCountAggregateInputType | true
    }

  export interface FG_PRODUCTSDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['FG_PRODUCTS'], meta: { name: 'FG_PRODUCTS' } }
    /**
     * Find zero or one FG_PRODUCTS that matches the filter.
     * @param {FG_PRODUCTSFindUniqueArgs} args - Arguments to find a FG_PRODUCTS
     * @example
     * // Get one FG_PRODUCTS
     * const fG_PRODUCTS = await prisma.fG_PRODUCTS.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FG_PRODUCTSFindUniqueArgs>(args: SelectSubset<T, FG_PRODUCTSFindUniqueArgs<ExtArgs>>): Prisma__FG_PRODUCTSClient<$Result.GetResult<Prisma.$FG_PRODUCTSPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one FG_PRODUCTS that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FG_PRODUCTSFindUniqueOrThrowArgs} args - Arguments to find a FG_PRODUCTS
     * @example
     * // Get one FG_PRODUCTS
     * const fG_PRODUCTS = await prisma.fG_PRODUCTS.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FG_PRODUCTSFindUniqueOrThrowArgs>(args: SelectSubset<T, FG_PRODUCTSFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FG_PRODUCTSClient<$Result.GetResult<Prisma.$FG_PRODUCTSPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first FG_PRODUCTS that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FG_PRODUCTSFindFirstArgs} args - Arguments to find a FG_PRODUCTS
     * @example
     * // Get one FG_PRODUCTS
     * const fG_PRODUCTS = await prisma.fG_PRODUCTS.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FG_PRODUCTSFindFirstArgs>(args?: SelectSubset<T, FG_PRODUCTSFindFirstArgs<ExtArgs>>): Prisma__FG_PRODUCTSClient<$Result.GetResult<Prisma.$FG_PRODUCTSPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first FG_PRODUCTS that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FG_PRODUCTSFindFirstOrThrowArgs} args - Arguments to find a FG_PRODUCTS
     * @example
     * // Get one FG_PRODUCTS
     * const fG_PRODUCTS = await prisma.fG_PRODUCTS.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FG_PRODUCTSFindFirstOrThrowArgs>(args?: SelectSubset<T, FG_PRODUCTSFindFirstOrThrowArgs<ExtArgs>>): Prisma__FG_PRODUCTSClient<$Result.GetResult<Prisma.$FG_PRODUCTSPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more FG_PRODUCTS that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FG_PRODUCTSFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FG_PRODUCTS
     * const fG_PRODUCTS = await prisma.fG_PRODUCTS.findMany()
     * 
     * // Get first 10 FG_PRODUCTS
     * const fG_PRODUCTS = await prisma.fG_PRODUCTS.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const fG_PRODUCTSWithIdOnly = await prisma.fG_PRODUCTS.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FG_PRODUCTSFindManyArgs>(args?: SelectSubset<T, FG_PRODUCTSFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FG_PRODUCTSPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a FG_PRODUCTS.
     * @param {FG_PRODUCTSCreateArgs} args - Arguments to create a FG_PRODUCTS.
     * @example
     * // Create one FG_PRODUCTS
     * const FG_PRODUCTS = await prisma.fG_PRODUCTS.create({
     *   data: {
     *     // ... data to create a FG_PRODUCTS
     *   }
     * })
     * 
     */
    create<T extends FG_PRODUCTSCreateArgs>(args: SelectSubset<T, FG_PRODUCTSCreateArgs<ExtArgs>>): Prisma__FG_PRODUCTSClient<$Result.GetResult<Prisma.$FG_PRODUCTSPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many FG_PRODUCTS.
     * @param {FG_PRODUCTSCreateManyArgs} args - Arguments to create many FG_PRODUCTS.
     * @example
     * // Create many FG_PRODUCTS
     * const fG_PRODUCTS = await prisma.fG_PRODUCTS.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FG_PRODUCTSCreateManyArgs>(args?: SelectSubset<T, FG_PRODUCTSCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a FG_PRODUCTS.
     * @param {FG_PRODUCTSDeleteArgs} args - Arguments to delete one FG_PRODUCTS.
     * @example
     * // Delete one FG_PRODUCTS
     * const FG_PRODUCTS = await prisma.fG_PRODUCTS.delete({
     *   where: {
     *     // ... filter to delete one FG_PRODUCTS
     *   }
     * })
     * 
     */
    delete<T extends FG_PRODUCTSDeleteArgs>(args: SelectSubset<T, FG_PRODUCTSDeleteArgs<ExtArgs>>): Prisma__FG_PRODUCTSClient<$Result.GetResult<Prisma.$FG_PRODUCTSPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one FG_PRODUCTS.
     * @param {FG_PRODUCTSUpdateArgs} args - Arguments to update one FG_PRODUCTS.
     * @example
     * // Update one FG_PRODUCTS
     * const fG_PRODUCTS = await prisma.fG_PRODUCTS.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FG_PRODUCTSUpdateArgs>(args: SelectSubset<T, FG_PRODUCTSUpdateArgs<ExtArgs>>): Prisma__FG_PRODUCTSClient<$Result.GetResult<Prisma.$FG_PRODUCTSPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more FG_PRODUCTS.
     * @param {FG_PRODUCTSDeleteManyArgs} args - Arguments to filter FG_PRODUCTS to delete.
     * @example
     * // Delete a few FG_PRODUCTS
     * const { count } = await prisma.fG_PRODUCTS.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FG_PRODUCTSDeleteManyArgs>(args?: SelectSubset<T, FG_PRODUCTSDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FG_PRODUCTS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FG_PRODUCTSUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FG_PRODUCTS
     * const fG_PRODUCTS = await prisma.fG_PRODUCTS.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FG_PRODUCTSUpdateManyArgs>(args: SelectSubset<T, FG_PRODUCTSUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one FG_PRODUCTS.
     * @param {FG_PRODUCTSUpsertArgs} args - Arguments to update or create a FG_PRODUCTS.
     * @example
     * // Update or create a FG_PRODUCTS
     * const fG_PRODUCTS = await prisma.fG_PRODUCTS.upsert({
     *   create: {
     *     // ... data to create a FG_PRODUCTS
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FG_PRODUCTS we want to update
     *   }
     * })
     */
    upsert<T extends FG_PRODUCTSUpsertArgs>(args: SelectSubset<T, FG_PRODUCTSUpsertArgs<ExtArgs>>): Prisma__FG_PRODUCTSClient<$Result.GetResult<Prisma.$FG_PRODUCTSPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of FG_PRODUCTS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FG_PRODUCTSCountArgs} args - Arguments to filter FG_PRODUCTS to count.
     * @example
     * // Count the number of FG_PRODUCTS
     * const count = await prisma.fG_PRODUCTS.count({
     *   where: {
     *     // ... the filter for the FG_PRODUCTS we want to count
     *   }
     * })
    **/
    count<T extends FG_PRODUCTSCountArgs>(
      args?: Subset<T, FG_PRODUCTSCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FG_PRODUCTSCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FG_PRODUCTS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FG_PRODUCTSAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FG_PRODUCTSAggregateArgs>(args: Subset<T, FG_PRODUCTSAggregateArgs>): Prisma.PrismaPromise<GetFG_PRODUCTSAggregateType<T>>

    /**
     * Group by FG_PRODUCTS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FG_PRODUCTSGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FG_PRODUCTSGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FG_PRODUCTSGroupByArgs['orderBy'] }
        : { orderBy?: FG_PRODUCTSGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FG_PRODUCTSGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFG_PRODUCTSGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the FG_PRODUCTS model
   */
  readonly fields: FG_PRODUCTSFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for FG_PRODUCTS.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FG_PRODUCTSClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    fg<T extends FGDefaultArgs<ExtArgs> = {}>(args?: Subset<T, FGDefaultArgs<ExtArgs>>): Prisma__FGClient<$Result.GetResult<Prisma.$FGPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the FG_PRODUCTS model
   */ 
  interface FG_PRODUCTSFieldRefs {
    readonly id: FieldRef<"FG_PRODUCTS", 'Int'>
    readonly fgId: FieldRef<"FG_PRODUCTS", 'Int'>
    readonly productId: FieldRef<"FG_PRODUCTS", 'Int'>
    readonly quantity: FieldRef<"FG_PRODUCTS", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * FG_PRODUCTS findUnique
   */
  export type FG_PRODUCTSFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FG_PRODUCTS
     */
    select?: FG_PRODUCTSSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FG_PRODUCTS
     */
    omit?: FG_PRODUCTSOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FG_PRODUCTSInclude<ExtArgs> | null
    /**
     * Filter, which FG_PRODUCTS to fetch.
     */
    where: FG_PRODUCTSWhereUniqueInput
  }

  /**
   * FG_PRODUCTS findUniqueOrThrow
   */
  export type FG_PRODUCTSFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FG_PRODUCTS
     */
    select?: FG_PRODUCTSSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FG_PRODUCTS
     */
    omit?: FG_PRODUCTSOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FG_PRODUCTSInclude<ExtArgs> | null
    /**
     * Filter, which FG_PRODUCTS to fetch.
     */
    where: FG_PRODUCTSWhereUniqueInput
  }

  /**
   * FG_PRODUCTS findFirst
   */
  export type FG_PRODUCTSFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FG_PRODUCTS
     */
    select?: FG_PRODUCTSSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FG_PRODUCTS
     */
    omit?: FG_PRODUCTSOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FG_PRODUCTSInclude<ExtArgs> | null
    /**
     * Filter, which FG_PRODUCTS to fetch.
     */
    where?: FG_PRODUCTSWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FG_PRODUCTS to fetch.
     */
    orderBy?: FG_PRODUCTSOrderByWithRelationInput | FG_PRODUCTSOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FG_PRODUCTS.
     */
    cursor?: FG_PRODUCTSWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FG_PRODUCTS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FG_PRODUCTS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FG_PRODUCTS.
     */
    distinct?: FG_PRODUCTSScalarFieldEnum | FG_PRODUCTSScalarFieldEnum[]
  }

  /**
   * FG_PRODUCTS findFirstOrThrow
   */
  export type FG_PRODUCTSFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FG_PRODUCTS
     */
    select?: FG_PRODUCTSSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FG_PRODUCTS
     */
    omit?: FG_PRODUCTSOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FG_PRODUCTSInclude<ExtArgs> | null
    /**
     * Filter, which FG_PRODUCTS to fetch.
     */
    where?: FG_PRODUCTSWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FG_PRODUCTS to fetch.
     */
    orderBy?: FG_PRODUCTSOrderByWithRelationInput | FG_PRODUCTSOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FG_PRODUCTS.
     */
    cursor?: FG_PRODUCTSWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FG_PRODUCTS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FG_PRODUCTS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FG_PRODUCTS.
     */
    distinct?: FG_PRODUCTSScalarFieldEnum | FG_PRODUCTSScalarFieldEnum[]
  }

  /**
   * FG_PRODUCTS findMany
   */
  export type FG_PRODUCTSFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FG_PRODUCTS
     */
    select?: FG_PRODUCTSSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FG_PRODUCTS
     */
    omit?: FG_PRODUCTSOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FG_PRODUCTSInclude<ExtArgs> | null
    /**
     * Filter, which FG_PRODUCTS to fetch.
     */
    where?: FG_PRODUCTSWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FG_PRODUCTS to fetch.
     */
    orderBy?: FG_PRODUCTSOrderByWithRelationInput | FG_PRODUCTSOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FG_PRODUCTS.
     */
    cursor?: FG_PRODUCTSWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FG_PRODUCTS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FG_PRODUCTS.
     */
    skip?: number
    distinct?: FG_PRODUCTSScalarFieldEnum | FG_PRODUCTSScalarFieldEnum[]
  }

  /**
   * FG_PRODUCTS create
   */
  export type FG_PRODUCTSCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FG_PRODUCTS
     */
    select?: FG_PRODUCTSSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FG_PRODUCTS
     */
    omit?: FG_PRODUCTSOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FG_PRODUCTSInclude<ExtArgs> | null
    /**
     * The data needed to create a FG_PRODUCTS.
     */
    data: XOR<FG_PRODUCTSCreateInput, FG_PRODUCTSUncheckedCreateInput>
  }

  /**
   * FG_PRODUCTS createMany
   */
  export type FG_PRODUCTSCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many FG_PRODUCTS.
     */
    data: FG_PRODUCTSCreateManyInput | FG_PRODUCTSCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * FG_PRODUCTS update
   */
  export type FG_PRODUCTSUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FG_PRODUCTS
     */
    select?: FG_PRODUCTSSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FG_PRODUCTS
     */
    omit?: FG_PRODUCTSOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FG_PRODUCTSInclude<ExtArgs> | null
    /**
     * The data needed to update a FG_PRODUCTS.
     */
    data: XOR<FG_PRODUCTSUpdateInput, FG_PRODUCTSUncheckedUpdateInput>
    /**
     * Choose, which FG_PRODUCTS to update.
     */
    where: FG_PRODUCTSWhereUniqueInput
  }

  /**
   * FG_PRODUCTS updateMany
   */
  export type FG_PRODUCTSUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update FG_PRODUCTS.
     */
    data: XOR<FG_PRODUCTSUpdateManyMutationInput, FG_PRODUCTSUncheckedUpdateManyInput>
    /**
     * Filter which FG_PRODUCTS to update
     */
    where?: FG_PRODUCTSWhereInput
  }

  /**
   * FG_PRODUCTS upsert
   */
  export type FG_PRODUCTSUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FG_PRODUCTS
     */
    select?: FG_PRODUCTSSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FG_PRODUCTS
     */
    omit?: FG_PRODUCTSOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FG_PRODUCTSInclude<ExtArgs> | null
    /**
     * The filter to search for the FG_PRODUCTS to update in case it exists.
     */
    where: FG_PRODUCTSWhereUniqueInput
    /**
     * In case the FG_PRODUCTS found by the `where` argument doesn't exist, create a new FG_PRODUCTS with this data.
     */
    create: XOR<FG_PRODUCTSCreateInput, FG_PRODUCTSUncheckedCreateInput>
    /**
     * In case the FG_PRODUCTS was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FG_PRODUCTSUpdateInput, FG_PRODUCTSUncheckedUpdateInput>
  }

  /**
   * FG_PRODUCTS delete
   */
  export type FG_PRODUCTSDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FG_PRODUCTS
     */
    select?: FG_PRODUCTSSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FG_PRODUCTS
     */
    omit?: FG_PRODUCTSOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FG_PRODUCTSInclude<ExtArgs> | null
    /**
     * Filter which FG_PRODUCTS to delete.
     */
    where: FG_PRODUCTSWhereUniqueInput
  }

  /**
   * FG_PRODUCTS deleteMany
   */
  export type FG_PRODUCTSDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FG_PRODUCTS to delete
     */
    where?: FG_PRODUCTSWhereInput
  }

  /**
   * FG_PRODUCTS without action
   */
  export type FG_PRODUCTSDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FG_PRODUCTS
     */
    select?: FG_PRODUCTSSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FG_PRODUCTS
     */
    omit?: FG_PRODUCTSOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FG_PRODUCTSInclude<ExtArgs> | null
  }


  /**
   * Model WIP_TRANSACTIONS
   */

  export type AggregateWIP_TRANSACTIONS = {
    _count: WIP_TRANSACTIONSCountAggregateOutputType | null
    _avg: WIP_TRANSACTIONSAvgAggregateOutputType | null
    _sum: WIP_TRANSACTIONSSumAggregateOutputType | null
    _min: WIP_TRANSACTIONSMinAggregateOutputType | null
    _max: WIP_TRANSACTIONSMaxAggregateOutputType | null
  }

  export type WIP_TRANSACTIONSAvgAggregateOutputType = {
    id: number | null
    wipId: number | null
    quantity: number | null
    initiatedById: number | null
  }

  export type WIP_TRANSACTIONSSumAggregateOutputType = {
    id: number | null
    wipId: number | null
    quantity: number | null
    initiatedById: number | null
  }

  export type WIP_TRANSACTIONSMinAggregateOutputType = {
    id: number | null
    wipId: number | null
    quantity: number | null
    transactionType: $Enums.TransactionType | null
    reason: string | null
    status: $Enums.Status | null
    initiatedById: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type WIP_TRANSACTIONSMaxAggregateOutputType = {
    id: number | null
    wipId: number | null
    quantity: number | null
    transactionType: $Enums.TransactionType | null
    reason: string | null
    status: $Enums.Status | null
    initiatedById: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type WIP_TRANSACTIONSCountAggregateOutputType = {
    id: number
    wipId: number
    quantity: number
    transactionType: number
    reason: number
    status: number
    initiatedById: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type WIP_TRANSACTIONSAvgAggregateInputType = {
    id?: true
    wipId?: true
    quantity?: true
    initiatedById?: true
  }

  export type WIP_TRANSACTIONSSumAggregateInputType = {
    id?: true
    wipId?: true
    quantity?: true
    initiatedById?: true
  }

  export type WIP_TRANSACTIONSMinAggregateInputType = {
    id?: true
    wipId?: true
    quantity?: true
    transactionType?: true
    reason?: true
    status?: true
    initiatedById?: true
    createdAt?: true
    updatedAt?: true
  }

  export type WIP_TRANSACTIONSMaxAggregateInputType = {
    id?: true
    wipId?: true
    quantity?: true
    transactionType?: true
    reason?: true
    status?: true
    initiatedById?: true
    createdAt?: true
    updatedAt?: true
  }

  export type WIP_TRANSACTIONSCountAggregateInputType = {
    id?: true
    wipId?: true
    quantity?: true
    transactionType?: true
    reason?: true
    status?: true
    initiatedById?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type WIP_TRANSACTIONSAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WIP_TRANSACTIONS to aggregate.
     */
    where?: WIP_TRANSACTIONSWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WIP_TRANSACTIONS to fetch.
     */
    orderBy?: WIP_TRANSACTIONSOrderByWithRelationInput | WIP_TRANSACTIONSOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WIP_TRANSACTIONSWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WIP_TRANSACTIONS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WIP_TRANSACTIONS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned WIP_TRANSACTIONS
    **/
    _count?: true | WIP_TRANSACTIONSCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: WIP_TRANSACTIONSAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: WIP_TRANSACTIONSSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WIP_TRANSACTIONSMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WIP_TRANSACTIONSMaxAggregateInputType
  }

  export type GetWIP_TRANSACTIONSAggregateType<T extends WIP_TRANSACTIONSAggregateArgs> = {
        [P in keyof T & keyof AggregateWIP_TRANSACTIONS]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWIP_TRANSACTIONS[P]>
      : GetScalarType<T[P], AggregateWIP_TRANSACTIONS[P]>
  }




  export type WIP_TRANSACTIONSGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WIP_TRANSACTIONSWhereInput
    orderBy?: WIP_TRANSACTIONSOrderByWithAggregationInput | WIP_TRANSACTIONSOrderByWithAggregationInput[]
    by: WIP_TRANSACTIONSScalarFieldEnum[] | WIP_TRANSACTIONSScalarFieldEnum
    having?: WIP_TRANSACTIONSScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WIP_TRANSACTIONSCountAggregateInputType | true
    _avg?: WIP_TRANSACTIONSAvgAggregateInputType
    _sum?: WIP_TRANSACTIONSSumAggregateInputType
    _min?: WIP_TRANSACTIONSMinAggregateInputType
    _max?: WIP_TRANSACTIONSMaxAggregateInputType
  }

  export type WIP_TRANSACTIONSGroupByOutputType = {
    id: number
    wipId: number
    quantity: number
    transactionType: $Enums.TransactionType
    reason: string
    status: $Enums.Status
    initiatedById: number
    createdAt: Date
    updatedAt: Date
    _count: WIP_TRANSACTIONSCountAggregateOutputType | null
    _avg: WIP_TRANSACTIONSAvgAggregateOutputType | null
    _sum: WIP_TRANSACTIONSSumAggregateOutputType | null
    _min: WIP_TRANSACTIONSMinAggregateOutputType | null
    _max: WIP_TRANSACTIONSMaxAggregateOutputType | null
  }

  type GetWIP_TRANSACTIONSGroupByPayload<T extends WIP_TRANSACTIONSGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WIP_TRANSACTIONSGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WIP_TRANSACTIONSGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WIP_TRANSACTIONSGroupByOutputType[P]>
            : GetScalarType<T[P], WIP_TRANSACTIONSGroupByOutputType[P]>
        }
      >
    >


  export type WIP_TRANSACTIONSSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    wipId?: boolean
    quantity?: boolean
    transactionType?: boolean
    reason?: boolean
    status?: boolean
    initiatedById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    wip?: boolean | WIPDefaultArgs<ExtArgs>
    initiatedBy?: boolean | EmployeeDefaultArgs<ExtArgs>
    wipQC?: boolean | WIP_TRANSACTIONS$wipQCArgs<ExtArgs>
    wipWasteLogs?: boolean | WIP_TRANSACTIONS$wipWasteLogsArgs<ExtArgs>
    _count?: boolean | WIP_TRANSACTIONSCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["wIP_TRANSACTIONS"]>



  export type WIP_TRANSACTIONSSelectScalar = {
    id?: boolean
    wipId?: boolean
    quantity?: boolean
    transactionType?: boolean
    reason?: boolean
    status?: boolean
    initiatedById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type WIP_TRANSACTIONSOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "wipId" | "quantity" | "transactionType" | "reason" | "status" | "initiatedById" | "createdAt" | "updatedAt", ExtArgs["result"]["wIP_TRANSACTIONS"]>
  export type WIP_TRANSACTIONSInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    wip?: boolean | WIPDefaultArgs<ExtArgs>
    initiatedBy?: boolean | EmployeeDefaultArgs<ExtArgs>
    wipQC?: boolean | WIP_TRANSACTIONS$wipQCArgs<ExtArgs>
    wipWasteLogs?: boolean | WIP_TRANSACTIONS$wipWasteLogsArgs<ExtArgs>
    _count?: boolean | WIP_TRANSACTIONSCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $WIP_TRANSACTIONSPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "WIP_TRANSACTIONS"
    objects: {
      wip: Prisma.$WIPPayload<ExtArgs>
      initiatedBy: Prisma.$EmployeePayload<ExtArgs>
      wipQC: Prisma.$WIP_QCPayload<ExtArgs>[]
      wipWasteLogs: Prisma.$WIP_WASTAGE_LOGSPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      wipId: number
      quantity: number
      transactionType: $Enums.TransactionType
      reason: string
      status: $Enums.Status
      initiatedById: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["wIP_TRANSACTIONS"]>
    composites: {}
  }

  type WIP_TRANSACTIONSGetPayload<S extends boolean | null | undefined | WIP_TRANSACTIONSDefaultArgs> = $Result.GetResult<Prisma.$WIP_TRANSACTIONSPayload, S>

  type WIP_TRANSACTIONSCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<WIP_TRANSACTIONSFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: WIP_TRANSACTIONSCountAggregateInputType | true
    }

  export interface WIP_TRANSACTIONSDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['WIP_TRANSACTIONS'], meta: { name: 'WIP_TRANSACTIONS' } }
    /**
     * Find zero or one WIP_TRANSACTIONS that matches the filter.
     * @param {WIP_TRANSACTIONSFindUniqueArgs} args - Arguments to find a WIP_TRANSACTIONS
     * @example
     * // Get one WIP_TRANSACTIONS
     * const wIP_TRANSACTIONS = await prisma.wIP_TRANSACTIONS.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WIP_TRANSACTIONSFindUniqueArgs>(args: SelectSubset<T, WIP_TRANSACTIONSFindUniqueArgs<ExtArgs>>): Prisma__WIP_TRANSACTIONSClient<$Result.GetResult<Prisma.$WIP_TRANSACTIONSPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one WIP_TRANSACTIONS that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {WIP_TRANSACTIONSFindUniqueOrThrowArgs} args - Arguments to find a WIP_TRANSACTIONS
     * @example
     * // Get one WIP_TRANSACTIONS
     * const wIP_TRANSACTIONS = await prisma.wIP_TRANSACTIONS.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WIP_TRANSACTIONSFindUniqueOrThrowArgs>(args: SelectSubset<T, WIP_TRANSACTIONSFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WIP_TRANSACTIONSClient<$Result.GetResult<Prisma.$WIP_TRANSACTIONSPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first WIP_TRANSACTIONS that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WIP_TRANSACTIONSFindFirstArgs} args - Arguments to find a WIP_TRANSACTIONS
     * @example
     * // Get one WIP_TRANSACTIONS
     * const wIP_TRANSACTIONS = await prisma.wIP_TRANSACTIONS.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WIP_TRANSACTIONSFindFirstArgs>(args?: SelectSubset<T, WIP_TRANSACTIONSFindFirstArgs<ExtArgs>>): Prisma__WIP_TRANSACTIONSClient<$Result.GetResult<Prisma.$WIP_TRANSACTIONSPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first WIP_TRANSACTIONS that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WIP_TRANSACTIONSFindFirstOrThrowArgs} args - Arguments to find a WIP_TRANSACTIONS
     * @example
     * // Get one WIP_TRANSACTIONS
     * const wIP_TRANSACTIONS = await prisma.wIP_TRANSACTIONS.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WIP_TRANSACTIONSFindFirstOrThrowArgs>(args?: SelectSubset<T, WIP_TRANSACTIONSFindFirstOrThrowArgs<ExtArgs>>): Prisma__WIP_TRANSACTIONSClient<$Result.GetResult<Prisma.$WIP_TRANSACTIONSPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more WIP_TRANSACTIONS that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WIP_TRANSACTIONSFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all WIP_TRANSACTIONS
     * const wIP_TRANSACTIONS = await prisma.wIP_TRANSACTIONS.findMany()
     * 
     * // Get first 10 WIP_TRANSACTIONS
     * const wIP_TRANSACTIONS = await prisma.wIP_TRANSACTIONS.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const wIP_TRANSACTIONSWithIdOnly = await prisma.wIP_TRANSACTIONS.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends WIP_TRANSACTIONSFindManyArgs>(args?: SelectSubset<T, WIP_TRANSACTIONSFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WIP_TRANSACTIONSPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a WIP_TRANSACTIONS.
     * @param {WIP_TRANSACTIONSCreateArgs} args - Arguments to create a WIP_TRANSACTIONS.
     * @example
     * // Create one WIP_TRANSACTIONS
     * const WIP_TRANSACTIONS = await prisma.wIP_TRANSACTIONS.create({
     *   data: {
     *     // ... data to create a WIP_TRANSACTIONS
     *   }
     * })
     * 
     */
    create<T extends WIP_TRANSACTIONSCreateArgs>(args: SelectSubset<T, WIP_TRANSACTIONSCreateArgs<ExtArgs>>): Prisma__WIP_TRANSACTIONSClient<$Result.GetResult<Prisma.$WIP_TRANSACTIONSPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many WIP_TRANSACTIONS.
     * @param {WIP_TRANSACTIONSCreateManyArgs} args - Arguments to create many WIP_TRANSACTIONS.
     * @example
     * // Create many WIP_TRANSACTIONS
     * const wIP_TRANSACTIONS = await prisma.wIP_TRANSACTIONS.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WIP_TRANSACTIONSCreateManyArgs>(args?: SelectSubset<T, WIP_TRANSACTIONSCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a WIP_TRANSACTIONS.
     * @param {WIP_TRANSACTIONSDeleteArgs} args - Arguments to delete one WIP_TRANSACTIONS.
     * @example
     * // Delete one WIP_TRANSACTIONS
     * const WIP_TRANSACTIONS = await prisma.wIP_TRANSACTIONS.delete({
     *   where: {
     *     // ... filter to delete one WIP_TRANSACTIONS
     *   }
     * })
     * 
     */
    delete<T extends WIP_TRANSACTIONSDeleteArgs>(args: SelectSubset<T, WIP_TRANSACTIONSDeleteArgs<ExtArgs>>): Prisma__WIP_TRANSACTIONSClient<$Result.GetResult<Prisma.$WIP_TRANSACTIONSPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one WIP_TRANSACTIONS.
     * @param {WIP_TRANSACTIONSUpdateArgs} args - Arguments to update one WIP_TRANSACTIONS.
     * @example
     * // Update one WIP_TRANSACTIONS
     * const wIP_TRANSACTIONS = await prisma.wIP_TRANSACTIONS.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WIP_TRANSACTIONSUpdateArgs>(args: SelectSubset<T, WIP_TRANSACTIONSUpdateArgs<ExtArgs>>): Prisma__WIP_TRANSACTIONSClient<$Result.GetResult<Prisma.$WIP_TRANSACTIONSPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more WIP_TRANSACTIONS.
     * @param {WIP_TRANSACTIONSDeleteManyArgs} args - Arguments to filter WIP_TRANSACTIONS to delete.
     * @example
     * // Delete a few WIP_TRANSACTIONS
     * const { count } = await prisma.wIP_TRANSACTIONS.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WIP_TRANSACTIONSDeleteManyArgs>(args?: SelectSubset<T, WIP_TRANSACTIONSDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WIP_TRANSACTIONS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WIP_TRANSACTIONSUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many WIP_TRANSACTIONS
     * const wIP_TRANSACTIONS = await prisma.wIP_TRANSACTIONS.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WIP_TRANSACTIONSUpdateManyArgs>(args: SelectSubset<T, WIP_TRANSACTIONSUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one WIP_TRANSACTIONS.
     * @param {WIP_TRANSACTIONSUpsertArgs} args - Arguments to update or create a WIP_TRANSACTIONS.
     * @example
     * // Update or create a WIP_TRANSACTIONS
     * const wIP_TRANSACTIONS = await prisma.wIP_TRANSACTIONS.upsert({
     *   create: {
     *     // ... data to create a WIP_TRANSACTIONS
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the WIP_TRANSACTIONS we want to update
     *   }
     * })
     */
    upsert<T extends WIP_TRANSACTIONSUpsertArgs>(args: SelectSubset<T, WIP_TRANSACTIONSUpsertArgs<ExtArgs>>): Prisma__WIP_TRANSACTIONSClient<$Result.GetResult<Prisma.$WIP_TRANSACTIONSPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of WIP_TRANSACTIONS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WIP_TRANSACTIONSCountArgs} args - Arguments to filter WIP_TRANSACTIONS to count.
     * @example
     * // Count the number of WIP_TRANSACTIONS
     * const count = await prisma.wIP_TRANSACTIONS.count({
     *   where: {
     *     // ... the filter for the WIP_TRANSACTIONS we want to count
     *   }
     * })
    **/
    count<T extends WIP_TRANSACTIONSCountArgs>(
      args?: Subset<T, WIP_TRANSACTIONSCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WIP_TRANSACTIONSCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a WIP_TRANSACTIONS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WIP_TRANSACTIONSAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WIP_TRANSACTIONSAggregateArgs>(args: Subset<T, WIP_TRANSACTIONSAggregateArgs>): Prisma.PrismaPromise<GetWIP_TRANSACTIONSAggregateType<T>>

    /**
     * Group by WIP_TRANSACTIONS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WIP_TRANSACTIONSGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WIP_TRANSACTIONSGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WIP_TRANSACTIONSGroupByArgs['orderBy'] }
        : { orderBy?: WIP_TRANSACTIONSGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WIP_TRANSACTIONSGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWIP_TRANSACTIONSGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the WIP_TRANSACTIONS model
   */
  readonly fields: WIP_TRANSACTIONSFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for WIP_TRANSACTIONS.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WIP_TRANSACTIONSClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    wip<T extends WIPDefaultArgs<ExtArgs> = {}>(args?: Subset<T, WIPDefaultArgs<ExtArgs>>): Prisma__WIPClient<$Result.GetResult<Prisma.$WIPPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    initiatedBy<T extends EmployeeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EmployeeDefaultArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    wipQC<T extends WIP_TRANSACTIONS$wipQCArgs<ExtArgs> = {}>(args?: Subset<T, WIP_TRANSACTIONS$wipQCArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WIP_QCPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    wipWasteLogs<T extends WIP_TRANSACTIONS$wipWasteLogsArgs<ExtArgs> = {}>(args?: Subset<T, WIP_TRANSACTIONS$wipWasteLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WIP_WASTAGE_LOGSPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the WIP_TRANSACTIONS model
   */ 
  interface WIP_TRANSACTIONSFieldRefs {
    readonly id: FieldRef<"WIP_TRANSACTIONS", 'Int'>
    readonly wipId: FieldRef<"WIP_TRANSACTIONS", 'Int'>
    readonly quantity: FieldRef<"WIP_TRANSACTIONS", 'Int'>
    readonly transactionType: FieldRef<"WIP_TRANSACTIONS", 'TransactionType'>
    readonly reason: FieldRef<"WIP_TRANSACTIONS", 'String'>
    readonly status: FieldRef<"WIP_TRANSACTIONS", 'Status'>
    readonly initiatedById: FieldRef<"WIP_TRANSACTIONS", 'Int'>
    readonly createdAt: FieldRef<"WIP_TRANSACTIONS", 'DateTime'>
    readonly updatedAt: FieldRef<"WIP_TRANSACTIONS", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * WIP_TRANSACTIONS findUnique
   */
  export type WIP_TRANSACTIONSFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WIP_TRANSACTIONS
     */
    select?: WIP_TRANSACTIONSSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WIP_TRANSACTIONS
     */
    omit?: WIP_TRANSACTIONSOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WIP_TRANSACTIONSInclude<ExtArgs> | null
    /**
     * Filter, which WIP_TRANSACTIONS to fetch.
     */
    where: WIP_TRANSACTIONSWhereUniqueInput
  }

  /**
   * WIP_TRANSACTIONS findUniqueOrThrow
   */
  export type WIP_TRANSACTIONSFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WIP_TRANSACTIONS
     */
    select?: WIP_TRANSACTIONSSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WIP_TRANSACTIONS
     */
    omit?: WIP_TRANSACTIONSOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WIP_TRANSACTIONSInclude<ExtArgs> | null
    /**
     * Filter, which WIP_TRANSACTIONS to fetch.
     */
    where: WIP_TRANSACTIONSWhereUniqueInput
  }

  /**
   * WIP_TRANSACTIONS findFirst
   */
  export type WIP_TRANSACTIONSFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WIP_TRANSACTIONS
     */
    select?: WIP_TRANSACTIONSSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WIP_TRANSACTIONS
     */
    omit?: WIP_TRANSACTIONSOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WIP_TRANSACTIONSInclude<ExtArgs> | null
    /**
     * Filter, which WIP_TRANSACTIONS to fetch.
     */
    where?: WIP_TRANSACTIONSWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WIP_TRANSACTIONS to fetch.
     */
    orderBy?: WIP_TRANSACTIONSOrderByWithRelationInput | WIP_TRANSACTIONSOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WIP_TRANSACTIONS.
     */
    cursor?: WIP_TRANSACTIONSWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WIP_TRANSACTIONS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WIP_TRANSACTIONS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WIP_TRANSACTIONS.
     */
    distinct?: WIP_TRANSACTIONSScalarFieldEnum | WIP_TRANSACTIONSScalarFieldEnum[]
  }

  /**
   * WIP_TRANSACTIONS findFirstOrThrow
   */
  export type WIP_TRANSACTIONSFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WIP_TRANSACTIONS
     */
    select?: WIP_TRANSACTIONSSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WIP_TRANSACTIONS
     */
    omit?: WIP_TRANSACTIONSOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WIP_TRANSACTIONSInclude<ExtArgs> | null
    /**
     * Filter, which WIP_TRANSACTIONS to fetch.
     */
    where?: WIP_TRANSACTIONSWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WIP_TRANSACTIONS to fetch.
     */
    orderBy?: WIP_TRANSACTIONSOrderByWithRelationInput | WIP_TRANSACTIONSOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WIP_TRANSACTIONS.
     */
    cursor?: WIP_TRANSACTIONSWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WIP_TRANSACTIONS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WIP_TRANSACTIONS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WIP_TRANSACTIONS.
     */
    distinct?: WIP_TRANSACTIONSScalarFieldEnum | WIP_TRANSACTIONSScalarFieldEnum[]
  }

  /**
   * WIP_TRANSACTIONS findMany
   */
  export type WIP_TRANSACTIONSFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WIP_TRANSACTIONS
     */
    select?: WIP_TRANSACTIONSSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WIP_TRANSACTIONS
     */
    omit?: WIP_TRANSACTIONSOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WIP_TRANSACTIONSInclude<ExtArgs> | null
    /**
     * Filter, which WIP_TRANSACTIONS to fetch.
     */
    where?: WIP_TRANSACTIONSWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WIP_TRANSACTIONS to fetch.
     */
    orderBy?: WIP_TRANSACTIONSOrderByWithRelationInput | WIP_TRANSACTIONSOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing WIP_TRANSACTIONS.
     */
    cursor?: WIP_TRANSACTIONSWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WIP_TRANSACTIONS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WIP_TRANSACTIONS.
     */
    skip?: number
    distinct?: WIP_TRANSACTIONSScalarFieldEnum | WIP_TRANSACTIONSScalarFieldEnum[]
  }

  /**
   * WIP_TRANSACTIONS create
   */
  export type WIP_TRANSACTIONSCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WIP_TRANSACTIONS
     */
    select?: WIP_TRANSACTIONSSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WIP_TRANSACTIONS
     */
    omit?: WIP_TRANSACTIONSOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WIP_TRANSACTIONSInclude<ExtArgs> | null
    /**
     * The data needed to create a WIP_TRANSACTIONS.
     */
    data: XOR<WIP_TRANSACTIONSCreateInput, WIP_TRANSACTIONSUncheckedCreateInput>
  }

  /**
   * WIP_TRANSACTIONS createMany
   */
  export type WIP_TRANSACTIONSCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many WIP_TRANSACTIONS.
     */
    data: WIP_TRANSACTIONSCreateManyInput | WIP_TRANSACTIONSCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * WIP_TRANSACTIONS update
   */
  export type WIP_TRANSACTIONSUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WIP_TRANSACTIONS
     */
    select?: WIP_TRANSACTIONSSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WIP_TRANSACTIONS
     */
    omit?: WIP_TRANSACTIONSOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WIP_TRANSACTIONSInclude<ExtArgs> | null
    /**
     * The data needed to update a WIP_TRANSACTIONS.
     */
    data: XOR<WIP_TRANSACTIONSUpdateInput, WIP_TRANSACTIONSUncheckedUpdateInput>
    /**
     * Choose, which WIP_TRANSACTIONS to update.
     */
    where: WIP_TRANSACTIONSWhereUniqueInput
  }

  /**
   * WIP_TRANSACTIONS updateMany
   */
  export type WIP_TRANSACTIONSUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update WIP_TRANSACTIONS.
     */
    data: XOR<WIP_TRANSACTIONSUpdateManyMutationInput, WIP_TRANSACTIONSUncheckedUpdateManyInput>
    /**
     * Filter which WIP_TRANSACTIONS to update
     */
    where?: WIP_TRANSACTIONSWhereInput
  }

  /**
   * WIP_TRANSACTIONS upsert
   */
  export type WIP_TRANSACTIONSUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WIP_TRANSACTIONS
     */
    select?: WIP_TRANSACTIONSSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WIP_TRANSACTIONS
     */
    omit?: WIP_TRANSACTIONSOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WIP_TRANSACTIONSInclude<ExtArgs> | null
    /**
     * The filter to search for the WIP_TRANSACTIONS to update in case it exists.
     */
    where: WIP_TRANSACTIONSWhereUniqueInput
    /**
     * In case the WIP_TRANSACTIONS found by the `where` argument doesn't exist, create a new WIP_TRANSACTIONS with this data.
     */
    create: XOR<WIP_TRANSACTIONSCreateInput, WIP_TRANSACTIONSUncheckedCreateInput>
    /**
     * In case the WIP_TRANSACTIONS was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WIP_TRANSACTIONSUpdateInput, WIP_TRANSACTIONSUncheckedUpdateInput>
  }

  /**
   * WIP_TRANSACTIONS delete
   */
  export type WIP_TRANSACTIONSDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WIP_TRANSACTIONS
     */
    select?: WIP_TRANSACTIONSSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WIP_TRANSACTIONS
     */
    omit?: WIP_TRANSACTIONSOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WIP_TRANSACTIONSInclude<ExtArgs> | null
    /**
     * Filter which WIP_TRANSACTIONS to delete.
     */
    where: WIP_TRANSACTIONSWhereUniqueInput
  }

  /**
   * WIP_TRANSACTIONS deleteMany
   */
  export type WIP_TRANSACTIONSDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WIP_TRANSACTIONS to delete
     */
    where?: WIP_TRANSACTIONSWhereInput
  }

  /**
   * WIP_TRANSACTIONS.wipQC
   */
  export type WIP_TRANSACTIONS$wipQCArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WIP_QC
     */
    select?: WIP_QCSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WIP_QC
     */
    omit?: WIP_QCOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WIP_QCInclude<ExtArgs> | null
    where?: WIP_QCWhereInput
    orderBy?: WIP_QCOrderByWithRelationInput | WIP_QCOrderByWithRelationInput[]
    cursor?: WIP_QCWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WIP_QCScalarFieldEnum | WIP_QCScalarFieldEnum[]
  }

  /**
   * WIP_TRANSACTIONS.wipWasteLogs
   */
  export type WIP_TRANSACTIONS$wipWasteLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WIP_WASTAGE_LOGS
     */
    select?: WIP_WASTAGE_LOGSSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WIP_WASTAGE_LOGS
     */
    omit?: WIP_WASTAGE_LOGSOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WIP_WASTAGE_LOGSInclude<ExtArgs> | null
    where?: WIP_WASTAGE_LOGSWhereInput
    orderBy?: WIP_WASTAGE_LOGSOrderByWithRelationInput | WIP_WASTAGE_LOGSOrderByWithRelationInput[]
    cursor?: WIP_WASTAGE_LOGSWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WIP_WASTAGE_LOGSScalarFieldEnum | WIP_WASTAGE_LOGSScalarFieldEnum[]
  }

  /**
   * WIP_TRANSACTIONS without action
   */
  export type WIP_TRANSACTIONSDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WIP_TRANSACTIONS
     */
    select?: WIP_TRANSACTIONSSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WIP_TRANSACTIONS
     */
    omit?: WIP_TRANSACTIONSOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WIP_TRANSACTIONSInclude<ExtArgs> | null
  }


  /**
   * Model FG_TRANSACTIONS
   */

  export type AggregateFG_TRANSACTIONS = {
    _count: FG_TRANSACTIONSCountAggregateOutputType | null
    _avg: FG_TRANSACTIONSAvgAggregateOutputType | null
    _sum: FG_TRANSACTIONSSumAggregateOutputType | null
    _min: FG_TRANSACTIONSMinAggregateOutputType | null
    _max: FG_TRANSACTIONSMaxAggregateOutputType | null
  }

  export type FG_TRANSACTIONSAvgAggregateOutputType = {
    id: number | null
    fgId: number | null
    quantity: number | null
    IntiatedById: number | null
  }

  export type FG_TRANSACTIONSSumAggregateOutputType = {
    id: number | null
    fgId: number | null
    quantity: number | null
    IntiatedById: number | null
  }

  export type FG_TRANSACTIONSMinAggregateOutputType = {
    id: number | null
    fgId: number | null
    quantity: number | null
    transactionType: $Enums.TransactionType | null
    status: $Enums.Status | null
    reason: string | null
    IntiatedById: number | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type FG_TRANSACTIONSMaxAggregateOutputType = {
    id: number | null
    fgId: number | null
    quantity: number | null
    transactionType: $Enums.TransactionType | null
    status: $Enums.Status | null
    reason: string | null
    IntiatedById: number | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type FG_TRANSACTIONSCountAggregateOutputType = {
    id: number
    fgId: number
    quantity: number
    transactionType: number
    status: number
    reason: number
    IntiatedById: number
    createdAt: number
    updatedAt: number
    deletedAt: number
    _all: number
  }


  export type FG_TRANSACTIONSAvgAggregateInputType = {
    id?: true
    fgId?: true
    quantity?: true
    IntiatedById?: true
  }

  export type FG_TRANSACTIONSSumAggregateInputType = {
    id?: true
    fgId?: true
    quantity?: true
    IntiatedById?: true
  }

  export type FG_TRANSACTIONSMinAggregateInputType = {
    id?: true
    fgId?: true
    quantity?: true
    transactionType?: true
    status?: true
    reason?: true
    IntiatedById?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type FG_TRANSACTIONSMaxAggregateInputType = {
    id?: true
    fgId?: true
    quantity?: true
    transactionType?: true
    status?: true
    reason?: true
    IntiatedById?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type FG_TRANSACTIONSCountAggregateInputType = {
    id?: true
    fgId?: true
    quantity?: true
    transactionType?: true
    status?: true
    reason?: true
    IntiatedById?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
    _all?: true
  }

  export type FG_TRANSACTIONSAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FG_TRANSACTIONS to aggregate.
     */
    where?: FG_TRANSACTIONSWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FG_TRANSACTIONS to fetch.
     */
    orderBy?: FG_TRANSACTIONSOrderByWithRelationInput | FG_TRANSACTIONSOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FG_TRANSACTIONSWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FG_TRANSACTIONS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FG_TRANSACTIONS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FG_TRANSACTIONS
    **/
    _count?: true | FG_TRANSACTIONSCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FG_TRANSACTIONSAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FG_TRANSACTIONSSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FG_TRANSACTIONSMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FG_TRANSACTIONSMaxAggregateInputType
  }

  export type GetFG_TRANSACTIONSAggregateType<T extends FG_TRANSACTIONSAggregateArgs> = {
        [P in keyof T & keyof AggregateFG_TRANSACTIONS]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFG_TRANSACTIONS[P]>
      : GetScalarType<T[P], AggregateFG_TRANSACTIONS[P]>
  }




  export type FG_TRANSACTIONSGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FG_TRANSACTIONSWhereInput
    orderBy?: FG_TRANSACTIONSOrderByWithAggregationInput | FG_TRANSACTIONSOrderByWithAggregationInput[]
    by: FG_TRANSACTIONSScalarFieldEnum[] | FG_TRANSACTIONSScalarFieldEnum
    having?: FG_TRANSACTIONSScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FG_TRANSACTIONSCountAggregateInputType | true
    _avg?: FG_TRANSACTIONSAvgAggregateInputType
    _sum?: FG_TRANSACTIONSSumAggregateInputType
    _min?: FG_TRANSACTIONSMinAggregateInputType
    _max?: FG_TRANSACTIONSMaxAggregateInputType
  }

  export type FG_TRANSACTIONSGroupByOutputType = {
    id: number
    fgId: number
    quantity: number
    transactionType: $Enums.TransactionType
    status: $Enums.Status
    reason: string
    IntiatedById: number
    createdAt: Date
    updatedAt: Date
    deletedAt: Date | null
    _count: FG_TRANSACTIONSCountAggregateOutputType | null
    _avg: FG_TRANSACTIONSAvgAggregateOutputType | null
    _sum: FG_TRANSACTIONSSumAggregateOutputType | null
    _min: FG_TRANSACTIONSMinAggregateOutputType | null
    _max: FG_TRANSACTIONSMaxAggregateOutputType | null
  }

  type GetFG_TRANSACTIONSGroupByPayload<T extends FG_TRANSACTIONSGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FG_TRANSACTIONSGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FG_TRANSACTIONSGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FG_TRANSACTIONSGroupByOutputType[P]>
            : GetScalarType<T[P], FG_TRANSACTIONSGroupByOutputType[P]>
        }
      >
    >


  export type FG_TRANSACTIONSSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    fgId?: boolean
    quantity?: boolean
    transactionType?: boolean
    status?: boolean
    reason?: boolean
    IntiatedById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    fg?: boolean | FGDefaultArgs<ExtArgs>
    initiatedBy?: boolean | EmployeeDefaultArgs<ExtArgs>
    fgQC?: boolean | FG_TRANSACTIONS$fgQCArgs<ExtArgs>
    fgWasteLogs?: boolean | FG_TRANSACTIONS$fgWasteLogsArgs<ExtArgs>
    _count?: boolean | FG_TRANSACTIONSCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["fG_TRANSACTIONS"]>



  export type FG_TRANSACTIONSSelectScalar = {
    id?: boolean
    fgId?: boolean
    quantity?: boolean
    transactionType?: boolean
    status?: boolean
    reason?: boolean
    IntiatedById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
  }

  export type FG_TRANSACTIONSOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "fgId" | "quantity" | "transactionType" | "status" | "reason" | "IntiatedById" | "createdAt" | "updatedAt" | "deletedAt", ExtArgs["result"]["fG_TRANSACTIONS"]>
  export type FG_TRANSACTIONSInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    fg?: boolean | FGDefaultArgs<ExtArgs>
    initiatedBy?: boolean | EmployeeDefaultArgs<ExtArgs>
    fgQC?: boolean | FG_TRANSACTIONS$fgQCArgs<ExtArgs>
    fgWasteLogs?: boolean | FG_TRANSACTIONS$fgWasteLogsArgs<ExtArgs>
    _count?: boolean | FG_TRANSACTIONSCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $FG_TRANSACTIONSPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "FG_TRANSACTIONS"
    objects: {
      fg: Prisma.$FGPayload<ExtArgs>
      initiatedBy: Prisma.$EmployeePayload<ExtArgs>
      fgQC: Prisma.$FG_QCPayload<ExtArgs>[]
      fgWasteLogs: Prisma.$FG_WASTAGE_LOGSPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      fgId: number
      quantity: number
      transactionType: $Enums.TransactionType
      status: $Enums.Status
      reason: string
      IntiatedById: number
      createdAt: Date
      updatedAt: Date
      deletedAt: Date | null
    }, ExtArgs["result"]["fG_TRANSACTIONS"]>
    composites: {}
  }

  type FG_TRANSACTIONSGetPayload<S extends boolean | null | undefined | FG_TRANSACTIONSDefaultArgs> = $Result.GetResult<Prisma.$FG_TRANSACTIONSPayload, S>

  type FG_TRANSACTIONSCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<FG_TRANSACTIONSFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FG_TRANSACTIONSCountAggregateInputType | true
    }

  export interface FG_TRANSACTIONSDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['FG_TRANSACTIONS'], meta: { name: 'FG_TRANSACTIONS' } }
    /**
     * Find zero or one FG_TRANSACTIONS that matches the filter.
     * @param {FG_TRANSACTIONSFindUniqueArgs} args - Arguments to find a FG_TRANSACTIONS
     * @example
     * // Get one FG_TRANSACTIONS
     * const fG_TRANSACTIONS = await prisma.fG_TRANSACTIONS.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FG_TRANSACTIONSFindUniqueArgs>(args: SelectSubset<T, FG_TRANSACTIONSFindUniqueArgs<ExtArgs>>): Prisma__FG_TRANSACTIONSClient<$Result.GetResult<Prisma.$FG_TRANSACTIONSPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one FG_TRANSACTIONS that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FG_TRANSACTIONSFindUniqueOrThrowArgs} args - Arguments to find a FG_TRANSACTIONS
     * @example
     * // Get one FG_TRANSACTIONS
     * const fG_TRANSACTIONS = await prisma.fG_TRANSACTIONS.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FG_TRANSACTIONSFindUniqueOrThrowArgs>(args: SelectSubset<T, FG_TRANSACTIONSFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FG_TRANSACTIONSClient<$Result.GetResult<Prisma.$FG_TRANSACTIONSPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first FG_TRANSACTIONS that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FG_TRANSACTIONSFindFirstArgs} args - Arguments to find a FG_TRANSACTIONS
     * @example
     * // Get one FG_TRANSACTIONS
     * const fG_TRANSACTIONS = await prisma.fG_TRANSACTIONS.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FG_TRANSACTIONSFindFirstArgs>(args?: SelectSubset<T, FG_TRANSACTIONSFindFirstArgs<ExtArgs>>): Prisma__FG_TRANSACTIONSClient<$Result.GetResult<Prisma.$FG_TRANSACTIONSPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first FG_TRANSACTIONS that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FG_TRANSACTIONSFindFirstOrThrowArgs} args - Arguments to find a FG_TRANSACTIONS
     * @example
     * // Get one FG_TRANSACTIONS
     * const fG_TRANSACTIONS = await prisma.fG_TRANSACTIONS.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FG_TRANSACTIONSFindFirstOrThrowArgs>(args?: SelectSubset<T, FG_TRANSACTIONSFindFirstOrThrowArgs<ExtArgs>>): Prisma__FG_TRANSACTIONSClient<$Result.GetResult<Prisma.$FG_TRANSACTIONSPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more FG_TRANSACTIONS that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FG_TRANSACTIONSFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FG_TRANSACTIONS
     * const fG_TRANSACTIONS = await prisma.fG_TRANSACTIONS.findMany()
     * 
     * // Get first 10 FG_TRANSACTIONS
     * const fG_TRANSACTIONS = await prisma.fG_TRANSACTIONS.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const fG_TRANSACTIONSWithIdOnly = await prisma.fG_TRANSACTIONS.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FG_TRANSACTIONSFindManyArgs>(args?: SelectSubset<T, FG_TRANSACTIONSFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FG_TRANSACTIONSPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a FG_TRANSACTIONS.
     * @param {FG_TRANSACTIONSCreateArgs} args - Arguments to create a FG_TRANSACTIONS.
     * @example
     * // Create one FG_TRANSACTIONS
     * const FG_TRANSACTIONS = await prisma.fG_TRANSACTIONS.create({
     *   data: {
     *     // ... data to create a FG_TRANSACTIONS
     *   }
     * })
     * 
     */
    create<T extends FG_TRANSACTIONSCreateArgs>(args: SelectSubset<T, FG_TRANSACTIONSCreateArgs<ExtArgs>>): Prisma__FG_TRANSACTIONSClient<$Result.GetResult<Prisma.$FG_TRANSACTIONSPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many FG_TRANSACTIONS.
     * @param {FG_TRANSACTIONSCreateManyArgs} args - Arguments to create many FG_TRANSACTIONS.
     * @example
     * // Create many FG_TRANSACTIONS
     * const fG_TRANSACTIONS = await prisma.fG_TRANSACTIONS.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FG_TRANSACTIONSCreateManyArgs>(args?: SelectSubset<T, FG_TRANSACTIONSCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a FG_TRANSACTIONS.
     * @param {FG_TRANSACTIONSDeleteArgs} args - Arguments to delete one FG_TRANSACTIONS.
     * @example
     * // Delete one FG_TRANSACTIONS
     * const FG_TRANSACTIONS = await prisma.fG_TRANSACTIONS.delete({
     *   where: {
     *     // ... filter to delete one FG_TRANSACTIONS
     *   }
     * })
     * 
     */
    delete<T extends FG_TRANSACTIONSDeleteArgs>(args: SelectSubset<T, FG_TRANSACTIONSDeleteArgs<ExtArgs>>): Prisma__FG_TRANSACTIONSClient<$Result.GetResult<Prisma.$FG_TRANSACTIONSPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one FG_TRANSACTIONS.
     * @param {FG_TRANSACTIONSUpdateArgs} args - Arguments to update one FG_TRANSACTIONS.
     * @example
     * // Update one FG_TRANSACTIONS
     * const fG_TRANSACTIONS = await prisma.fG_TRANSACTIONS.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FG_TRANSACTIONSUpdateArgs>(args: SelectSubset<T, FG_TRANSACTIONSUpdateArgs<ExtArgs>>): Prisma__FG_TRANSACTIONSClient<$Result.GetResult<Prisma.$FG_TRANSACTIONSPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more FG_TRANSACTIONS.
     * @param {FG_TRANSACTIONSDeleteManyArgs} args - Arguments to filter FG_TRANSACTIONS to delete.
     * @example
     * // Delete a few FG_TRANSACTIONS
     * const { count } = await prisma.fG_TRANSACTIONS.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FG_TRANSACTIONSDeleteManyArgs>(args?: SelectSubset<T, FG_TRANSACTIONSDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FG_TRANSACTIONS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FG_TRANSACTIONSUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FG_TRANSACTIONS
     * const fG_TRANSACTIONS = await prisma.fG_TRANSACTIONS.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FG_TRANSACTIONSUpdateManyArgs>(args: SelectSubset<T, FG_TRANSACTIONSUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one FG_TRANSACTIONS.
     * @param {FG_TRANSACTIONSUpsertArgs} args - Arguments to update or create a FG_TRANSACTIONS.
     * @example
     * // Update or create a FG_TRANSACTIONS
     * const fG_TRANSACTIONS = await prisma.fG_TRANSACTIONS.upsert({
     *   create: {
     *     // ... data to create a FG_TRANSACTIONS
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FG_TRANSACTIONS we want to update
     *   }
     * })
     */
    upsert<T extends FG_TRANSACTIONSUpsertArgs>(args: SelectSubset<T, FG_TRANSACTIONSUpsertArgs<ExtArgs>>): Prisma__FG_TRANSACTIONSClient<$Result.GetResult<Prisma.$FG_TRANSACTIONSPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of FG_TRANSACTIONS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FG_TRANSACTIONSCountArgs} args - Arguments to filter FG_TRANSACTIONS to count.
     * @example
     * // Count the number of FG_TRANSACTIONS
     * const count = await prisma.fG_TRANSACTIONS.count({
     *   where: {
     *     // ... the filter for the FG_TRANSACTIONS we want to count
     *   }
     * })
    **/
    count<T extends FG_TRANSACTIONSCountArgs>(
      args?: Subset<T, FG_TRANSACTIONSCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FG_TRANSACTIONSCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FG_TRANSACTIONS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FG_TRANSACTIONSAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FG_TRANSACTIONSAggregateArgs>(args: Subset<T, FG_TRANSACTIONSAggregateArgs>): Prisma.PrismaPromise<GetFG_TRANSACTIONSAggregateType<T>>

    /**
     * Group by FG_TRANSACTIONS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FG_TRANSACTIONSGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FG_TRANSACTIONSGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FG_TRANSACTIONSGroupByArgs['orderBy'] }
        : { orderBy?: FG_TRANSACTIONSGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FG_TRANSACTIONSGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFG_TRANSACTIONSGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the FG_TRANSACTIONS model
   */
  readonly fields: FG_TRANSACTIONSFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for FG_TRANSACTIONS.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FG_TRANSACTIONSClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    fg<T extends FGDefaultArgs<ExtArgs> = {}>(args?: Subset<T, FGDefaultArgs<ExtArgs>>): Prisma__FGClient<$Result.GetResult<Prisma.$FGPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    initiatedBy<T extends EmployeeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EmployeeDefaultArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    fgQC<T extends FG_TRANSACTIONS$fgQCArgs<ExtArgs> = {}>(args?: Subset<T, FG_TRANSACTIONS$fgQCArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FG_QCPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    fgWasteLogs<T extends FG_TRANSACTIONS$fgWasteLogsArgs<ExtArgs> = {}>(args?: Subset<T, FG_TRANSACTIONS$fgWasteLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FG_WASTAGE_LOGSPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the FG_TRANSACTIONS model
   */ 
  interface FG_TRANSACTIONSFieldRefs {
    readonly id: FieldRef<"FG_TRANSACTIONS", 'Int'>
    readonly fgId: FieldRef<"FG_TRANSACTIONS", 'Int'>
    readonly quantity: FieldRef<"FG_TRANSACTIONS", 'Int'>
    readonly transactionType: FieldRef<"FG_TRANSACTIONS", 'TransactionType'>
    readonly status: FieldRef<"FG_TRANSACTIONS", 'Status'>
    readonly reason: FieldRef<"FG_TRANSACTIONS", 'String'>
    readonly IntiatedById: FieldRef<"FG_TRANSACTIONS", 'Int'>
    readonly createdAt: FieldRef<"FG_TRANSACTIONS", 'DateTime'>
    readonly updatedAt: FieldRef<"FG_TRANSACTIONS", 'DateTime'>
    readonly deletedAt: FieldRef<"FG_TRANSACTIONS", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * FG_TRANSACTIONS findUnique
   */
  export type FG_TRANSACTIONSFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FG_TRANSACTIONS
     */
    select?: FG_TRANSACTIONSSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FG_TRANSACTIONS
     */
    omit?: FG_TRANSACTIONSOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FG_TRANSACTIONSInclude<ExtArgs> | null
    /**
     * Filter, which FG_TRANSACTIONS to fetch.
     */
    where: FG_TRANSACTIONSWhereUniqueInput
  }

  /**
   * FG_TRANSACTIONS findUniqueOrThrow
   */
  export type FG_TRANSACTIONSFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FG_TRANSACTIONS
     */
    select?: FG_TRANSACTIONSSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FG_TRANSACTIONS
     */
    omit?: FG_TRANSACTIONSOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FG_TRANSACTIONSInclude<ExtArgs> | null
    /**
     * Filter, which FG_TRANSACTIONS to fetch.
     */
    where: FG_TRANSACTIONSWhereUniqueInput
  }

  /**
   * FG_TRANSACTIONS findFirst
   */
  export type FG_TRANSACTIONSFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FG_TRANSACTIONS
     */
    select?: FG_TRANSACTIONSSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FG_TRANSACTIONS
     */
    omit?: FG_TRANSACTIONSOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FG_TRANSACTIONSInclude<ExtArgs> | null
    /**
     * Filter, which FG_TRANSACTIONS to fetch.
     */
    where?: FG_TRANSACTIONSWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FG_TRANSACTIONS to fetch.
     */
    orderBy?: FG_TRANSACTIONSOrderByWithRelationInput | FG_TRANSACTIONSOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FG_TRANSACTIONS.
     */
    cursor?: FG_TRANSACTIONSWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FG_TRANSACTIONS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FG_TRANSACTIONS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FG_TRANSACTIONS.
     */
    distinct?: FG_TRANSACTIONSScalarFieldEnum | FG_TRANSACTIONSScalarFieldEnum[]
  }

  /**
   * FG_TRANSACTIONS findFirstOrThrow
   */
  export type FG_TRANSACTIONSFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FG_TRANSACTIONS
     */
    select?: FG_TRANSACTIONSSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FG_TRANSACTIONS
     */
    omit?: FG_TRANSACTIONSOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FG_TRANSACTIONSInclude<ExtArgs> | null
    /**
     * Filter, which FG_TRANSACTIONS to fetch.
     */
    where?: FG_TRANSACTIONSWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FG_TRANSACTIONS to fetch.
     */
    orderBy?: FG_TRANSACTIONSOrderByWithRelationInput | FG_TRANSACTIONSOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FG_TRANSACTIONS.
     */
    cursor?: FG_TRANSACTIONSWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FG_TRANSACTIONS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FG_TRANSACTIONS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FG_TRANSACTIONS.
     */
    distinct?: FG_TRANSACTIONSScalarFieldEnum | FG_TRANSACTIONSScalarFieldEnum[]
  }

  /**
   * FG_TRANSACTIONS findMany
   */
  export type FG_TRANSACTIONSFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FG_TRANSACTIONS
     */
    select?: FG_TRANSACTIONSSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FG_TRANSACTIONS
     */
    omit?: FG_TRANSACTIONSOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FG_TRANSACTIONSInclude<ExtArgs> | null
    /**
     * Filter, which FG_TRANSACTIONS to fetch.
     */
    where?: FG_TRANSACTIONSWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FG_TRANSACTIONS to fetch.
     */
    orderBy?: FG_TRANSACTIONSOrderByWithRelationInput | FG_TRANSACTIONSOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FG_TRANSACTIONS.
     */
    cursor?: FG_TRANSACTIONSWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FG_TRANSACTIONS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FG_TRANSACTIONS.
     */
    skip?: number
    distinct?: FG_TRANSACTIONSScalarFieldEnum | FG_TRANSACTIONSScalarFieldEnum[]
  }

  /**
   * FG_TRANSACTIONS create
   */
  export type FG_TRANSACTIONSCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FG_TRANSACTIONS
     */
    select?: FG_TRANSACTIONSSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FG_TRANSACTIONS
     */
    omit?: FG_TRANSACTIONSOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FG_TRANSACTIONSInclude<ExtArgs> | null
    /**
     * The data needed to create a FG_TRANSACTIONS.
     */
    data: XOR<FG_TRANSACTIONSCreateInput, FG_TRANSACTIONSUncheckedCreateInput>
  }

  /**
   * FG_TRANSACTIONS createMany
   */
  export type FG_TRANSACTIONSCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many FG_TRANSACTIONS.
     */
    data: FG_TRANSACTIONSCreateManyInput | FG_TRANSACTIONSCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * FG_TRANSACTIONS update
   */
  export type FG_TRANSACTIONSUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FG_TRANSACTIONS
     */
    select?: FG_TRANSACTIONSSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FG_TRANSACTIONS
     */
    omit?: FG_TRANSACTIONSOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FG_TRANSACTIONSInclude<ExtArgs> | null
    /**
     * The data needed to update a FG_TRANSACTIONS.
     */
    data: XOR<FG_TRANSACTIONSUpdateInput, FG_TRANSACTIONSUncheckedUpdateInput>
    /**
     * Choose, which FG_TRANSACTIONS to update.
     */
    where: FG_TRANSACTIONSWhereUniqueInput
  }

  /**
   * FG_TRANSACTIONS updateMany
   */
  export type FG_TRANSACTIONSUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update FG_TRANSACTIONS.
     */
    data: XOR<FG_TRANSACTIONSUpdateManyMutationInput, FG_TRANSACTIONSUncheckedUpdateManyInput>
    /**
     * Filter which FG_TRANSACTIONS to update
     */
    where?: FG_TRANSACTIONSWhereInput
  }

  /**
   * FG_TRANSACTIONS upsert
   */
  export type FG_TRANSACTIONSUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FG_TRANSACTIONS
     */
    select?: FG_TRANSACTIONSSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FG_TRANSACTIONS
     */
    omit?: FG_TRANSACTIONSOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FG_TRANSACTIONSInclude<ExtArgs> | null
    /**
     * The filter to search for the FG_TRANSACTIONS to update in case it exists.
     */
    where: FG_TRANSACTIONSWhereUniqueInput
    /**
     * In case the FG_TRANSACTIONS found by the `where` argument doesn't exist, create a new FG_TRANSACTIONS with this data.
     */
    create: XOR<FG_TRANSACTIONSCreateInput, FG_TRANSACTIONSUncheckedCreateInput>
    /**
     * In case the FG_TRANSACTIONS was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FG_TRANSACTIONSUpdateInput, FG_TRANSACTIONSUncheckedUpdateInput>
  }

  /**
   * FG_TRANSACTIONS delete
   */
  export type FG_TRANSACTIONSDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FG_TRANSACTIONS
     */
    select?: FG_TRANSACTIONSSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FG_TRANSACTIONS
     */
    omit?: FG_TRANSACTIONSOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FG_TRANSACTIONSInclude<ExtArgs> | null
    /**
     * Filter which FG_TRANSACTIONS to delete.
     */
    where: FG_TRANSACTIONSWhereUniqueInput
  }

  /**
   * FG_TRANSACTIONS deleteMany
   */
  export type FG_TRANSACTIONSDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FG_TRANSACTIONS to delete
     */
    where?: FG_TRANSACTIONSWhereInput
  }

  /**
   * FG_TRANSACTIONS.fgQC
   */
  export type FG_TRANSACTIONS$fgQCArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FG_QC
     */
    select?: FG_QCSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FG_QC
     */
    omit?: FG_QCOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FG_QCInclude<ExtArgs> | null
    where?: FG_QCWhereInput
    orderBy?: FG_QCOrderByWithRelationInput | FG_QCOrderByWithRelationInput[]
    cursor?: FG_QCWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FG_QCScalarFieldEnum | FG_QCScalarFieldEnum[]
  }

  /**
   * FG_TRANSACTIONS.fgWasteLogs
   */
  export type FG_TRANSACTIONS$fgWasteLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FG_WASTAGE_LOGS
     */
    select?: FG_WASTAGE_LOGSSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FG_WASTAGE_LOGS
     */
    omit?: FG_WASTAGE_LOGSOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FG_WASTAGE_LOGSInclude<ExtArgs> | null
    where?: FG_WASTAGE_LOGSWhereInput
    orderBy?: FG_WASTAGE_LOGSOrderByWithRelationInput | FG_WASTAGE_LOGSOrderByWithRelationInput[]
    cursor?: FG_WASTAGE_LOGSWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FG_WASTAGE_LOGSScalarFieldEnum | FG_WASTAGE_LOGSScalarFieldEnum[]
  }

  /**
   * FG_TRANSACTIONS without action
   */
  export type FG_TRANSACTIONSDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FG_TRANSACTIONS
     */
    select?: FG_TRANSACTIONSSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FG_TRANSACTIONS
     */
    omit?: FG_TRANSACTIONSOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FG_TRANSACTIONSInclude<ExtArgs> | null
  }


  /**
   * Model WIP_QC
   */

  export type AggregateWIP_QC = {
    _count: WIP_QCCountAggregateOutputType | null
    _avg: WIP_QCAvgAggregateOutputType | null
    _sum: WIP_QCSumAggregateOutputType | null
    _min: WIP_QCMinAggregateOutputType | null
    _max: WIP_QCMaxAggregateOutputType | null
  }

  export type WIP_QCAvgAggregateOutputType = {
    id: number | null
    transactionId: number | null
    wipId: number | null
  }

  export type WIP_QCSumAggregateOutputType = {
    id: number | null
    transactionId: number | null
    wipId: number | null
  }

  export type WIP_QCMinAggregateOutputType = {
    id: number | null
    transactionId: number | null
    transactionType: $Enums.TransactionType | null
    wipId: number | null
    quality_status: $Enums.QualityStatus | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type WIP_QCMaxAggregateOutputType = {
    id: number | null
    transactionId: number | null
    transactionType: $Enums.TransactionType | null
    wipId: number | null
    quality_status: $Enums.QualityStatus | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type WIP_QCCountAggregateOutputType = {
    id: number
    transactionId: number
    transactionType: number
    wipId: number
    quality_status: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type WIP_QCAvgAggregateInputType = {
    id?: true
    transactionId?: true
    wipId?: true
  }

  export type WIP_QCSumAggregateInputType = {
    id?: true
    transactionId?: true
    wipId?: true
  }

  export type WIP_QCMinAggregateInputType = {
    id?: true
    transactionId?: true
    transactionType?: true
    wipId?: true
    quality_status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type WIP_QCMaxAggregateInputType = {
    id?: true
    transactionId?: true
    transactionType?: true
    wipId?: true
    quality_status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type WIP_QCCountAggregateInputType = {
    id?: true
    transactionId?: true
    transactionType?: true
    wipId?: true
    quality_status?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type WIP_QCAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WIP_QC to aggregate.
     */
    where?: WIP_QCWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WIP_QCS to fetch.
     */
    orderBy?: WIP_QCOrderByWithRelationInput | WIP_QCOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WIP_QCWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WIP_QCS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WIP_QCS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned WIP_QCS
    **/
    _count?: true | WIP_QCCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: WIP_QCAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: WIP_QCSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WIP_QCMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WIP_QCMaxAggregateInputType
  }

  export type GetWIP_QCAggregateType<T extends WIP_QCAggregateArgs> = {
        [P in keyof T & keyof AggregateWIP_QC]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWIP_QC[P]>
      : GetScalarType<T[P], AggregateWIP_QC[P]>
  }




  export type WIP_QCGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WIP_QCWhereInput
    orderBy?: WIP_QCOrderByWithAggregationInput | WIP_QCOrderByWithAggregationInput[]
    by: WIP_QCScalarFieldEnum[] | WIP_QCScalarFieldEnum
    having?: WIP_QCScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WIP_QCCountAggregateInputType | true
    _avg?: WIP_QCAvgAggregateInputType
    _sum?: WIP_QCSumAggregateInputType
    _min?: WIP_QCMinAggregateInputType
    _max?: WIP_QCMaxAggregateInputType
  }

  export type WIP_QCGroupByOutputType = {
    id: number
    transactionId: number
    transactionType: $Enums.TransactionType
    wipId: number
    quality_status: $Enums.QualityStatus
    createdAt: Date
    updatedAt: Date
    _count: WIP_QCCountAggregateOutputType | null
    _avg: WIP_QCAvgAggregateOutputType | null
    _sum: WIP_QCSumAggregateOutputType | null
    _min: WIP_QCMinAggregateOutputType | null
    _max: WIP_QCMaxAggregateOutputType | null
  }

  type GetWIP_QCGroupByPayload<T extends WIP_QCGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WIP_QCGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WIP_QCGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WIP_QCGroupByOutputType[P]>
            : GetScalarType<T[P], WIP_QCGroupByOutputType[P]>
        }
      >
    >


  export type WIP_QCSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    transactionId?: boolean
    transactionType?: boolean
    wipId?: boolean
    quality_status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    wip?: boolean | WIPDefaultArgs<ExtArgs>
    WIPTransactions?: boolean | WIP_TRANSACTIONSDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["wIP_QC"]>



  export type WIP_QCSelectScalar = {
    id?: boolean
    transactionId?: boolean
    transactionType?: boolean
    wipId?: boolean
    quality_status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type WIP_QCOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "transactionId" | "transactionType" | "wipId" | "quality_status" | "createdAt" | "updatedAt", ExtArgs["result"]["wIP_QC"]>
  export type WIP_QCInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    wip?: boolean | WIPDefaultArgs<ExtArgs>
    WIPTransactions?: boolean | WIP_TRANSACTIONSDefaultArgs<ExtArgs>
  }

  export type $WIP_QCPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "WIP_QC"
    objects: {
      wip: Prisma.$WIPPayload<ExtArgs>
      WIPTransactions: Prisma.$WIP_TRANSACTIONSPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      transactionId: number
      transactionType: $Enums.TransactionType
      wipId: number
      quality_status: $Enums.QualityStatus
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["wIP_QC"]>
    composites: {}
  }

  type WIP_QCGetPayload<S extends boolean | null | undefined | WIP_QCDefaultArgs> = $Result.GetResult<Prisma.$WIP_QCPayload, S>

  type WIP_QCCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<WIP_QCFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: WIP_QCCountAggregateInputType | true
    }

  export interface WIP_QCDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['WIP_QC'], meta: { name: 'WIP_QC' } }
    /**
     * Find zero or one WIP_QC that matches the filter.
     * @param {WIP_QCFindUniqueArgs} args - Arguments to find a WIP_QC
     * @example
     * // Get one WIP_QC
     * const wIP_QC = await prisma.wIP_QC.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WIP_QCFindUniqueArgs>(args: SelectSubset<T, WIP_QCFindUniqueArgs<ExtArgs>>): Prisma__WIP_QCClient<$Result.GetResult<Prisma.$WIP_QCPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one WIP_QC that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {WIP_QCFindUniqueOrThrowArgs} args - Arguments to find a WIP_QC
     * @example
     * // Get one WIP_QC
     * const wIP_QC = await prisma.wIP_QC.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WIP_QCFindUniqueOrThrowArgs>(args: SelectSubset<T, WIP_QCFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WIP_QCClient<$Result.GetResult<Prisma.$WIP_QCPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first WIP_QC that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WIP_QCFindFirstArgs} args - Arguments to find a WIP_QC
     * @example
     * // Get one WIP_QC
     * const wIP_QC = await prisma.wIP_QC.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WIP_QCFindFirstArgs>(args?: SelectSubset<T, WIP_QCFindFirstArgs<ExtArgs>>): Prisma__WIP_QCClient<$Result.GetResult<Prisma.$WIP_QCPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first WIP_QC that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WIP_QCFindFirstOrThrowArgs} args - Arguments to find a WIP_QC
     * @example
     * // Get one WIP_QC
     * const wIP_QC = await prisma.wIP_QC.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WIP_QCFindFirstOrThrowArgs>(args?: SelectSubset<T, WIP_QCFindFirstOrThrowArgs<ExtArgs>>): Prisma__WIP_QCClient<$Result.GetResult<Prisma.$WIP_QCPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more WIP_QCS that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WIP_QCFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all WIP_QCS
     * const wIP_QCS = await prisma.wIP_QC.findMany()
     * 
     * // Get first 10 WIP_QCS
     * const wIP_QCS = await prisma.wIP_QC.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const wIP_QCWithIdOnly = await prisma.wIP_QC.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends WIP_QCFindManyArgs>(args?: SelectSubset<T, WIP_QCFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WIP_QCPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a WIP_QC.
     * @param {WIP_QCCreateArgs} args - Arguments to create a WIP_QC.
     * @example
     * // Create one WIP_QC
     * const WIP_QC = await prisma.wIP_QC.create({
     *   data: {
     *     // ... data to create a WIP_QC
     *   }
     * })
     * 
     */
    create<T extends WIP_QCCreateArgs>(args: SelectSubset<T, WIP_QCCreateArgs<ExtArgs>>): Prisma__WIP_QCClient<$Result.GetResult<Prisma.$WIP_QCPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many WIP_QCS.
     * @param {WIP_QCCreateManyArgs} args - Arguments to create many WIP_QCS.
     * @example
     * // Create many WIP_QCS
     * const wIP_QC = await prisma.wIP_QC.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WIP_QCCreateManyArgs>(args?: SelectSubset<T, WIP_QCCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a WIP_QC.
     * @param {WIP_QCDeleteArgs} args - Arguments to delete one WIP_QC.
     * @example
     * // Delete one WIP_QC
     * const WIP_QC = await prisma.wIP_QC.delete({
     *   where: {
     *     // ... filter to delete one WIP_QC
     *   }
     * })
     * 
     */
    delete<T extends WIP_QCDeleteArgs>(args: SelectSubset<T, WIP_QCDeleteArgs<ExtArgs>>): Prisma__WIP_QCClient<$Result.GetResult<Prisma.$WIP_QCPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one WIP_QC.
     * @param {WIP_QCUpdateArgs} args - Arguments to update one WIP_QC.
     * @example
     * // Update one WIP_QC
     * const wIP_QC = await prisma.wIP_QC.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WIP_QCUpdateArgs>(args: SelectSubset<T, WIP_QCUpdateArgs<ExtArgs>>): Prisma__WIP_QCClient<$Result.GetResult<Prisma.$WIP_QCPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more WIP_QCS.
     * @param {WIP_QCDeleteManyArgs} args - Arguments to filter WIP_QCS to delete.
     * @example
     * // Delete a few WIP_QCS
     * const { count } = await prisma.wIP_QC.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WIP_QCDeleteManyArgs>(args?: SelectSubset<T, WIP_QCDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WIP_QCS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WIP_QCUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many WIP_QCS
     * const wIP_QC = await prisma.wIP_QC.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WIP_QCUpdateManyArgs>(args: SelectSubset<T, WIP_QCUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one WIP_QC.
     * @param {WIP_QCUpsertArgs} args - Arguments to update or create a WIP_QC.
     * @example
     * // Update or create a WIP_QC
     * const wIP_QC = await prisma.wIP_QC.upsert({
     *   create: {
     *     // ... data to create a WIP_QC
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the WIP_QC we want to update
     *   }
     * })
     */
    upsert<T extends WIP_QCUpsertArgs>(args: SelectSubset<T, WIP_QCUpsertArgs<ExtArgs>>): Prisma__WIP_QCClient<$Result.GetResult<Prisma.$WIP_QCPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of WIP_QCS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WIP_QCCountArgs} args - Arguments to filter WIP_QCS to count.
     * @example
     * // Count the number of WIP_QCS
     * const count = await prisma.wIP_QC.count({
     *   where: {
     *     // ... the filter for the WIP_QCS we want to count
     *   }
     * })
    **/
    count<T extends WIP_QCCountArgs>(
      args?: Subset<T, WIP_QCCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WIP_QCCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a WIP_QC.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WIP_QCAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WIP_QCAggregateArgs>(args: Subset<T, WIP_QCAggregateArgs>): Prisma.PrismaPromise<GetWIP_QCAggregateType<T>>

    /**
     * Group by WIP_QC.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WIP_QCGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WIP_QCGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WIP_QCGroupByArgs['orderBy'] }
        : { orderBy?: WIP_QCGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WIP_QCGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWIP_QCGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the WIP_QC model
   */
  readonly fields: WIP_QCFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for WIP_QC.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WIP_QCClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    wip<T extends WIPDefaultArgs<ExtArgs> = {}>(args?: Subset<T, WIPDefaultArgs<ExtArgs>>): Prisma__WIPClient<$Result.GetResult<Prisma.$WIPPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    WIPTransactions<T extends WIP_TRANSACTIONSDefaultArgs<ExtArgs> = {}>(args?: Subset<T, WIP_TRANSACTIONSDefaultArgs<ExtArgs>>): Prisma__WIP_TRANSACTIONSClient<$Result.GetResult<Prisma.$WIP_TRANSACTIONSPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the WIP_QC model
   */ 
  interface WIP_QCFieldRefs {
    readonly id: FieldRef<"WIP_QC", 'Int'>
    readonly transactionId: FieldRef<"WIP_QC", 'Int'>
    readonly transactionType: FieldRef<"WIP_QC", 'TransactionType'>
    readonly wipId: FieldRef<"WIP_QC", 'Int'>
    readonly quality_status: FieldRef<"WIP_QC", 'QualityStatus'>
    readonly createdAt: FieldRef<"WIP_QC", 'DateTime'>
    readonly updatedAt: FieldRef<"WIP_QC", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * WIP_QC findUnique
   */
  export type WIP_QCFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WIP_QC
     */
    select?: WIP_QCSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WIP_QC
     */
    omit?: WIP_QCOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WIP_QCInclude<ExtArgs> | null
    /**
     * Filter, which WIP_QC to fetch.
     */
    where: WIP_QCWhereUniqueInput
  }

  /**
   * WIP_QC findUniqueOrThrow
   */
  export type WIP_QCFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WIP_QC
     */
    select?: WIP_QCSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WIP_QC
     */
    omit?: WIP_QCOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WIP_QCInclude<ExtArgs> | null
    /**
     * Filter, which WIP_QC to fetch.
     */
    where: WIP_QCWhereUniqueInput
  }

  /**
   * WIP_QC findFirst
   */
  export type WIP_QCFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WIP_QC
     */
    select?: WIP_QCSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WIP_QC
     */
    omit?: WIP_QCOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WIP_QCInclude<ExtArgs> | null
    /**
     * Filter, which WIP_QC to fetch.
     */
    where?: WIP_QCWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WIP_QCS to fetch.
     */
    orderBy?: WIP_QCOrderByWithRelationInput | WIP_QCOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WIP_QCS.
     */
    cursor?: WIP_QCWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WIP_QCS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WIP_QCS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WIP_QCS.
     */
    distinct?: WIP_QCScalarFieldEnum | WIP_QCScalarFieldEnum[]
  }

  /**
   * WIP_QC findFirstOrThrow
   */
  export type WIP_QCFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WIP_QC
     */
    select?: WIP_QCSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WIP_QC
     */
    omit?: WIP_QCOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WIP_QCInclude<ExtArgs> | null
    /**
     * Filter, which WIP_QC to fetch.
     */
    where?: WIP_QCWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WIP_QCS to fetch.
     */
    orderBy?: WIP_QCOrderByWithRelationInput | WIP_QCOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WIP_QCS.
     */
    cursor?: WIP_QCWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WIP_QCS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WIP_QCS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WIP_QCS.
     */
    distinct?: WIP_QCScalarFieldEnum | WIP_QCScalarFieldEnum[]
  }

  /**
   * WIP_QC findMany
   */
  export type WIP_QCFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WIP_QC
     */
    select?: WIP_QCSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WIP_QC
     */
    omit?: WIP_QCOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WIP_QCInclude<ExtArgs> | null
    /**
     * Filter, which WIP_QCS to fetch.
     */
    where?: WIP_QCWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WIP_QCS to fetch.
     */
    orderBy?: WIP_QCOrderByWithRelationInput | WIP_QCOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing WIP_QCS.
     */
    cursor?: WIP_QCWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WIP_QCS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WIP_QCS.
     */
    skip?: number
    distinct?: WIP_QCScalarFieldEnum | WIP_QCScalarFieldEnum[]
  }

  /**
   * WIP_QC create
   */
  export type WIP_QCCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WIP_QC
     */
    select?: WIP_QCSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WIP_QC
     */
    omit?: WIP_QCOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WIP_QCInclude<ExtArgs> | null
    /**
     * The data needed to create a WIP_QC.
     */
    data: XOR<WIP_QCCreateInput, WIP_QCUncheckedCreateInput>
  }

  /**
   * WIP_QC createMany
   */
  export type WIP_QCCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many WIP_QCS.
     */
    data: WIP_QCCreateManyInput | WIP_QCCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * WIP_QC update
   */
  export type WIP_QCUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WIP_QC
     */
    select?: WIP_QCSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WIP_QC
     */
    omit?: WIP_QCOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WIP_QCInclude<ExtArgs> | null
    /**
     * The data needed to update a WIP_QC.
     */
    data: XOR<WIP_QCUpdateInput, WIP_QCUncheckedUpdateInput>
    /**
     * Choose, which WIP_QC to update.
     */
    where: WIP_QCWhereUniqueInput
  }

  /**
   * WIP_QC updateMany
   */
  export type WIP_QCUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update WIP_QCS.
     */
    data: XOR<WIP_QCUpdateManyMutationInput, WIP_QCUncheckedUpdateManyInput>
    /**
     * Filter which WIP_QCS to update
     */
    where?: WIP_QCWhereInput
  }

  /**
   * WIP_QC upsert
   */
  export type WIP_QCUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WIP_QC
     */
    select?: WIP_QCSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WIP_QC
     */
    omit?: WIP_QCOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WIP_QCInclude<ExtArgs> | null
    /**
     * The filter to search for the WIP_QC to update in case it exists.
     */
    where: WIP_QCWhereUniqueInput
    /**
     * In case the WIP_QC found by the `where` argument doesn't exist, create a new WIP_QC with this data.
     */
    create: XOR<WIP_QCCreateInput, WIP_QCUncheckedCreateInput>
    /**
     * In case the WIP_QC was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WIP_QCUpdateInput, WIP_QCUncheckedUpdateInput>
  }

  /**
   * WIP_QC delete
   */
  export type WIP_QCDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WIP_QC
     */
    select?: WIP_QCSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WIP_QC
     */
    omit?: WIP_QCOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WIP_QCInclude<ExtArgs> | null
    /**
     * Filter which WIP_QC to delete.
     */
    where: WIP_QCWhereUniqueInput
  }

  /**
   * WIP_QC deleteMany
   */
  export type WIP_QCDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WIP_QCS to delete
     */
    where?: WIP_QCWhereInput
  }

  /**
   * WIP_QC without action
   */
  export type WIP_QCDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WIP_QC
     */
    select?: WIP_QCSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WIP_QC
     */
    omit?: WIP_QCOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WIP_QCInclude<ExtArgs> | null
  }


  /**
   * Model FG_QC
   */

  export type AggregateFG_QC = {
    _count: FG_QCCountAggregateOutputType | null
    _avg: FG_QCAvgAggregateOutputType | null
    _sum: FG_QCSumAggregateOutputType | null
    _min: FG_QCMinAggregateOutputType | null
    _max: FG_QCMaxAggregateOutputType | null
  }

  export type FG_QCAvgAggregateOutputType = {
    id: number | null
    transactionId: number | null
    fgId: number | null
  }

  export type FG_QCSumAggregateOutputType = {
    id: number | null
    transactionId: number | null
    fgId: number | null
  }

  export type FG_QCMinAggregateOutputType = {
    id: number | null
    transactionId: number | null
    transactionType: $Enums.TransactionType | null
    fgId: number | null
    quality_status: $Enums.QualityStatus | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FG_QCMaxAggregateOutputType = {
    id: number | null
    transactionId: number | null
    transactionType: $Enums.TransactionType | null
    fgId: number | null
    quality_status: $Enums.QualityStatus | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FG_QCCountAggregateOutputType = {
    id: number
    transactionId: number
    transactionType: number
    fgId: number
    quality_status: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type FG_QCAvgAggregateInputType = {
    id?: true
    transactionId?: true
    fgId?: true
  }

  export type FG_QCSumAggregateInputType = {
    id?: true
    transactionId?: true
    fgId?: true
  }

  export type FG_QCMinAggregateInputType = {
    id?: true
    transactionId?: true
    transactionType?: true
    fgId?: true
    quality_status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FG_QCMaxAggregateInputType = {
    id?: true
    transactionId?: true
    transactionType?: true
    fgId?: true
    quality_status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FG_QCCountAggregateInputType = {
    id?: true
    transactionId?: true
    transactionType?: true
    fgId?: true
    quality_status?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type FG_QCAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FG_QC to aggregate.
     */
    where?: FG_QCWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FG_QCS to fetch.
     */
    orderBy?: FG_QCOrderByWithRelationInput | FG_QCOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FG_QCWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FG_QCS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FG_QCS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FG_QCS
    **/
    _count?: true | FG_QCCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FG_QCAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FG_QCSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FG_QCMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FG_QCMaxAggregateInputType
  }

  export type GetFG_QCAggregateType<T extends FG_QCAggregateArgs> = {
        [P in keyof T & keyof AggregateFG_QC]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFG_QC[P]>
      : GetScalarType<T[P], AggregateFG_QC[P]>
  }




  export type FG_QCGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FG_QCWhereInput
    orderBy?: FG_QCOrderByWithAggregationInput | FG_QCOrderByWithAggregationInput[]
    by: FG_QCScalarFieldEnum[] | FG_QCScalarFieldEnum
    having?: FG_QCScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FG_QCCountAggregateInputType | true
    _avg?: FG_QCAvgAggregateInputType
    _sum?: FG_QCSumAggregateInputType
    _min?: FG_QCMinAggregateInputType
    _max?: FG_QCMaxAggregateInputType
  }

  export type FG_QCGroupByOutputType = {
    id: number
    transactionId: number
    transactionType: $Enums.TransactionType
    fgId: number
    quality_status: $Enums.QualityStatus
    createdAt: Date
    updatedAt: Date
    _count: FG_QCCountAggregateOutputType | null
    _avg: FG_QCAvgAggregateOutputType | null
    _sum: FG_QCSumAggregateOutputType | null
    _min: FG_QCMinAggregateOutputType | null
    _max: FG_QCMaxAggregateOutputType | null
  }

  type GetFG_QCGroupByPayload<T extends FG_QCGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FG_QCGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FG_QCGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FG_QCGroupByOutputType[P]>
            : GetScalarType<T[P], FG_QCGroupByOutputType[P]>
        }
      >
    >


  export type FG_QCSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    transactionId?: boolean
    transactionType?: boolean
    fgId?: boolean
    quality_status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    fg?: boolean | FGDefaultArgs<ExtArgs>
    FGTransactions?: boolean | FG_TRANSACTIONSDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["fG_QC"]>



  export type FG_QCSelectScalar = {
    id?: boolean
    transactionId?: boolean
    transactionType?: boolean
    fgId?: boolean
    quality_status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type FG_QCOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "transactionId" | "transactionType" | "fgId" | "quality_status" | "createdAt" | "updatedAt", ExtArgs["result"]["fG_QC"]>
  export type FG_QCInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    fg?: boolean | FGDefaultArgs<ExtArgs>
    FGTransactions?: boolean | FG_TRANSACTIONSDefaultArgs<ExtArgs>
  }

  export type $FG_QCPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "FG_QC"
    objects: {
      fg: Prisma.$FGPayload<ExtArgs>
      FGTransactions: Prisma.$FG_TRANSACTIONSPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      transactionId: number
      transactionType: $Enums.TransactionType
      fgId: number
      quality_status: $Enums.QualityStatus
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["fG_QC"]>
    composites: {}
  }

  type FG_QCGetPayload<S extends boolean | null | undefined | FG_QCDefaultArgs> = $Result.GetResult<Prisma.$FG_QCPayload, S>

  type FG_QCCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<FG_QCFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FG_QCCountAggregateInputType | true
    }

  export interface FG_QCDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['FG_QC'], meta: { name: 'FG_QC' } }
    /**
     * Find zero or one FG_QC that matches the filter.
     * @param {FG_QCFindUniqueArgs} args - Arguments to find a FG_QC
     * @example
     * // Get one FG_QC
     * const fG_QC = await prisma.fG_QC.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FG_QCFindUniqueArgs>(args: SelectSubset<T, FG_QCFindUniqueArgs<ExtArgs>>): Prisma__FG_QCClient<$Result.GetResult<Prisma.$FG_QCPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one FG_QC that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FG_QCFindUniqueOrThrowArgs} args - Arguments to find a FG_QC
     * @example
     * // Get one FG_QC
     * const fG_QC = await prisma.fG_QC.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FG_QCFindUniqueOrThrowArgs>(args: SelectSubset<T, FG_QCFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FG_QCClient<$Result.GetResult<Prisma.$FG_QCPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first FG_QC that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FG_QCFindFirstArgs} args - Arguments to find a FG_QC
     * @example
     * // Get one FG_QC
     * const fG_QC = await prisma.fG_QC.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FG_QCFindFirstArgs>(args?: SelectSubset<T, FG_QCFindFirstArgs<ExtArgs>>): Prisma__FG_QCClient<$Result.GetResult<Prisma.$FG_QCPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first FG_QC that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FG_QCFindFirstOrThrowArgs} args - Arguments to find a FG_QC
     * @example
     * // Get one FG_QC
     * const fG_QC = await prisma.fG_QC.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FG_QCFindFirstOrThrowArgs>(args?: SelectSubset<T, FG_QCFindFirstOrThrowArgs<ExtArgs>>): Prisma__FG_QCClient<$Result.GetResult<Prisma.$FG_QCPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more FG_QCS that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FG_QCFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FG_QCS
     * const fG_QCS = await prisma.fG_QC.findMany()
     * 
     * // Get first 10 FG_QCS
     * const fG_QCS = await prisma.fG_QC.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const fG_QCWithIdOnly = await prisma.fG_QC.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FG_QCFindManyArgs>(args?: SelectSubset<T, FG_QCFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FG_QCPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a FG_QC.
     * @param {FG_QCCreateArgs} args - Arguments to create a FG_QC.
     * @example
     * // Create one FG_QC
     * const FG_QC = await prisma.fG_QC.create({
     *   data: {
     *     // ... data to create a FG_QC
     *   }
     * })
     * 
     */
    create<T extends FG_QCCreateArgs>(args: SelectSubset<T, FG_QCCreateArgs<ExtArgs>>): Prisma__FG_QCClient<$Result.GetResult<Prisma.$FG_QCPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many FG_QCS.
     * @param {FG_QCCreateManyArgs} args - Arguments to create many FG_QCS.
     * @example
     * // Create many FG_QCS
     * const fG_QC = await prisma.fG_QC.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FG_QCCreateManyArgs>(args?: SelectSubset<T, FG_QCCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a FG_QC.
     * @param {FG_QCDeleteArgs} args - Arguments to delete one FG_QC.
     * @example
     * // Delete one FG_QC
     * const FG_QC = await prisma.fG_QC.delete({
     *   where: {
     *     // ... filter to delete one FG_QC
     *   }
     * })
     * 
     */
    delete<T extends FG_QCDeleteArgs>(args: SelectSubset<T, FG_QCDeleteArgs<ExtArgs>>): Prisma__FG_QCClient<$Result.GetResult<Prisma.$FG_QCPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one FG_QC.
     * @param {FG_QCUpdateArgs} args - Arguments to update one FG_QC.
     * @example
     * // Update one FG_QC
     * const fG_QC = await prisma.fG_QC.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FG_QCUpdateArgs>(args: SelectSubset<T, FG_QCUpdateArgs<ExtArgs>>): Prisma__FG_QCClient<$Result.GetResult<Prisma.$FG_QCPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more FG_QCS.
     * @param {FG_QCDeleteManyArgs} args - Arguments to filter FG_QCS to delete.
     * @example
     * // Delete a few FG_QCS
     * const { count } = await prisma.fG_QC.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FG_QCDeleteManyArgs>(args?: SelectSubset<T, FG_QCDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FG_QCS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FG_QCUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FG_QCS
     * const fG_QC = await prisma.fG_QC.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FG_QCUpdateManyArgs>(args: SelectSubset<T, FG_QCUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one FG_QC.
     * @param {FG_QCUpsertArgs} args - Arguments to update or create a FG_QC.
     * @example
     * // Update or create a FG_QC
     * const fG_QC = await prisma.fG_QC.upsert({
     *   create: {
     *     // ... data to create a FG_QC
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FG_QC we want to update
     *   }
     * })
     */
    upsert<T extends FG_QCUpsertArgs>(args: SelectSubset<T, FG_QCUpsertArgs<ExtArgs>>): Prisma__FG_QCClient<$Result.GetResult<Prisma.$FG_QCPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of FG_QCS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FG_QCCountArgs} args - Arguments to filter FG_QCS to count.
     * @example
     * // Count the number of FG_QCS
     * const count = await prisma.fG_QC.count({
     *   where: {
     *     // ... the filter for the FG_QCS we want to count
     *   }
     * })
    **/
    count<T extends FG_QCCountArgs>(
      args?: Subset<T, FG_QCCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FG_QCCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FG_QC.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FG_QCAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FG_QCAggregateArgs>(args: Subset<T, FG_QCAggregateArgs>): Prisma.PrismaPromise<GetFG_QCAggregateType<T>>

    /**
     * Group by FG_QC.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FG_QCGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FG_QCGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FG_QCGroupByArgs['orderBy'] }
        : { orderBy?: FG_QCGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FG_QCGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFG_QCGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the FG_QC model
   */
  readonly fields: FG_QCFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for FG_QC.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FG_QCClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    fg<T extends FGDefaultArgs<ExtArgs> = {}>(args?: Subset<T, FGDefaultArgs<ExtArgs>>): Prisma__FGClient<$Result.GetResult<Prisma.$FGPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    FGTransactions<T extends FG_TRANSACTIONSDefaultArgs<ExtArgs> = {}>(args?: Subset<T, FG_TRANSACTIONSDefaultArgs<ExtArgs>>): Prisma__FG_TRANSACTIONSClient<$Result.GetResult<Prisma.$FG_TRANSACTIONSPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the FG_QC model
   */ 
  interface FG_QCFieldRefs {
    readonly id: FieldRef<"FG_QC", 'Int'>
    readonly transactionId: FieldRef<"FG_QC", 'Int'>
    readonly transactionType: FieldRef<"FG_QC", 'TransactionType'>
    readonly fgId: FieldRef<"FG_QC", 'Int'>
    readonly quality_status: FieldRef<"FG_QC", 'QualityStatus'>
    readonly createdAt: FieldRef<"FG_QC", 'DateTime'>
    readonly updatedAt: FieldRef<"FG_QC", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * FG_QC findUnique
   */
  export type FG_QCFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FG_QC
     */
    select?: FG_QCSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FG_QC
     */
    omit?: FG_QCOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FG_QCInclude<ExtArgs> | null
    /**
     * Filter, which FG_QC to fetch.
     */
    where: FG_QCWhereUniqueInput
  }

  /**
   * FG_QC findUniqueOrThrow
   */
  export type FG_QCFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FG_QC
     */
    select?: FG_QCSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FG_QC
     */
    omit?: FG_QCOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FG_QCInclude<ExtArgs> | null
    /**
     * Filter, which FG_QC to fetch.
     */
    where: FG_QCWhereUniqueInput
  }

  /**
   * FG_QC findFirst
   */
  export type FG_QCFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FG_QC
     */
    select?: FG_QCSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FG_QC
     */
    omit?: FG_QCOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FG_QCInclude<ExtArgs> | null
    /**
     * Filter, which FG_QC to fetch.
     */
    where?: FG_QCWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FG_QCS to fetch.
     */
    orderBy?: FG_QCOrderByWithRelationInput | FG_QCOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FG_QCS.
     */
    cursor?: FG_QCWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FG_QCS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FG_QCS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FG_QCS.
     */
    distinct?: FG_QCScalarFieldEnum | FG_QCScalarFieldEnum[]
  }

  /**
   * FG_QC findFirstOrThrow
   */
  export type FG_QCFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FG_QC
     */
    select?: FG_QCSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FG_QC
     */
    omit?: FG_QCOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FG_QCInclude<ExtArgs> | null
    /**
     * Filter, which FG_QC to fetch.
     */
    where?: FG_QCWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FG_QCS to fetch.
     */
    orderBy?: FG_QCOrderByWithRelationInput | FG_QCOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FG_QCS.
     */
    cursor?: FG_QCWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FG_QCS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FG_QCS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FG_QCS.
     */
    distinct?: FG_QCScalarFieldEnum | FG_QCScalarFieldEnum[]
  }

  /**
   * FG_QC findMany
   */
  export type FG_QCFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FG_QC
     */
    select?: FG_QCSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FG_QC
     */
    omit?: FG_QCOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FG_QCInclude<ExtArgs> | null
    /**
     * Filter, which FG_QCS to fetch.
     */
    where?: FG_QCWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FG_QCS to fetch.
     */
    orderBy?: FG_QCOrderByWithRelationInput | FG_QCOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FG_QCS.
     */
    cursor?: FG_QCWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FG_QCS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FG_QCS.
     */
    skip?: number
    distinct?: FG_QCScalarFieldEnum | FG_QCScalarFieldEnum[]
  }

  /**
   * FG_QC create
   */
  export type FG_QCCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FG_QC
     */
    select?: FG_QCSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FG_QC
     */
    omit?: FG_QCOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FG_QCInclude<ExtArgs> | null
    /**
     * The data needed to create a FG_QC.
     */
    data: XOR<FG_QCCreateInput, FG_QCUncheckedCreateInput>
  }

  /**
   * FG_QC createMany
   */
  export type FG_QCCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many FG_QCS.
     */
    data: FG_QCCreateManyInput | FG_QCCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * FG_QC update
   */
  export type FG_QCUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FG_QC
     */
    select?: FG_QCSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FG_QC
     */
    omit?: FG_QCOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FG_QCInclude<ExtArgs> | null
    /**
     * The data needed to update a FG_QC.
     */
    data: XOR<FG_QCUpdateInput, FG_QCUncheckedUpdateInput>
    /**
     * Choose, which FG_QC to update.
     */
    where: FG_QCWhereUniqueInput
  }

  /**
   * FG_QC updateMany
   */
  export type FG_QCUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update FG_QCS.
     */
    data: XOR<FG_QCUpdateManyMutationInput, FG_QCUncheckedUpdateManyInput>
    /**
     * Filter which FG_QCS to update
     */
    where?: FG_QCWhereInput
  }

  /**
   * FG_QC upsert
   */
  export type FG_QCUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FG_QC
     */
    select?: FG_QCSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FG_QC
     */
    omit?: FG_QCOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FG_QCInclude<ExtArgs> | null
    /**
     * The filter to search for the FG_QC to update in case it exists.
     */
    where: FG_QCWhereUniqueInput
    /**
     * In case the FG_QC found by the `where` argument doesn't exist, create a new FG_QC with this data.
     */
    create: XOR<FG_QCCreateInput, FG_QCUncheckedCreateInput>
    /**
     * In case the FG_QC was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FG_QCUpdateInput, FG_QCUncheckedUpdateInput>
  }

  /**
   * FG_QC delete
   */
  export type FG_QCDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FG_QC
     */
    select?: FG_QCSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FG_QC
     */
    omit?: FG_QCOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FG_QCInclude<ExtArgs> | null
    /**
     * Filter which FG_QC to delete.
     */
    where: FG_QCWhereUniqueInput
  }

  /**
   * FG_QC deleteMany
   */
  export type FG_QCDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FG_QCS to delete
     */
    where?: FG_QCWhereInput
  }

  /**
   * FG_QC without action
   */
  export type FG_QCDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FG_QC
     */
    select?: FG_QCSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FG_QC
     */
    omit?: FG_QCOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FG_QCInclude<ExtArgs> | null
  }


  /**
   * Model WIP_WASTAGE_LOGS
   */

  export type AggregateWIP_WASTAGE_LOGS = {
    _count: WIP_WASTAGE_LOGSCountAggregateOutputType | null
    _avg: WIP_WASTAGE_LOGSAvgAggregateOutputType | null
    _sum: WIP_WASTAGE_LOGSSumAggregateOutputType | null
    _min: WIP_WASTAGE_LOGSMinAggregateOutputType | null
    _max: WIP_WASTAGE_LOGSMaxAggregateOutputType | null
  }

  export type WIP_WASTAGE_LOGSAvgAggregateOutputType = {
    id: number | null
    transactionId: number | null
    wipId: number | null
    quantity: number | null
  }

  export type WIP_WASTAGE_LOGSSumAggregateOutputType = {
    id: number | null
    transactionId: number | null
    wipId: number | null
    quantity: number | null
  }

  export type WIP_WASTAGE_LOGSMinAggregateOutputType = {
    id: number | null
    transactionId: number | null
    transactionType: $Enums.TransactionType | null
    wipId: number | null
    quantity: number | null
    reason: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type WIP_WASTAGE_LOGSMaxAggregateOutputType = {
    id: number | null
    transactionId: number | null
    transactionType: $Enums.TransactionType | null
    wipId: number | null
    quantity: number | null
    reason: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type WIP_WASTAGE_LOGSCountAggregateOutputType = {
    id: number
    transactionId: number
    transactionType: number
    wipId: number
    quantity: number
    reason: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type WIP_WASTAGE_LOGSAvgAggregateInputType = {
    id?: true
    transactionId?: true
    wipId?: true
    quantity?: true
  }

  export type WIP_WASTAGE_LOGSSumAggregateInputType = {
    id?: true
    transactionId?: true
    wipId?: true
    quantity?: true
  }

  export type WIP_WASTAGE_LOGSMinAggregateInputType = {
    id?: true
    transactionId?: true
    transactionType?: true
    wipId?: true
    quantity?: true
    reason?: true
    createdAt?: true
    updatedAt?: true
  }

  export type WIP_WASTAGE_LOGSMaxAggregateInputType = {
    id?: true
    transactionId?: true
    transactionType?: true
    wipId?: true
    quantity?: true
    reason?: true
    createdAt?: true
    updatedAt?: true
  }

  export type WIP_WASTAGE_LOGSCountAggregateInputType = {
    id?: true
    transactionId?: true
    transactionType?: true
    wipId?: true
    quantity?: true
    reason?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type WIP_WASTAGE_LOGSAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WIP_WASTAGE_LOGS to aggregate.
     */
    where?: WIP_WASTAGE_LOGSWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WIP_WASTAGE_LOGS to fetch.
     */
    orderBy?: WIP_WASTAGE_LOGSOrderByWithRelationInput | WIP_WASTAGE_LOGSOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WIP_WASTAGE_LOGSWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WIP_WASTAGE_LOGS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WIP_WASTAGE_LOGS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned WIP_WASTAGE_LOGS
    **/
    _count?: true | WIP_WASTAGE_LOGSCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: WIP_WASTAGE_LOGSAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: WIP_WASTAGE_LOGSSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WIP_WASTAGE_LOGSMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WIP_WASTAGE_LOGSMaxAggregateInputType
  }

  export type GetWIP_WASTAGE_LOGSAggregateType<T extends WIP_WASTAGE_LOGSAggregateArgs> = {
        [P in keyof T & keyof AggregateWIP_WASTAGE_LOGS]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWIP_WASTAGE_LOGS[P]>
      : GetScalarType<T[P], AggregateWIP_WASTAGE_LOGS[P]>
  }




  export type WIP_WASTAGE_LOGSGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WIP_WASTAGE_LOGSWhereInput
    orderBy?: WIP_WASTAGE_LOGSOrderByWithAggregationInput | WIP_WASTAGE_LOGSOrderByWithAggregationInput[]
    by: WIP_WASTAGE_LOGSScalarFieldEnum[] | WIP_WASTAGE_LOGSScalarFieldEnum
    having?: WIP_WASTAGE_LOGSScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WIP_WASTAGE_LOGSCountAggregateInputType | true
    _avg?: WIP_WASTAGE_LOGSAvgAggregateInputType
    _sum?: WIP_WASTAGE_LOGSSumAggregateInputType
    _min?: WIP_WASTAGE_LOGSMinAggregateInputType
    _max?: WIP_WASTAGE_LOGSMaxAggregateInputType
  }

  export type WIP_WASTAGE_LOGSGroupByOutputType = {
    id: number
    transactionId: number
    transactionType: $Enums.TransactionType
    wipId: number
    quantity: number
    reason: string
    createdAt: Date
    updatedAt: Date
    _count: WIP_WASTAGE_LOGSCountAggregateOutputType | null
    _avg: WIP_WASTAGE_LOGSAvgAggregateOutputType | null
    _sum: WIP_WASTAGE_LOGSSumAggregateOutputType | null
    _min: WIP_WASTAGE_LOGSMinAggregateOutputType | null
    _max: WIP_WASTAGE_LOGSMaxAggregateOutputType | null
  }

  type GetWIP_WASTAGE_LOGSGroupByPayload<T extends WIP_WASTAGE_LOGSGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WIP_WASTAGE_LOGSGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WIP_WASTAGE_LOGSGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WIP_WASTAGE_LOGSGroupByOutputType[P]>
            : GetScalarType<T[P], WIP_WASTAGE_LOGSGroupByOutputType[P]>
        }
      >
    >


  export type WIP_WASTAGE_LOGSSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    transactionId?: boolean
    transactionType?: boolean
    wipId?: boolean
    quantity?: boolean
    reason?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    wip?: boolean | WIPDefaultArgs<ExtArgs>
    WIPTransactions?: boolean | WIP_TRANSACTIONSDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["wIP_WASTAGE_LOGS"]>



  export type WIP_WASTAGE_LOGSSelectScalar = {
    id?: boolean
    transactionId?: boolean
    transactionType?: boolean
    wipId?: boolean
    quantity?: boolean
    reason?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type WIP_WASTAGE_LOGSOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "transactionId" | "transactionType" | "wipId" | "quantity" | "reason" | "createdAt" | "updatedAt", ExtArgs["result"]["wIP_WASTAGE_LOGS"]>
  export type WIP_WASTAGE_LOGSInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    wip?: boolean | WIPDefaultArgs<ExtArgs>
    WIPTransactions?: boolean | WIP_TRANSACTIONSDefaultArgs<ExtArgs>
  }

  export type $WIP_WASTAGE_LOGSPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "WIP_WASTAGE_LOGS"
    objects: {
      wip: Prisma.$WIPPayload<ExtArgs>
      WIPTransactions: Prisma.$WIP_TRANSACTIONSPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      transactionId: number
      transactionType: $Enums.TransactionType
      wipId: number
      quantity: number
      reason: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["wIP_WASTAGE_LOGS"]>
    composites: {}
  }

  type WIP_WASTAGE_LOGSGetPayload<S extends boolean | null | undefined | WIP_WASTAGE_LOGSDefaultArgs> = $Result.GetResult<Prisma.$WIP_WASTAGE_LOGSPayload, S>

  type WIP_WASTAGE_LOGSCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<WIP_WASTAGE_LOGSFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: WIP_WASTAGE_LOGSCountAggregateInputType | true
    }

  export interface WIP_WASTAGE_LOGSDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['WIP_WASTAGE_LOGS'], meta: { name: 'WIP_WASTAGE_LOGS' } }
    /**
     * Find zero or one WIP_WASTAGE_LOGS that matches the filter.
     * @param {WIP_WASTAGE_LOGSFindUniqueArgs} args - Arguments to find a WIP_WASTAGE_LOGS
     * @example
     * // Get one WIP_WASTAGE_LOGS
     * const wIP_WASTAGE_LOGS = await prisma.wIP_WASTAGE_LOGS.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WIP_WASTAGE_LOGSFindUniqueArgs>(args: SelectSubset<T, WIP_WASTAGE_LOGSFindUniqueArgs<ExtArgs>>): Prisma__WIP_WASTAGE_LOGSClient<$Result.GetResult<Prisma.$WIP_WASTAGE_LOGSPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one WIP_WASTAGE_LOGS that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {WIP_WASTAGE_LOGSFindUniqueOrThrowArgs} args - Arguments to find a WIP_WASTAGE_LOGS
     * @example
     * // Get one WIP_WASTAGE_LOGS
     * const wIP_WASTAGE_LOGS = await prisma.wIP_WASTAGE_LOGS.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WIP_WASTAGE_LOGSFindUniqueOrThrowArgs>(args: SelectSubset<T, WIP_WASTAGE_LOGSFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WIP_WASTAGE_LOGSClient<$Result.GetResult<Prisma.$WIP_WASTAGE_LOGSPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first WIP_WASTAGE_LOGS that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WIP_WASTAGE_LOGSFindFirstArgs} args - Arguments to find a WIP_WASTAGE_LOGS
     * @example
     * // Get one WIP_WASTAGE_LOGS
     * const wIP_WASTAGE_LOGS = await prisma.wIP_WASTAGE_LOGS.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WIP_WASTAGE_LOGSFindFirstArgs>(args?: SelectSubset<T, WIP_WASTAGE_LOGSFindFirstArgs<ExtArgs>>): Prisma__WIP_WASTAGE_LOGSClient<$Result.GetResult<Prisma.$WIP_WASTAGE_LOGSPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first WIP_WASTAGE_LOGS that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WIP_WASTAGE_LOGSFindFirstOrThrowArgs} args - Arguments to find a WIP_WASTAGE_LOGS
     * @example
     * // Get one WIP_WASTAGE_LOGS
     * const wIP_WASTAGE_LOGS = await prisma.wIP_WASTAGE_LOGS.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WIP_WASTAGE_LOGSFindFirstOrThrowArgs>(args?: SelectSubset<T, WIP_WASTAGE_LOGSFindFirstOrThrowArgs<ExtArgs>>): Prisma__WIP_WASTAGE_LOGSClient<$Result.GetResult<Prisma.$WIP_WASTAGE_LOGSPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more WIP_WASTAGE_LOGS that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WIP_WASTAGE_LOGSFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all WIP_WASTAGE_LOGS
     * const wIP_WASTAGE_LOGS = await prisma.wIP_WASTAGE_LOGS.findMany()
     * 
     * // Get first 10 WIP_WASTAGE_LOGS
     * const wIP_WASTAGE_LOGS = await prisma.wIP_WASTAGE_LOGS.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const wIP_WASTAGE_LOGSWithIdOnly = await prisma.wIP_WASTAGE_LOGS.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends WIP_WASTAGE_LOGSFindManyArgs>(args?: SelectSubset<T, WIP_WASTAGE_LOGSFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WIP_WASTAGE_LOGSPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a WIP_WASTAGE_LOGS.
     * @param {WIP_WASTAGE_LOGSCreateArgs} args - Arguments to create a WIP_WASTAGE_LOGS.
     * @example
     * // Create one WIP_WASTAGE_LOGS
     * const WIP_WASTAGE_LOGS = await prisma.wIP_WASTAGE_LOGS.create({
     *   data: {
     *     // ... data to create a WIP_WASTAGE_LOGS
     *   }
     * })
     * 
     */
    create<T extends WIP_WASTAGE_LOGSCreateArgs>(args: SelectSubset<T, WIP_WASTAGE_LOGSCreateArgs<ExtArgs>>): Prisma__WIP_WASTAGE_LOGSClient<$Result.GetResult<Prisma.$WIP_WASTAGE_LOGSPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many WIP_WASTAGE_LOGS.
     * @param {WIP_WASTAGE_LOGSCreateManyArgs} args - Arguments to create many WIP_WASTAGE_LOGS.
     * @example
     * // Create many WIP_WASTAGE_LOGS
     * const wIP_WASTAGE_LOGS = await prisma.wIP_WASTAGE_LOGS.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WIP_WASTAGE_LOGSCreateManyArgs>(args?: SelectSubset<T, WIP_WASTAGE_LOGSCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a WIP_WASTAGE_LOGS.
     * @param {WIP_WASTAGE_LOGSDeleteArgs} args - Arguments to delete one WIP_WASTAGE_LOGS.
     * @example
     * // Delete one WIP_WASTAGE_LOGS
     * const WIP_WASTAGE_LOGS = await prisma.wIP_WASTAGE_LOGS.delete({
     *   where: {
     *     // ... filter to delete one WIP_WASTAGE_LOGS
     *   }
     * })
     * 
     */
    delete<T extends WIP_WASTAGE_LOGSDeleteArgs>(args: SelectSubset<T, WIP_WASTAGE_LOGSDeleteArgs<ExtArgs>>): Prisma__WIP_WASTAGE_LOGSClient<$Result.GetResult<Prisma.$WIP_WASTAGE_LOGSPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one WIP_WASTAGE_LOGS.
     * @param {WIP_WASTAGE_LOGSUpdateArgs} args - Arguments to update one WIP_WASTAGE_LOGS.
     * @example
     * // Update one WIP_WASTAGE_LOGS
     * const wIP_WASTAGE_LOGS = await prisma.wIP_WASTAGE_LOGS.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WIP_WASTAGE_LOGSUpdateArgs>(args: SelectSubset<T, WIP_WASTAGE_LOGSUpdateArgs<ExtArgs>>): Prisma__WIP_WASTAGE_LOGSClient<$Result.GetResult<Prisma.$WIP_WASTAGE_LOGSPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more WIP_WASTAGE_LOGS.
     * @param {WIP_WASTAGE_LOGSDeleteManyArgs} args - Arguments to filter WIP_WASTAGE_LOGS to delete.
     * @example
     * // Delete a few WIP_WASTAGE_LOGS
     * const { count } = await prisma.wIP_WASTAGE_LOGS.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WIP_WASTAGE_LOGSDeleteManyArgs>(args?: SelectSubset<T, WIP_WASTAGE_LOGSDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WIP_WASTAGE_LOGS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WIP_WASTAGE_LOGSUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many WIP_WASTAGE_LOGS
     * const wIP_WASTAGE_LOGS = await prisma.wIP_WASTAGE_LOGS.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WIP_WASTAGE_LOGSUpdateManyArgs>(args: SelectSubset<T, WIP_WASTAGE_LOGSUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one WIP_WASTAGE_LOGS.
     * @param {WIP_WASTAGE_LOGSUpsertArgs} args - Arguments to update or create a WIP_WASTAGE_LOGS.
     * @example
     * // Update or create a WIP_WASTAGE_LOGS
     * const wIP_WASTAGE_LOGS = await prisma.wIP_WASTAGE_LOGS.upsert({
     *   create: {
     *     // ... data to create a WIP_WASTAGE_LOGS
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the WIP_WASTAGE_LOGS we want to update
     *   }
     * })
     */
    upsert<T extends WIP_WASTAGE_LOGSUpsertArgs>(args: SelectSubset<T, WIP_WASTAGE_LOGSUpsertArgs<ExtArgs>>): Prisma__WIP_WASTAGE_LOGSClient<$Result.GetResult<Prisma.$WIP_WASTAGE_LOGSPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of WIP_WASTAGE_LOGS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WIP_WASTAGE_LOGSCountArgs} args - Arguments to filter WIP_WASTAGE_LOGS to count.
     * @example
     * // Count the number of WIP_WASTAGE_LOGS
     * const count = await prisma.wIP_WASTAGE_LOGS.count({
     *   where: {
     *     // ... the filter for the WIP_WASTAGE_LOGS we want to count
     *   }
     * })
    **/
    count<T extends WIP_WASTAGE_LOGSCountArgs>(
      args?: Subset<T, WIP_WASTAGE_LOGSCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WIP_WASTAGE_LOGSCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a WIP_WASTAGE_LOGS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WIP_WASTAGE_LOGSAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WIP_WASTAGE_LOGSAggregateArgs>(args: Subset<T, WIP_WASTAGE_LOGSAggregateArgs>): Prisma.PrismaPromise<GetWIP_WASTAGE_LOGSAggregateType<T>>

    /**
     * Group by WIP_WASTAGE_LOGS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WIP_WASTAGE_LOGSGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WIP_WASTAGE_LOGSGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WIP_WASTAGE_LOGSGroupByArgs['orderBy'] }
        : { orderBy?: WIP_WASTAGE_LOGSGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WIP_WASTAGE_LOGSGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWIP_WASTAGE_LOGSGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the WIP_WASTAGE_LOGS model
   */
  readonly fields: WIP_WASTAGE_LOGSFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for WIP_WASTAGE_LOGS.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WIP_WASTAGE_LOGSClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    wip<T extends WIPDefaultArgs<ExtArgs> = {}>(args?: Subset<T, WIPDefaultArgs<ExtArgs>>): Prisma__WIPClient<$Result.GetResult<Prisma.$WIPPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    WIPTransactions<T extends WIP_TRANSACTIONSDefaultArgs<ExtArgs> = {}>(args?: Subset<T, WIP_TRANSACTIONSDefaultArgs<ExtArgs>>): Prisma__WIP_TRANSACTIONSClient<$Result.GetResult<Prisma.$WIP_TRANSACTIONSPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the WIP_WASTAGE_LOGS model
   */ 
  interface WIP_WASTAGE_LOGSFieldRefs {
    readonly id: FieldRef<"WIP_WASTAGE_LOGS", 'Int'>
    readonly transactionId: FieldRef<"WIP_WASTAGE_LOGS", 'Int'>
    readonly transactionType: FieldRef<"WIP_WASTAGE_LOGS", 'TransactionType'>
    readonly wipId: FieldRef<"WIP_WASTAGE_LOGS", 'Int'>
    readonly quantity: FieldRef<"WIP_WASTAGE_LOGS", 'Int'>
    readonly reason: FieldRef<"WIP_WASTAGE_LOGS", 'String'>
    readonly createdAt: FieldRef<"WIP_WASTAGE_LOGS", 'DateTime'>
    readonly updatedAt: FieldRef<"WIP_WASTAGE_LOGS", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * WIP_WASTAGE_LOGS findUnique
   */
  export type WIP_WASTAGE_LOGSFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WIP_WASTAGE_LOGS
     */
    select?: WIP_WASTAGE_LOGSSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WIP_WASTAGE_LOGS
     */
    omit?: WIP_WASTAGE_LOGSOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WIP_WASTAGE_LOGSInclude<ExtArgs> | null
    /**
     * Filter, which WIP_WASTAGE_LOGS to fetch.
     */
    where: WIP_WASTAGE_LOGSWhereUniqueInput
  }

  /**
   * WIP_WASTAGE_LOGS findUniqueOrThrow
   */
  export type WIP_WASTAGE_LOGSFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WIP_WASTAGE_LOGS
     */
    select?: WIP_WASTAGE_LOGSSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WIP_WASTAGE_LOGS
     */
    omit?: WIP_WASTAGE_LOGSOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WIP_WASTAGE_LOGSInclude<ExtArgs> | null
    /**
     * Filter, which WIP_WASTAGE_LOGS to fetch.
     */
    where: WIP_WASTAGE_LOGSWhereUniqueInput
  }

  /**
   * WIP_WASTAGE_LOGS findFirst
   */
  export type WIP_WASTAGE_LOGSFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WIP_WASTAGE_LOGS
     */
    select?: WIP_WASTAGE_LOGSSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WIP_WASTAGE_LOGS
     */
    omit?: WIP_WASTAGE_LOGSOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WIP_WASTAGE_LOGSInclude<ExtArgs> | null
    /**
     * Filter, which WIP_WASTAGE_LOGS to fetch.
     */
    where?: WIP_WASTAGE_LOGSWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WIP_WASTAGE_LOGS to fetch.
     */
    orderBy?: WIP_WASTAGE_LOGSOrderByWithRelationInput | WIP_WASTAGE_LOGSOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WIP_WASTAGE_LOGS.
     */
    cursor?: WIP_WASTAGE_LOGSWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WIP_WASTAGE_LOGS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WIP_WASTAGE_LOGS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WIP_WASTAGE_LOGS.
     */
    distinct?: WIP_WASTAGE_LOGSScalarFieldEnum | WIP_WASTAGE_LOGSScalarFieldEnum[]
  }

  /**
   * WIP_WASTAGE_LOGS findFirstOrThrow
   */
  export type WIP_WASTAGE_LOGSFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WIP_WASTAGE_LOGS
     */
    select?: WIP_WASTAGE_LOGSSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WIP_WASTAGE_LOGS
     */
    omit?: WIP_WASTAGE_LOGSOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WIP_WASTAGE_LOGSInclude<ExtArgs> | null
    /**
     * Filter, which WIP_WASTAGE_LOGS to fetch.
     */
    where?: WIP_WASTAGE_LOGSWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WIP_WASTAGE_LOGS to fetch.
     */
    orderBy?: WIP_WASTAGE_LOGSOrderByWithRelationInput | WIP_WASTAGE_LOGSOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WIP_WASTAGE_LOGS.
     */
    cursor?: WIP_WASTAGE_LOGSWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WIP_WASTAGE_LOGS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WIP_WASTAGE_LOGS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WIP_WASTAGE_LOGS.
     */
    distinct?: WIP_WASTAGE_LOGSScalarFieldEnum | WIP_WASTAGE_LOGSScalarFieldEnum[]
  }

  /**
   * WIP_WASTAGE_LOGS findMany
   */
  export type WIP_WASTAGE_LOGSFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WIP_WASTAGE_LOGS
     */
    select?: WIP_WASTAGE_LOGSSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WIP_WASTAGE_LOGS
     */
    omit?: WIP_WASTAGE_LOGSOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WIP_WASTAGE_LOGSInclude<ExtArgs> | null
    /**
     * Filter, which WIP_WASTAGE_LOGS to fetch.
     */
    where?: WIP_WASTAGE_LOGSWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WIP_WASTAGE_LOGS to fetch.
     */
    orderBy?: WIP_WASTAGE_LOGSOrderByWithRelationInput | WIP_WASTAGE_LOGSOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing WIP_WASTAGE_LOGS.
     */
    cursor?: WIP_WASTAGE_LOGSWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WIP_WASTAGE_LOGS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WIP_WASTAGE_LOGS.
     */
    skip?: number
    distinct?: WIP_WASTAGE_LOGSScalarFieldEnum | WIP_WASTAGE_LOGSScalarFieldEnum[]
  }

  /**
   * WIP_WASTAGE_LOGS create
   */
  export type WIP_WASTAGE_LOGSCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WIP_WASTAGE_LOGS
     */
    select?: WIP_WASTAGE_LOGSSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WIP_WASTAGE_LOGS
     */
    omit?: WIP_WASTAGE_LOGSOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WIP_WASTAGE_LOGSInclude<ExtArgs> | null
    /**
     * The data needed to create a WIP_WASTAGE_LOGS.
     */
    data: XOR<WIP_WASTAGE_LOGSCreateInput, WIP_WASTAGE_LOGSUncheckedCreateInput>
  }

  /**
   * WIP_WASTAGE_LOGS createMany
   */
  export type WIP_WASTAGE_LOGSCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many WIP_WASTAGE_LOGS.
     */
    data: WIP_WASTAGE_LOGSCreateManyInput | WIP_WASTAGE_LOGSCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * WIP_WASTAGE_LOGS update
   */
  export type WIP_WASTAGE_LOGSUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WIP_WASTAGE_LOGS
     */
    select?: WIP_WASTAGE_LOGSSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WIP_WASTAGE_LOGS
     */
    omit?: WIP_WASTAGE_LOGSOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WIP_WASTAGE_LOGSInclude<ExtArgs> | null
    /**
     * The data needed to update a WIP_WASTAGE_LOGS.
     */
    data: XOR<WIP_WASTAGE_LOGSUpdateInput, WIP_WASTAGE_LOGSUncheckedUpdateInput>
    /**
     * Choose, which WIP_WASTAGE_LOGS to update.
     */
    where: WIP_WASTAGE_LOGSWhereUniqueInput
  }

  /**
   * WIP_WASTAGE_LOGS updateMany
   */
  export type WIP_WASTAGE_LOGSUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update WIP_WASTAGE_LOGS.
     */
    data: XOR<WIP_WASTAGE_LOGSUpdateManyMutationInput, WIP_WASTAGE_LOGSUncheckedUpdateManyInput>
    /**
     * Filter which WIP_WASTAGE_LOGS to update
     */
    where?: WIP_WASTAGE_LOGSWhereInput
  }

  /**
   * WIP_WASTAGE_LOGS upsert
   */
  export type WIP_WASTAGE_LOGSUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WIP_WASTAGE_LOGS
     */
    select?: WIP_WASTAGE_LOGSSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WIP_WASTAGE_LOGS
     */
    omit?: WIP_WASTAGE_LOGSOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WIP_WASTAGE_LOGSInclude<ExtArgs> | null
    /**
     * The filter to search for the WIP_WASTAGE_LOGS to update in case it exists.
     */
    where: WIP_WASTAGE_LOGSWhereUniqueInput
    /**
     * In case the WIP_WASTAGE_LOGS found by the `where` argument doesn't exist, create a new WIP_WASTAGE_LOGS with this data.
     */
    create: XOR<WIP_WASTAGE_LOGSCreateInput, WIP_WASTAGE_LOGSUncheckedCreateInput>
    /**
     * In case the WIP_WASTAGE_LOGS was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WIP_WASTAGE_LOGSUpdateInput, WIP_WASTAGE_LOGSUncheckedUpdateInput>
  }

  /**
   * WIP_WASTAGE_LOGS delete
   */
  export type WIP_WASTAGE_LOGSDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WIP_WASTAGE_LOGS
     */
    select?: WIP_WASTAGE_LOGSSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WIP_WASTAGE_LOGS
     */
    omit?: WIP_WASTAGE_LOGSOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WIP_WASTAGE_LOGSInclude<ExtArgs> | null
    /**
     * Filter which WIP_WASTAGE_LOGS to delete.
     */
    where: WIP_WASTAGE_LOGSWhereUniqueInput
  }

  /**
   * WIP_WASTAGE_LOGS deleteMany
   */
  export type WIP_WASTAGE_LOGSDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WIP_WASTAGE_LOGS to delete
     */
    where?: WIP_WASTAGE_LOGSWhereInput
  }

  /**
   * WIP_WASTAGE_LOGS without action
   */
  export type WIP_WASTAGE_LOGSDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WIP_WASTAGE_LOGS
     */
    select?: WIP_WASTAGE_LOGSSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WIP_WASTAGE_LOGS
     */
    omit?: WIP_WASTAGE_LOGSOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WIP_WASTAGE_LOGSInclude<ExtArgs> | null
  }


  /**
   * Model FG_WASTAGE_LOGS
   */

  export type AggregateFG_WASTAGE_LOGS = {
    _count: FG_WASTAGE_LOGSCountAggregateOutputType | null
    _avg: FG_WASTAGE_LOGSAvgAggregateOutputType | null
    _sum: FG_WASTAGE_LOGSSumAggregateOutputType | null
    _min: FG_WASTAGE_LOGSMinAggregateOutputType | null
    _max: FG_WASTAGE_LOGSMaxAggregateOutputType | null
  }

  export type FG_WASTAGE_LOGSAvgAggregateOutputType = {
    id: number | null
    transactionId: number | null
    fgId: number | null
    quantity: number | null
  }

  export type FG_WASTAGE_LOGSSumAggregateOutputType = {
    id: number | null
    transactionId: number | null
    fgId: number | null
    quantity: number | null
  }

  export type FG_WASTAGE_LOGSMinAggregateOutputType = {
    id: number | null
    transactionId: number | null
    transactionType: $Enums.TransactionType | null
    fgId: number | null
    quantity: number | null
    reason: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FG_WASTAGE_LOGSMaxAggregateOutputType = {
    id: number | null
    transactionId: number | null
    transactionType: $Enums.TransactionType | null
    fgId: number | null
    quantity: number | null
    reason: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FG_WASTAGE_LOGSCountAggregateOutputType = {
    id: number
    transactionId: number
    transactionType: number
    fgId: number
    quantity: number
    reason: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type FG_WASTAGE_LOGSAvgAggregateInputType = {
    id?: true
    transactionId?: true
    fgId?: true
    quantity?: true
  }

  export type FG_WASTAGE_LOGSSumAggregateInputType = {
    id?: true
    transactionId?: true
    fgId?: true
    quantity?: true
  }

  export type FG_WASTAGE_LOGSMinAggregateInputType = {
    id?: true
    transactionId?: true
    transactionType?: true
    fgId?: true
    quantity?: true
    reason?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FG_WASTAGE_LOGSMaxAggregateInputType = {
    id?: true
    transactionId?: true
    transactionType?: true
    fgId?: true
    quantity?: true
    reason?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FG_WASTAGE_LOGSCountAggregateInputType = {
    id?: true
    transactionId?: true
    transactionType?: true
    fgId?: true
    quantity?: true
    reason?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type FG_WASTAGE_LOGSAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FG_WASTAGE_LOGS to aggregate.
     */
    where?: FG_WASTAGE_LOGSWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FG_WASTAGE_LOGS to fetch.
     */
    orderBy?: FG_WASTAGE_LOGSOrderByWithRelationInput | FG_WASTAGE_LOGSOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FG_WASTAGE_LOGSWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FG_WASTAGE_LOGS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FG_WASTAGE_LOGS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FG_WASTAGE_LOGS
    **/
    _count?: true | FG_WASTAGE_LOGSCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FG_WASTAGE_LOGSAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FG_WASTAGE_LOGSSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FG_WASTAGE_LOGSMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FG_WASTAGE_LOGSMaxAggregateInputType
  }

  export type GetFG_WASTAGE_LOGSAggregateType<T extends FG_WASTAGE_LOGSAggregateArgs> = {
        [P in keyof T & keyof AggregateFG_WASTAGE_LOGS]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFG_WASTAGE_LOGS[P]>
      : GetScalarType<T[P], AggregateFG_WASTAGE_LOGS[P]>
  }




  export type FG_WASTAGE_LOGSGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FG_WASTAGE_LOGSWhereInput
    orderBy?: FG_WASTAGE_LOGSOrderByWithAggregationInput | FG_WASTAGE_LOGSOrderByWithAggregationInput[]
    by: FG_WASTAGE_LOGSScalarFieldEnum[] | FG_WASTAGE_LOGSScalarFieldEnum
    having?: FG_WASTAGE_LOGSScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FG_WASTAGE_LOGSCountAggregateInputType | true
    _avg?: FG_WASTAGE_LOGSAvgAggregateInputType
    _sum?: FG_WASTAGE_LOGSSumAggregateInputType
    _min?: FG_WASTAGE_LOGSMinAggregateInputType
    _max?: FG_WASTAGE_LOGSMaxAggregateInputType
  }

  export type FG_WASTAGE_LOGSGroupByOutputType = {
    id: number
    transactionId: number
    transactionType: $Enums.TransactionType
    fgId: number
    quantity: number
    reason: string
    createdAt: Date
    updatedAt: Date
    _count: FG_WASTAGE_LOGSCountAggregateOutputType | null
    _avg: FG_WASTAGE_LOGSAvgAggregateOutputType | null
    _sum: FG_WASTAGE_LOGSSumAggregateOutputType | null
    _min: FG_WASTAGE_LOGSMinAggregateOutputType | null
    _max: FG_WASTAGE_LOGSMaxAggregateOutputType | null
  }

  type GetFG_WASTAGE_LOGSGroupByPayload<T extends FG_WASTAGE_LOGSGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FG_WASTAGE_LOGSGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FG_WASTAGE_LOGSGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FG_WASTAGE_LOGSGroupByOutputType[P]>
            : GetScalarType<T[P], FG_WASTAGE_LOGSGroupByOutputType[P]>
        }
      >
    >


  export type FG_WASTAGE_LOGSSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    transactionId?: boolean
    transactionType?: boolean
    fgId?: boolean
    quantity?: boolean
    reason?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    fg?: boolean | FGDefaultArgs<ExtArgs>
    FGTransactions?: boolean | FG_TRANSACTIONSDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["fG_WASTAGE_LOGS"]>



  export type FG_WASTAGE_LOGSSelectScalar = {
    id?: boolean
    transactionId?: boolean
    transactionType?: boolean
    fgId?: boolean
    quantity?: boolean
    reason?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type FG_WASTAGE_LOGSOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "transactionId" | "transactionType" | "fgId" | "quantity" | "reason" | "createdAt" | "updatedAt", ExtArgs["result"]["fG_WASTAGE_LOGS"]>
  export type FG_WASTAGE_LOGSInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    fg?: boolean | FGDefaultArgs<ExtArgs>
    FGTransactions?: boolean | FG_TRANSACTIONSDefaultArgs<ExtArgs>
  }

  export type $FG_WASTAGE_LOGSPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "FG_WASTAGE_LOGS"
    objects: {
      fg: Prisma.$FGPayload<ExtArgs>
      FGTransactions: Prisma.$FG_TRANSACTIONSPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      transactionId: number
      transactionType: $Enums.TransactionType
      fgId: number
      quantity: number
      reason: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["fG_WASTAGE_LOGS"]>
    composites: {}
  }

  type FG_WASTAGE_LOGSGetPayload<S extends boolean | null | undefined | FG_WASTAGE_LOGSDefaultArgs> = $Result.GetResult<Prisma.$FG_WASTAGE_LOGSPayload, S>

  type FG_WASTAGE_LOGSCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<FG_WASTAGE_LOGSFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FG_WASTAGE_LOGSCountAggregateInputType | true
    }

  export interface FG_WASTAGE_LOGSDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['FG_WASTAGE_LOGS'], meta: { name: 'FG_WASTAGE_LOGS' } }
    /**
     * Find zero or one FG_WASTAGE_LOGS that matches the filter.
     * @param {FG_WASTAGE_LOGSFindUniqueArgs} args - Arguments to find a FG_WASTAGE_LOGS
     * @example
     * // Get one FG_WASTAGE_LOGS
     * const fG_WASTAGE_LOGS = await prisma.fG_WASTAGE_LOGS.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FG_WASTAGE_LOGSFindUniqueArgs>(args: SelectSubset<T, FG_WASTAGE_LOGSFindUniqueArgs<ExtArgs>>): Prisma__FG_WASTAGE_LOGSClient<$Result.GetResult<Prisma.$FG_WASTAGE_LOGSPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one FG_WASTAGE_LOGS that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FG_WASTAGE_LOGSFindUniqueOrThrowArgs} args - Arguments to find a FG_WASTAGE_LOGS
     * @example
     * // Get one FG_WASTAGE_LOGS
     * const fG_WASTAGE_LOGS = await prisma.fG_WASTAGE_LOGS.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FG_WASTAGE_LOGSFindUniqueOrThrowArgs>(args: SelectSubset<T, FG_WASTAGE_LOGSFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FG_WASTAGE_LOGSClient<$Result.GetResult<Prisma.$FG_WASTAGE_LOGSPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first FG_WASTAGE_LOGS that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FG_WASTAGE_LOGSFindFirstArgs} args - Arguments to find a FG_WASTAGE_LOGS
     * @example
     * // Get one FG_WASTAGE_LOGS
     * const fG_WASTAGE_LOGS = await prisma.fG_WASTAGE_LOGS.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FG_WASTAGE_LOGSFindFirstArgs>(args?: SelectSubset<T, FG_WASTAGE_LOGSFindFirstArgs<ExtArgs>>): Prisma__FG_WASTAGE_LOGSClient<$Result.GetResult<Prisma.$FG_WASTAGE_LOGSPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first FG_WASTAGE_LOGS that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FG_WASTAGE_LOGSFindFirstOrThrowArgs} args - Arguments to find a FG_WASTAGE_LOGS
     * @example
     * // Get one FG_WASTAGE_LOGS
     * const fG_WASTAGE_LOGS = await prisma.fG_WASTAGE_LOGS.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FG_WASTAGE_LOGSFindFirstOrThrowArgs>(args?: SelectSubset<T, FG_WASTAGE_LOGSFindFirstOrThrowArgs<ExtArgs>>): Prisma__FG_WASTAGE_LOGSClient<$Result.GetResult<Prisma.$FG_WASTAGE_LOGSPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more FG_WASTAGE_LOGS that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FG_WASTAGE_LOGSFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FG_WASTAGE_LOGS
     * const fG_WASTAGE_LOGS = await prisma.fG_WASTAGE_LOGS.findMany()
     * 
     * // Get first 10 FG_WASTAGE_LOGS
     * const fG_WASTAGE_LOGS = await prisma.fG_WASTAGE_LOGS.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const fG_WASTAGE_LOGSWithIdOnly = await prisma.fG_WASTAGE_LOGS.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FG_WASTAGE_LOGSFindManyArgs>(args?: SelectSubset<T, FG_WASTAGE_LOGSFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FG_WASTAGE_LOGSPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a FG_WASTAGE_LOGS.
     * @param {FG_WASTAGE_LOGSCreateArgs} args - Arguments to create a FG_WASTAGE_LOGS.
     * @example
     * // Create one FG_WASTAGE_LOGS
     * const FG_WASTAGE_LOGS = await prisma.fG_WASTAGE_LOGS.create({
     *   data: {
     *     // ... data to create a FG_WASTAGE_LOGS
     *   }
     * })
     * 
     */
    create<T extends FG_WASTAGE_LOGSCreateArgs>(args: SelectSubset<T, FG_WASTAGE_LOGSCreateArgs<ExtArgs>>): Prisma__FG_WASTAGE_LOGSClient<$Result.GetResult<Prisma.$FG_WASTAGE_LOGSPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many FG_WASTAGE_LOGS.
     * @param {FG_WASTAGE_LOGSCreateManyArgs} args - Arguments to create many FG_WASTAGE_LOGS.
     * @example
     * // Create many FG_WASTAGE_LOGS
     * const fG_WASTAGE_LOGS = await prisma.fG_WASTAGE_LOGS.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FG_WASTAGE_LOGSCreateManyArgs>(args?: SelectSubset<T, FG_WASTAGE_LOGSCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a FG_WASTAGE_LOGS.
     * @param {FG_WASTAGE_LOGSDeleteArgs} args - Arguments to delete one FG_WASTAGE_LOGS.
     * @example
     * // Delete one FG_WASTAGE_LOGS
     * const FG_WASTAGE_LOGS = await prisma.fG_WASTAGE_LOGS.delete({
     *   where: {
     *     // ... filter to delete one FG_WASTAGE_LOGS
     *   }
     * })
     * 
     */
    delete<T extends FG_WASTAGE_LOGSDeleteArgs>(args: SelectSubset<T, FG_WASTAGE_LOGSDeleteArgs<ExtArgs>>): Prisma__FG_WASTAGE_LOGSClient<$Result.GetResult<Prisma.$FG_WASTAGE_LOGSPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one FG_WASTAGE_LOGS.
     * @param {FG_WASTAGE_LOGSUpdateArgs} args - Arguments to update one FG_WASTAGE_LOGS.
     * @example
     * // Update one FG_WASTAGE_LOGS
     * const fG_WASTAGE_LOGS = await prisma.fG_WASTAGE_LOGS.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FG_WASTAGE_LOGSUpdateArgs>(args: SelectSubset<T, FG_WASTAGE_LOGSUpdateArgs<ExtArgs>>): Prisma__FG_WASTAGE_LOGSClient<$Result.GetResult<Prisma.$FG_WASTAGE_LOGSPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more FG_WASTAGE_LOGS.
     * @param {FG_WASTAGE_LOGSDeleteManyArgs} args - Arguments to filter FG_WASTAGE_LOGS to delete.
     * @example
     * // Delete a few FG_WASTAGE_LOGS
     * const { count } = await prisma.fG_WASTAGE_LOGS.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FG_WASTAGE_LOGSDeleteManyArgs>(args?: SelectSubset<T, FG_WASTAGE_LOGSDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FG_WASTAGE_LOGS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FG_WASTAGE_LOGSUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FG_WASTAGE_LOGS
     * const fG_WASTAGE_LOGS = await prisma.fG_WASTAGE_LOGS.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FG_WASTAGE_LOGSUpdateManyArgs>(args: SelectSubset<T, FG_WASTAGE_LOGSUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one FG_WASTAGE_LOGS.
     * @param {FG_WASTAGE_LOGSUpsertArgs} args - Arguments to update or create a FG_WASTAGE_LOGS.
     * @example
     * // Update or create a FG_WASTAGE_LOGS
     * const fG_WASTAGE_LOGS = await prisma.fG_WASTAGE_LOGS.upsert({
     *   create: {
     *     // ... data to create a FG_WASTAGE_LOGS
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FG_WASTAGE_LOGS we want to update
     *   }
     * })
     */
    upsert<T extends FG_WASTAGE_LOGSUpsertArgs>(args: SelectSubset<T, FG_WASTAGE_LOGSUpsertArgs<ExtArgs>>): Prisma__FG_WASTAGE_LOGSClient<$Result.GetResult<Prisma.$FG_WASTAGE_LOGSPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of FG_WASTAGE_LOGS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FG_WASTAGE_LOGSCountArgs} args - Arguments to filter FG_WASTAGE_LOGS to count.
     * @example
     * // Count the number of FG_WASTAGE_LOGS
     * const count = await prisma.fG_WASTAGE_LOGS.count({
     *   where: {
     *     // ... the filter for the FG_WASTAGE_LOGS we want to count
     *   }
     * })
    **/
    count<T extends FG_WASTAGE_LOGSCountArgs>(
      args?: Subset<T, FG_WASTAGE_LOGSCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FG_WASTAGE_LOGSCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FG_WASTAGE_LOGS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FG_WASTAGE_LOGSAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FG_WASTAGE_LOGSAggregateArgs>(args: Subset<T, FG_WASTAGE_LOGSAggregateArgs>): Prisma.PrismaPromise<GetFG_WASTAGE_LOGSAggregateType<T>>

    /**
     * Group by FG_WASTAGE_LOGS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FG_WASTAGE_LOGSGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FG_WASTAGE_LOGSGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FG_WASTAGE_LOGSGroupByArgs['orderBy'] }
        : { orderBy?: FG_WASTAGE_LOGSGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FG_WASTAGE_LOGSGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFG_WASTAGE_LOGSGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the FG_WASTAGE_LOGS model
   */
  readonly fields: FG_WASTAGE_LOGSFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for FG_WASTAGE_LOGS.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FG_WASTAGE_LOGSClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    fg<T extends FGDefaultArgs<ExtArgs> = {}>(args?: Subset<T, FGDefaultArgs<ExtArgs>>): Prisma__FGClient<$Result.GetResult<Prisma.$FGPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    FGTransactions<T extends FG_TRANSACTIONSDefaultArgs<ExtArgs> = {}>(args?: Subset<T, FG_TRANSACTIONSDefaultArgs<ExtArgs>>): Prisma__FG_TRANSACTIONSClient<$Result.GetResult<Prisma.$FG_TRANSACTIONSPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the FG_WASTAGE_LOGS model
   */ 
  interface FG_WASTAGE_LOGSFieldRefs {
    readonly id: FieldRef<"FG_WASTAGE_LOGS", 'Int'>
    readonly transactionId: FieldRef<"FG_WASTAGE_LOGS", 'Int'>
    readonly transactionType: FieldRef<"FG_WASTAGE_LOGS", 'TransactionType'>
    readonly fgId: FieldRef<"FG_WASTAGE_LOGS", 'Int'>
    readonly quantity: FieldRef<"FG_WASTAGE_LOGS", 'Int'>
    readonly reason: FieldRef<"FG_WASTAGE_LOGS", 'String'>
    readonly createdAt: FieldRef<"FG_WASTAGE_LOGS", 'DateTime'>
    readonly updatedAt: FieldRef<"FG_WASTAGE_LOGS", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * FG_WASTAGE_LOGS findUnique
   */
  export type FG_WASTAGE_LOGSFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FG_WASTAGE_LOGS
     */
    select?: FG_WASTAGE_LOGSSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FG_WASTAGE_LOGS
     */
    omit?: FG_WASTAGE_LOGSOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FG_WASTAGE_LOGSInclude<ExtArgs> | null
    /**
     * Filter, which FG_WASTAGE_LOGS to fetch.
     */
    where: FG_WASTAGE_LOGSWhereUniqueInput
  }

  /**
   * FG_WASTAGE_LOGS findUniqueOrThrow
   */
  export type FG_WASTAGE_LOGSFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FG_WASTAGE_LOGS
     */
    select?: FG_WASTAGE_LOGSSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FG_WASTAGE_LOGS
     */
    omit?: FG_WASTAGE_LOGSOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FG_WASTAGE_LOGSInclude<ExtArgs> | null
    /**
     * Filter, which FG_WASTAGE_LOGS to fetch.
     */
    where: FG_WASTAGE_LOGSWhereUniqueInput
  }

  /**
   * FG_WASTAGE_LOGS findFirst
   */
  export type FG_WASTAGE_LOGSFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FG_WASTAGE_LOGS
     */
    select?: FG_WASTAGE_LOGSSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FG_WASTAGE_LOGS
     */
    omit?: FG_WASTAGE_LOGSOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FG_WASTAGE_LOGSInclude<ExtArgs> | null
    /**
     * Filter, which FG_WASTAGE_LOGS to fetch.
     */
    where?: FG_WASTAGE_LOGSWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FG_WASTAGE_LOGS to fetch.
     */
    orderBy?: FG_WASTAGE_LOGSOrderByWithRelationInput | FG_WASTAGE_LOGSOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FG_WASTAGE_LOGS.
     */
    cursor?: FG_WASTAGE_LOGSWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FG_WASTAGE_LOGS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FG_WASTAGE_LOGS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FG_WASTAGE_LOGS.
     */
    distinct?: FG_WASTAGE_LOGSScalarFieldEnum | FG_WASTAGE_LOGSScalarFieldEnum[]
  }

  /**
   * FG_WASTAGE_LOGS findFirstOrThrow
   */
  export type FG_WASTAGE_LOGSFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FG_WASTAGE_LOGS
     */
    select?: FG_WASTAGE_LOGSSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FG_WASTAGE_LOGS
     */
    omit?: FG_WASTAGE_LOGSOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FG_WASTAGE_LOGSInclude<ExtArgs> | null
    /**
     * Filter, which FG_WASTAGE_LOGS to fetch.
     */
    where?: FG_WASTAGE_LOGSWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FG_WASTAGE_LOGS to fetch.
     */
    orderBy?: FG_WASTAGE_LOGSOrderByWithRelationInput | FG_WASTAGE_LOGSOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FG_WASTAGE_LOGS.
     */
    cursor?: FG_WASTAGE_LOGSWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FG_WASTAGE_LOGS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FG_WASTAGE_LOGS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FG_WASTAGE_LOGS.
     */
    distinct?: FG_WASTAGE_LOGSScalarFieldEnum | FG_WASTAGE_LOGSScalarFieldEnum[]
  }

  /**
   * FG_WASTAGE_LOGS findMany
   */
  export type FG_WASTAGE_LOGSFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FG_WASTAGE_LOGS
     */
    select?: FG_WASTAGE_LOGSSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FG_WASTAGE_LOGS
     */
    omit?: FG_WASTAGE_LOGSOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FG_WASTAGE_LOGSInclude<ExtArgs> | null
    /**
     * Filter, which FG_WASTAGE_LOGS to fetch.
     */
    where?: FG_WASTAGE_LOGSWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FG_WASTAGE_LOGS to fetch.
     */
    orderBy?: FG_WASTAGE_LOGSOrderByWithRelationInput | FG_WASTAGE_LOGSOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FG_WASTAGE_LOGS.
     */
    cursor?: FG_WASTAGE_LOGSWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FG_WASTAGE_LOGS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FG_WASTAGE_LOGS.
     */
    skip?: number
    distinct?: FG_WASTAGE_LOGSScalarFieldEnum | FG_WASTAGE_LOGSScalarFieldEnum[]
  }

  /**
   * FG_WASTAGE_LOGS create
   */
  export type FG_WASTAGE_LOGSCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FG_WASTAGE_LOGS
     */
    select?: FG_WASTAGE_LOGSSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FG_WASTAGE_LOGS
     */
    omit?: FG_WASTAGE_LOGSOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FG_WASTAGE_LOGSInclude<ExtArgs> | null
    /**
     * The data needed to create a FG_WASTAGE_LOGS.
     */
    data: XOR<FG_WASTAGE_LOGSCreateInput, FG_WASTAGE_LOGSUncheckedCreateInput>
  }

  /**
   * FG_WASTAGE_LOGS createMany
   */
  export type FG_WASTAGE_LOGSCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many FG_WASTAGE_LOGS.
     */
    data: FG_WASTAGE_LOGSCreateManyInput | FG_WASTAGE_LOGSCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * FG_WASTAGE_LOGS update
   */
  export type FG_WASTAGE_LOGSUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FG_WASTAGE_LOGS
     */
    select?: FG_WASTAGE_LOGSSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FG_WASTAGE_LOGS
     */
    omit?: FG_WASTAGE_LOGSOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FG_WASTAGE_LOGSInclude<ExtArgs> | null
    /**
     * The data needed to update a FG_WASTAGE_LOGS.
     */
    data: XOR<FG_WASTAGE_LOGSUpdateInput, FG_WASTAGE_LOGSUncheckedUpdateInput>
    /**
     * Choose, which FG_WASTAGE_LOGS to update.
     */
    where: FG_WASTAGE_LOGSWhereUniqueInput
  }

  /**
   * FG_WASTAGE_LOGS updateMany
   */
  export type FG_WASTAGE_LOGSUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update FG_WASTAGE_LOGS.
     */
    data: XOR<FG_WASTAGE_LOGSUpdateManyMutationInput, FG_WASTAGE_LOGSUncheckedUpdateManyInput>
    /**
     * Filter which FG_WASTAGE_LOGS to update
     */
    where?: FG_WASTAGE_LOGSWhereInput
  }

  /**
   * FG_WASTAGE_LOGS upsert
   */
  export type FG_WASTAGE_LOGSUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FG_WASTAGE_LOGS
     */
    select?: FG_WASTAGE_LOGSSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FG_WASTAGE_LOGS
     */
    omit?: FG_WASTAGE_LOGSOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FG_WASTAGE_LOGSInclude<ExtArgs> | null
    /**
     * The filter to search for the FG_WASTAGE_LOGS to update in case it exists.
     */
    where: FG_WASTAGE_LOGSWhereUniqueInput
    /**
     * In case the FG_WASTAGE_LOGS found by the `where` argument doesn't exist, create a new FG_WASTAGE_LOGS with this data.
     */
    create: XOR<FG_WASTAGE_LOGSCreateInput, FG_WASTAGE_LOGSUncheckedCreateInput>
    /**
     * In case the FG_WASTAGE_LOGS was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FG_WASTAGE_LOGSUpdateInput, FG_WASTAGE_LOGSUncheckedUpdateInput>
  }

  /**
   * FG_WASTAGE_LOGS delete
   */
  export type FG_WASTAGE_LOGSDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FG_WASTAGE_LOGS
     */
    select?: FG_WASTAGE_LOGSSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FG_WASTAGE_LOGS
     */
    omit?: FG_WASTAGE_LOGSOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FG_WASTAGE_LOGSInclude<ExtArgs> | null
    /**
     * Filter which FG_WASTAGE_LOGS to delete.
     */
    where: FG_WASTAGE_LOGSWhereUniqueInput
  }

  /**
   * FG_WASTAGE_LOGS deleteMany
   */
  export type FG_WASTAGE_LOGSDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FG_WASTAGE_LOGS to delete
     */
    where?: FG_WASTAGE_LOGSWhereInput
  }

  /**
   * FG_WASTAGE_LOGS without action
   */
  export type FG_WASTAGE_LOGSDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FG_WASTAGE_LOGS
     */
    select?: FG_WASTAGE_LOGSSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FG_WASTAGE_LOGS
     */
    omit?: FG_WASTAGE_LOGSOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FG_WASTAGE_LOGSInclude<ExtArgs> | null
  }


  /**
   * Model AuditLogs
   */

  export type AggregateAuditLogs = {
    _count: AuditLogsCountAggregateOutputType | null
    _avg: AuditLogsAvgAggregateOutputType | null
    _sum: AuditLogsSumAggregateOutputType | null
    _min: AuditLogsMinAggregateOutputType | null
    _max: AuditLogsMaxAggregateOutputType | null
  }

  export type AuditLogsAvgAggregateOutputType = {
    id: number | null
    changedById: number | null
  }

  export type AuditLogsSumAggregateOutputType = {
    id: number | null
    changedById: number | null
  }

  export type AuditLogsMinAggregateOutputType = {
    id: number | null
    tableName: string | null
    action: $Enums.Actions | null
    changedById: number | null
    createdAt: Date | null
  }

  export type AuditLogsMaxAggregateOutputType = {
    id: number | null
    tableName: string | null
    action: $Enums.Actions | null
    changedById: number | null
    createdAt: Date | null
  }

  export type AuditLogsCountAggregateOutputType = {
    id: number
    tableName: number
    action: number
    oldValue: number
    newValue: number
    changedById: number
    createdAt: number
    _all: number
  }


  export type AuditLogsAvgAggregateInputType = {
    id?: true
    changedById?: true
  }

  export type AuditLogsSumAggregateInputType = {
    id?: true
    changedById?: true
  }

  export type AuditLogsMinAggregateInputType = {
    id?: true
    tableName?: true
    action?: true
    changedById?: true
    createdAt?: true
  }

  export type AuditLogsMaxAggregateInputType = {
    id?: true
    tableName?: true
    action?: true
    changedById?: true
    createdAt?: true
  }

  export type AuditLogsCountAggregateInputType = {
    id?: true
    tableName?: true
    action?: true
    oldValue?: true
    newValue?: true
    changedById?: true
    createdAt?: true
    _all?: true
  }

  export type AuditLogsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AuditLogs to aggregate.
     */
    where?: AuditLogsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogsOrderByWithRelationInput | AuditLogsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AuditLogsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AuditLogs
    **/
    _count?: true | AuditLogsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AuditLogsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AuditLogsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AuditLogsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AuditLogsMaxAggregateInputType
  }

  export type GetAuditLogsAggregateType<T extends AuditLogsAggregateArgs> = {
        [P in keyof T & keyof AggregateAuditLogs]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAuditLogs[P]>
      : GetScalarType<T[P], AggregateAuditLogs[P]>
  }




  export type AuditLogsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuditLogsWhereInput
    orderBy?: AuditLogsOrderByWithAggregationInput | AuditLogsOrderByWithAggregationInput[]
    by: AuditLogsScalarFieldEnum[] | AuditLogsScalarFieldEnum
    having?: AuditLogsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AuditLogsCountAggregateInputType | true
    _avg?: AuditLogsAvgAggregateInputType
    _sum?: AuditLogsSumAggregateInputType
    _min?: AuditLogsMinAggregateInputType
    _max?: AuditLogsMaxAggregateInputType
  }

  export type AuditLogsGroupByOutputType = {
    id: number
    tableName: string
    action: $Enums.Actions
    oldValue: JsonValue | null
    newValue: JsonValue | null
    changedById: number
    createdAt: Date
    _count: AuditLogsCountAggregateOutputType | null
    _avg: AuditLogsAvgAggregateOutputType | null
    _sum: AuditLogsSumAggregateOutputType | null
    _min: AuditLogsMinAggregateOutputType | null
    _max: AuditLogsMaxAggregateOutputType | null
  }

  type GetAuditLogsGroupByPayload<T extends AuditLogsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AuditLogsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AuditLogsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AuditLogsGroupByOutputType[P]>
            : GetScalarType<T[P], AuditLogsGroupByOutputType[P]>
        }
      >
    >


  export type AuditLogsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tableName?: boolean
    action?: boolean
    oldValue?: boolean
    newValue?: boolean
    changedById?: boolean
    createdAt?: boolean
    changedBy?: boolean | EmployeeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["auditLogs"]>



  export type AuditLogsSelectScalar = {
    id?: boolean
    tableName?: boolean
    action?: boolean
    oldValue?: boolean
    newValue?: boolean
    changedById?: boolean
    createdAt?: boolean
  }

  export type AuditLogsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "tableName" | "action" | "oldValue" | "newValue" | "changedById" | "createdAt", ExtArgs["result"]["auditLogs"]>
  export type AuditLogsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    changedBy?: boolean | EmployeeDefaultArgs<ExtArgs>
  }

  export type $AuditLogsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AuditLogs"
    objects: {
      changedBy: Prisma.$EmployeePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      tableName: string
      action: $Enums.Actions
      oldValue: Prisma.JsonValue | null
      newValue: Prisma.JsonValue | null
      changedById: number
      createdAt: Date
    }, ExtArgs["result"]["auditLogs"]>
    composites: {}
  }

  type AuditLogsGetPayload<S extends boolean | null | undefined | AuditLogsDefaultArgs> = $Result.GetResult<Prisma.$AuditLogsPayload, S>

  type AuditLogsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AuditLogsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AuditLogsCountAggregateInputType | true
    }

  export interface AuditLogsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AuditLogs'], meta: { name: 'AuditLogs' } }
    /**
     * Find zero or one AuditLogs that matches the filter.
     * @param {AuditLogsFindUniqueArgs} args - Arguments to find a AuditLogs
     * @example
     * // Get one AuditLogs
     * const auditLogs = await prisma.auditLogs.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AuditLogsFindUniqueArgs>(args: SelectSubset<T, AuditLogsFindUniqueArgs<ExtArgs>>): Prisma__AuditLogsClient<$Result.GetResult<Prisma.$AuditLogsPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one AuditLogs that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AuditLogsFindUniqueOrThrowArgs} args - Arguments to find a AuditLogs
     * @example
     * // Get one AuditLogs
     * const auditLogs = await prisma.auditLogs.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AuditLogsFindUniqueOrThrowArgs>(args: SelectSubset<T, AuditLogsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AuditLogsClient<$Result.GetResult<Prisma.$AuditLogsPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first AuditLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogsFindFirstArgs} args - Arguments to find a AuditLogs
     * @example
     * // Get one AuditLogs
     * const auditLogs = await prisma.auditLogs.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AuditLogsFindFirstArgs>(args?: SelectSubset<T, AuditLogsFindFirstArgs<ExtArgs>>): Prisma__AuditLogsClient<$Result.GetResult<Prisma.$AuditLogsPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first AuditLogs that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogsFindFirstOrThrowArgs} args - Arguments to find a AuditLogs
     * @example
     * // Get one AuditLogs
     * const auditLogs = await prisma.auditLogs.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AuditLogsFindFirstOrThrowArgs>(args?: SelectSubset<T, AuditLogsFindFirstOrThrowArgs<ExtArgs>>): Prisma__AuditLogsClient<$Result.GetResult<Prisma.$AuditLogsPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more AuditLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AuditLogs
     * const auditLogs = await prisma.auditLogs.findMany()
     * 
     * // Get first 10 AuditLogs
     * const auditLogs = await prisma.auditLogs.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const auditLogsWithIdOnly = await prisma.auditLogs.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AuditLogsFindManyArgs>(args?: SelectSubset<T, AuditLogsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogsPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a AuditLogs.
     * @param {AuditLogsCreateArgs} args - Arguments to create a AuditLogs.
     * @example
     * // Create one AuditLogs
     * const AuditLogs = await prisma.auditLogs.create({
     *   data: {
     *     // ... data to create a AuditLogs
     *   }
     * })
     * 
     */
    create<T extends AuditLogsCreateArgs>(args: SelectSubset<T, AuditLogsCreateArgs<ExtArgs>>): Prisma__AuditLogsClient<$Result.GetResult<Prisma.$AuditLogsPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many AuditLogs.
     * @param {AuditLogsCreateManyArgs} args - Arguments to create many AuditLogs.
     * @example
     * // Create many AuditLogs
     * const auditLogs = await prisma.auditLogs.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AuditLogsCreateManyArgs>(args?: SelectSubset<T, AuditLogsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a AuditLogs.
     * @param {AuditLogsDeleteArgs} args - Arguments to delete one AuditLogs.
     * @example
     * // Delete one AuditLogs
     * const AuditLogs = await prisma.auditLogs.delete({
     *   where: {
     *     // ... filter to delete one AuditLogs
     *   }
     * })
     * 
     */
    delete<T extends AuditLogsDeleteArgs>(args: SelectSubset<T, AuditLogsDeleteArgs<ExtArgs>>): Prisma__AuditLogsClient<$Result.GetResult<Prisma.$AuditLogsPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one AuditLogs.
     * @param {AuditLogsUpdateArgs} args - Arguments to update one AuditLogs.
     * @example
     * // Update one AuditLogs
     * const auditLogs = await prisma.auditLogs.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AuditLogsUpdateArgs>(args: SelectSubset<T, AuditLogsUpdateArgs<ExtArgs>>): Prisma__AuditLogsClient<$Result.GetResult<Prisma.$AuditLogsPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more AuditLogs.
     * @param {AuditLogsDeleteManyArgs} args - Arguments to filter AuditLogs to delete.
     * @example
     * // Delete a few AuditLogs
     * const { count } = await prisma.auditLogs.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AuditLogsDeleteManyArgs>(args?: SelectSubset<T, AuditLogsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AuditLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AuditLogs
     * const auditLogs = await prisma.auditLogs.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AuditLogsUpdateManyArgs>(args: SelectSubset<T, AuditLogsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AuditLogs.
     * @param {AuditLogsUpsertArgs} args - Arguments to update or create a AuditLogs.
     * @example
     * // Update or create a AuditLogs
     * const auditLogs = await prisma.auditLogs.upsert({
     *   create: {
     *     // ... data to create a AuditLogs
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AuditLogs we want to update
     *   }
     * })
     */
    upsert<T extends AuditLogsUpsertArgs>(args: SelectSubset<T, AuditLogsUpsertArgs<ExtArgs>>): Prisma__AuditLogsClient<$Result.GetResult<Prisma.$AuditLogsPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of AuditLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogsCountArgs} args - Arguments to filter AuditLogs to count.
     * @example
     * // Count the number of AuditLogs
     * const count = await prisma.auditLogs.count({
     *   where: {
     *     // ... the filter for the AuditLogs we want to count
     *   }
     * })
    **/
    count<T extends AuditLogsCountArgs>(
      args?: Subset<T, AuditLogsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AuditLogsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AuditLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AuditLogsAggregateArgs>(args: Subset<T, AuditLogsAggregateArgs>): Prisma.PrismaPromise<GetAuditLogsAggregateType<T>>

    /**
     * Group by AuditLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AuditLogsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AuditLogsGroupByArgs['orderBy'] }
        : { orderBy?: AuditLogsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AuditLogsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAuditLogsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AuditLogs model
   */
  readonly fields: AuditLogsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AuditLogs.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AuditLogsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    changedBy<T extends EmployeeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EmployeeDefaultArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AuditLogs model
   */ 
  interface AuditLogsFieldRefs {
    readonly id: FieldRef<"AuditLogs", 'Int'>
    readonly tableName: FieldRef<"AuditLogs", 'String'>
    readonly action: FieldRef<"AuditLogs", 'Actions'>
    readonly oldValue: FieldRef<"AuditLogs", 'Json'>
    readonly newValue: FieldRef<"AuditLogs", 'Json'>
    readonly changedById: FieldRef<"AuditLogs", 'Int'>
    readonly createdAt: FieldRef<"AuditLogs", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AuditLogs findUnique
   */
  export type AuditLogsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLogs
     */
    select?: AuditLogsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLogs
     */
    omit?: AuditLogsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogsInclude<ExtArgs> | null
    /**
     * Filter, which AuditLogs to fetch.
     */
    where: AuditLogsWhereUniqueInput
  }

  /**
   * AuditLogs findUniqueOrThrow
   */
  export type AuditLogsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLogs
     */
    select?: AuditLogsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLogs
     */
    omit?: AuditLogsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogsInclude<ExtArgs> | null
    /**
     * Filter, which AuditLogs to fetch.
     */
    where: AuditLogsWhereUniqueInput
  }

  /**
   * AuditLogs findFirst
   */
  export type AuditLogsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLogs
     */
    select?: AuditLogsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLogs
     */
    omit?: AuditLogsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogsInclude<ExtArgs> | null
    /**
     * Filter, which AuditLogs to fetch.
     */
    where?: AuditLogsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogsOrderByWithRelationInput | AuditLogsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AuditLogs.
     */
    cursor?: AuditLogsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AuditLogs.
     */
    distinct?: AuditLogsScalarFieldEnum | AuditLogsScalarFieldEnum[]
  }

  /**
   * AuditLogs findFirstOrThrow
   */
  export type AuditLogsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLogs
     */
    select?: AuditLogsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLogs
     */
    omit?: AuditLogsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogsInclude<ExtArgs> | null
    /**
     * Filter, which AuditLogs to fetch.
     */
    where?: AuditLogsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogsOrderByWithRelationInput | AuditLogsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AuditLogs.
     */
    cursor?: AuditLogsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AuditLogs.
     */
    distinct?: AuditLogsScalarFieldEnum | AuditLogsScalarFieldEnum[]
  }

  /**
   * AuditLogs findMany
   */
  export type AuditLogsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLogs
     */
    select?: AuditLogsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLogs
     */
    omit?: AuditLogsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogsInclude<ExtArgs> | null
    /**
     * Filter, which AuditLogs to fetch.
     */
    where?: AuditLogsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogsOrderByWithRelationInput | AuditLogsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AuditLogs.
     */
    cursor?: AuditLogsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    distinct?: AuditLogsScalarFieldEnum | AuditLogsScalarFieldEnum[]
  }

  /**
   * AuditLogs create
   */
  export type AuditLogsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLogs
     */
    select?: AuditLogsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLogs
     */
    omit?: AuditLogsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogsInclude<ExtArgs> | null
    /**
     * The data needed to create a AuditLogs.
     */
    data: XOR<AuditLogsCreateInput, AuditLogsUncheckedCreateInput>
  }

  /**
   * AuditLogs createMany
   */
  export type AuditLogsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AuditLogs.
     */
    data: AuditLogsCreateManyInput | AuditLogsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AuditLogs update
   */
  export type AuditLogsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLogs
     */
    select?: AuditLogsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLogs
     */
    omit?: AuditLogsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogsInclude<ExtArgs> | null
    /**
     * The data needed to update a AuditLogs.
     */
    data: XOR<AuditLogsUpdateInput, AuditLogsUncheckedUpdateInput>
    /**
     * Choose, which AuditLogs to update.
     */
    where: AuditLogsWhereUniqueInput
  }

  /**
   * AuditLogs updateMany
   */
  export type AuditLogsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AuditLogs.
     */
    data: XOR<AuditLogsUpdateManyMutationInput, AuditLogsUncheckedUpdateManyInput>
    /**
     * Filter which AuditLogs to update
     */
    where?: AuditLogsWhereInput
  }

  /**
   * AuditLogs upsert
   */
  export type AuditLogsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLogs
     */
    select?: AuditLogsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLogs
     */
    omit?: AuditLogsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogsInclude<ExtArgs> | null
    /**
     * The filter to search for the AuditLogs to update in case it exists.
     */
    where: AuditLogsWhereUniqueInput
    /**
     * In case the AuditLogs found by the `where` argument doesn't exist, create a new AuditLogs with this data.
     */
    create: XOR<AuditLogsCreateInput, AuditLogsUncheckedCreateInput>
    /**
     * In case the AuditLogs was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AuditLogsUpdateInput, AuditLogsUncheckedUpdateInput>
  }

  /**
   * AuditLogs delete
   */
  export type AuditLogsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLogs
     */
    select?: AuditLogsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLogs
     */
    omit?: AuditLogsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogsInclude<ExtArgs> | null
    /**
     * Filter which AuditLogs to delete.
     */
    where: AuditLogsWhereUniqueInput
  }

  /**
   * AuditLogs deleteMany
   */
  export type AuditLogsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AuditLogs to delete
     */
    where?: AuditLogsWhereInput
  }

  /**
   * AuditLogs without action
   */
  export type AuditLogsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLogs
     */
    select?: AuditLogsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLogs
     */
    omit?: AuditLogsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogsInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const RAW_MATERIALSScalarFieldEnum: {
    id: 'id',
    name: 'name',
    SKU: 'SKU',
    quantity: 'quantity',
    price: 'price',
    image: 'image',
    description: 'description',
    expiry_date: 'expiry_date',
    quality_status: 'quality_status',
    storage_location: 'storage_location',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    deletedAt: 'deletedAt'
  };

  export type RAW_MATERIALSScalarFieldEnum = (typeof RAW_MATERIALSScalarFieldEnum)[keyof typeof RAW_MATERIALSScalarFieldEnum]


  export const SHOPIFY_VARIANTSScalarFieldEnum: {
    id: 'id',
    productId: 'productId',
    name: 'name',
    AvailableQty: 'AvailableQty',
    img: 'img',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    deletedAt: 'deletedAt',
    variantName: 'variantName',
    variantOption: 'variantOption'
  };

  export type SHOPIFY_VARIANTSScalarFieldEnum = (typeof SHOPIFY_VARIANTSScalarFieldEnum)[keyof typeof SHOPIFY_VARIANTSScalarFieldEnum]


  export const VARIANT_RAW_MATERIALS_TRACKERScalarFieldEnum: {
    variantId: 'variantId',
    rawMaterialId: 'rawMaterialId',
    avgQuantity: 'avgQuantity',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    deletedAt: 'deletedAt'
  };

  export type VARIANT_RAW_MATERIALS_TRACKERScalarFieldEnum = (typeof VARIANT_RAW_MATERIALS_TRACKERScalarFieldEnum)[keyof typeof VARIANT_RAW_MATERIALS_TRACKERScalarFieldEnum]


  export const CATEGORIESScalarFieldEnum: {
    id: 'id',
    name: 'name',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CATEGORIESScalarFieldEnum = (typeof CATEGORIESScalarFieldEnum)[keyof typeof CATEGORIESScalarFieldEnum]


  export const SHOPIFY_PRODUCTSScalarFieldEnum: {
    id: 'id',
    name: 'name',
    categoryId: 'categoryId',
    price: 'price',
    status: 'status',
    img: 'img',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SHOPIFY_PRODUCTSScalarFieldEnum = (typeof SHOPIFY_PRODUCTSScalarFieldEnum)[keyof typeof SHOPIFY_PRODUCTSScalarFieldEnum]


  export const RM_TRANSACTIONSScalarFieldEnum: {
    id: 'id',
    rawMaterialId: 'rawMaterialId',
    quantity: 'quantity',
    transactionType: 'transactionType',
    reason: 'reason',
    status: 'status',
    initiatedById: 'initiatedById',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    deletedAt: 'deletedAt'
  };

  export type RM_TRANSACTIONSScalarFieldEnum = (typeof RM_TRANSACTIONSScalarFieldEnum)[keyof typeof RM_TRANSACTIONSScalarFieldEnum]


  export const RM_QCScalarFieldEnum: {
    id: 'id',
    transactionId: 'transactionId',
    rawMaterialId: 'rawMaterialId',
    quality_status: 'quality_status',
    checkedById: 'checkedById',
    doneById: 'doneById',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    deletedAt: 'deletedAt'
  };

  export type RM_QCScalarFieldEnum = (typeof RM_QCScalarFieldEnum)[keyof typeof RM_QCScalarFieldEnum]


  export const RM_WASTAGE_LOGSScalarFieldEnum: {
    id: 'id',
    transactionId: 'transactionId',
    rawMaterialId: 'rawMaterialId',
    quantity: 'quantity',
    reason: 'reason',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    deletedAt: 'deletedAt'
  };

  export type RM_WASTAGE_LOGSScalarFieldEnum = (typeof RM_WASTAGE_LOGSScalarFieldEnum)[keyof typeof RM_WASTAGE_LOGSScalarFieldEnum]


  export const EmployeeScalarFieldEnum: {
    id: 'id',
    name: 'name',
    role: 'role',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    deletedAt: 'deletedAt'
  };

  export type EmployeeScalarFieldEnum = (typeof EmployeeScalarFieldEnum)[keyof typeof EmployeeScalarFieldEnum]


  export const WIPScalarFieldEnum: {
    id: 'id',
    orderId: 'orderId',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type WIPScalarFieldEnum = (typeof WIPScalarFieldEnum)[keyof typeof WIPScalarFieldEnum]


  export const WIP_PRODUCTSScalarFieldEnum: {
    id: 'id',
    wipId: 'wipId',
    productId: 'productId',
    quantity: 'quantity'
  };

  export type WIP_PRODUCTSScalarFieldEnum = (typeof WIP_PRODUCTSScalarFieldEnum)[keyof typeof WIP_PRODUCTSScalarFieldEnum]


  export const WIPRawMaterialScalarFieldEnum: {
    id: 'id',
    wipId: 'wipId',
    rawMaterialId: 'rawMaterialId',
    quantity: 'quantity'
  };

  export type WIPRawMaterialScalarFieldEnum = (typeof WIPRawMaterialScalarFieldEnum)[keyof typeof WIPRawMaterialScalarFieldEnum]


  export const FGScalarFieldEnum: {
    id: 'id',
    orderId: 'orderId',
    customerName: 'customerName',
    price: 'price',
    status: 'status',
    createdAt: 'createdAt',
    deliveryDate: 'deliveryDate'
  };

  export type FGScalarFieldEnum = (typeof FGScalarFieldEnum)[keyof typeof FGScalarFieldEnum]


  export const FG_PRODUCTSScalarFieldEnum: {
    id: 'id',
    fgId: 'fgId',
    productId: 'productId',
    quantity: 'quantity'
  };

  export type FG_PRODUCTSScalarFieldEnum = (typeof FG_PRODUCTSScalarFieldEnum)[keyof typeof FG_PRODUCTSScalarFieldEnum]


  export const WIP_TRANSACTIONSScalarFieldEnum: {
    id: 'id',
    wipId: 'wipId',
    quantity: 'quantity',
    transactionType: 'transactionType',
    reason: 'reason',
    status: 'status',
    initiatedById: 'initiatedById',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type WIP_TRANSACTIONSScalarFieldEnum = (typeof WIP_TRANSACTIONSScalarFieldEnum)[keyof typeof WIP_TRANSACTIONSScalarFieldEnum]


  export const FG_TRANSACTIONSScalarFieldEnum: {
    id: 'id',
    fgId: 'fgId',
    quantity: 'quantity',
    transactionType: 'transactionType',
    status: 'status',
    reason: 'reason',
    IntiatedById: 'IntiatedById',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    deletedAt: 'deletedAt'
  };

  export type FG_TRANSACTIONSScalarFieldEnum = (typeof FG_TRANSACTIONSScalarFieldEnum)[keyof typeof FG_TRANSACTIONSScalarFieldEnum]


  export const WIP_QCScalarFieldEnum: {
    id: 'id',
    transactionId: 'transactionId',
    transactionType: 'transactionType',
    wipId: 'wipId',
    quality_status: 'quality_status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type WIP_QCScalarFieldEnum = (typeof WIP_QCScalarFieldEnum)[keyof typeof WIP_QCScalarFieldEnum]


  export const FG_QCScalarFieldEnum: {
    id: 'id',
    transactionId: 'transactionId',
    transactionType: 'transactionType',
    fgId: 'fgId',
    quality_status: 'quality_status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type FG_QCScalarFieldEnum = (typeof FG_QCScalarFieldEnum)[keyof typeof FG_QCScalarFieldEnum]


  export const WIP_WASTAGE_LOGSScalarFieldEnum: {
    id: 'id',
    transactionId: 'transactionId',
    transactionType: 'transactionType',
    wipId: 'wipId',
    quantity: 'quantity',
    reason: 'reason',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type WIP_WASTAGE_LOGSScalarFieldEnum = (typeof WIP_WASTAGE_LOGSScalarFieldEnum)[keyof typeof WIP_WASTAGE_LOGSScalarFieldEnum]


  export const FG_WASTAGE_LOGSScalarFieldEnum: {
    id: 'id',
    transactionId: 'transactionId',
    transactionType: 'transactionType',
    fgId: 'fgId',
    quantity: 'quantity',
    reason: 'reason',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type FG_WASTAGE_LOGSScalarFieldEnum = (typeof FG_WASTAGE_LOGSScalarFieldEnum)[keyof typeof FG_WASTAGE_LOGSScalarFieldEnum]


  export const AuditLogsScalarFieldEnum: {
    id: 'id',
    tableName: 'tableName',
    action: 'action',
    oldValue: 'oldValue',
    newValue: 'newValue',
    changedById: 'changedById',
    createdAt: 'createdAt'
  };

  export type AuditLogsScalarFieldEnum = (typeof AuditLogsScalarFieldEnum)[keyof typeof AuditLogsScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const RAW_MATERIALSOrderByRelevanceFieldEnum: {
    name: 'name',
    SKU: 'SKU',
    image: 'image',
    description: 'description',
    storage_location: 'storage_location'
  };

  export type RAW_MATERIALSOrderByRelevanceFieldEnum = (typeof RAW_MATERIALSOrderByRelevanceFieldEnum)[keyof typeof RAW_MATERIALSOrderByRelevanceFieldEnum]


  export const SHOPIFY_VARIANTSOrderByRelevanceFieldEnum: {
    name: 'name',
    img: 'img',
    variantName: 'variantName',
    variantOption: 'variantOption'
  };

  export type SHOPIFY_VARIANTSOrderByRelevanceFieldEnum = (typeof SHOPIFY_VARIANTSOrderByRelevanceFieldEnum)[keyof typeof SHOPIFY_VARIANTSOrderByRelevanceFieldEnum]


  export const CATEGORIESOrderByRelevanceFieldEnum: {
    name: 'name'
  };

  export type CATEGORIESOrderByRelevanceFieldEnum = (typeof CATEGORIESOrderByRelevanceFieldEnum)[keyof typeof CATEGORIESOrderByRelevanceFieldEnum]


  export const SHOPIFY_PRODUCTSOrderByRelevanceFieldEnum: {
    name: 'name',
    status: 'status',
    img: 'img'
  };

  export type SHOPIFY_PRODUCTSOrderByRelevanceFieldEnum = (typeof SHOPIFY_PRODUCTSOrderByRelevanceFieldEnum)[keyof typeof SHOPIFY_PRODUCTSOrderByRelevanceFieldEnum]


  export const RM_TRANSACTIONSOrderByRelevanceFieldEnum: {
    reason: 'reason',
    status: 'status'
  };

  export type RM_TRANSACTIONSOrderByRelevanceFieldEnum = (typeof RM_TRANSACTIONSOrderByRelevanceFieldEnum)[keyof typeof RM_TRANSACTIONSOrderByRelevanceFieldEnum]


  export const RM_WASTAGE_LOGSOrderByRelevanceFieldEnum: {
    reason: 'reason'
  };

  export type RM_WASTAGE_LOGSOrderByRelevanceFieldEnum = (typeof RM_WASTAGE_LOGSOrderByRelevanceFieldEnum)[keyof typeof RM_WASTAGE_LOGSOrderByRelevanceFieldEnum]


  export const EmployeeOrderByRelevanceFieldEnum: {
    name: 'name'
  };

  export type EmployeeOrderByRelevanceFieldEnum = (typeof EmployeeOrderByRelevanceFieldEnum)[keyof typeof EmployeeOrderByRelevanceFieldEnum]


  export const FGOrderByRelevanceFieldEnum: {
    customerName: 'customerName'
  };

  export type FGOrderByRelevanceFieldEnum = (typeof FGOrderByRelevanceFieldEnum)[keyof typeof FGOrderByRelevanceFieldEnum]


  export const WIP_TRANSACTIONSOrderByRelevanceFieldEnum: {
    reason: 'reason'
  };

  export type WIP_TRANSACTIONSOrderByRelevanceFieldEnum = (typeof WIP_TRANSACTIONSOrderByRelevanceFieldEnum)[keyof typeof WIP_TRANSACTIONSOrderByRelevanceFieldEnum]


  export const FG_TRANSACTIONSOrderByRelevanceFieldEnum: {
    reason: 'reason'
  };

  export type FG_TRANSACTIONSOrderByRelevanceFieldEnum = (typeof FG_TRANSACTIONSOrderByRelevanceFieldEnum)[keyof typeof FG_TRANSACTIONSOrderByRelevanceFieldEnum]


  export const WIP_WASTAGE_LOGSOrderByRelevanceFieldEnum: {
    reason: 'reason'
  };

  export type WIP_WASTAGE_LOGSOrderByRelevanceFieldEnum = (typeof WIP_WASTAGE_LOGSOrderByRelevanceFieldEnum)[keyof typeof WIP_WASTAGE_LOGSOrderByRelevanceFieldEnum]


  export const FG_WASTAGE_LOGSOrderByRelevanceFieldEnum: {
    reason: 'reason'
  };

  export type FG_WASTAGE_LOGSOrderByRelevanceFieldEnum = (typeof FG_WASTAGE_LOGSOrderByRelevanceFieldEnum)[keyof typeof FG_WASTAGE_LOGSOrderByRelevanceFieldEnum]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  export const AuditLogsOrderByRelevanceFieldEnum: {
    tableName: 'tableName'
  };

  export type AuditLogsOrderByRelevanceFieldEnum = (typeof AuditLogsOrderByRelevanceFieldEnum)[keyof typeof AuditLogsOrderByRelevanceFieldEnum]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'BigInt'
   */
  export type BigIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BigInt'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Decimal'
   */
  export type DecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'QualityStatus'
   */
  export type EnumQualityStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QualityStatus'>
    


  /**
   * Reference to a field of type 'TransactionType'
   */
  export type EnumTransactionTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TransactionType'>
    


  /**
   * Reference to a field of type 'Roles'
   */
  export type EnumRolesFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Roles'>
    


  /**
   * Reference to a field of type 'Status'
   */
  export type EnumStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Status'>
    


  /**
   * Reference to a field of type 'Actions'
   */
  export type EnumActionsFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Actions'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    
  /**
   * Deep Input Types
   */


  export type RAW_MATERIALSWhereInput = {
    AND?: RAW_MATERIALSWhereInput | RAW_MATERIALSWhereInput[]
    OR?: RAW_MATERIALSWhereInput[]
    NOT?: RAW_MATERIALSWhereInput | RAW_MATERIALSWhereInput[]
    id?: BigIntFilter<"RAW_MATERIALS"> | bigint | number
    name?: StringFilter<"RAW_MATERIALS"> | string
    SKU?: StringFilter<"RAW_MATERIALS"> | string
    quantity?: IntFilter<"RAW_MATERIALS"> | number
    price?: DecimalFilter<"RAW_MATERIALS"> | Decimal | DecimalJsLike | number | string
    image?: StringNullableFilter<"RAW_MATERIALS"> | string | null
    description?: StringNullableFilter<"RAW_MATERIALS"> | string | null
    expiry_date?: DateTimeFilter<"RAW_MATERIALS"> | Date | string
    quality_status?: EnumQualityStatusFilter<"RAW_MATERIALS"> | $Enums.QualityStatus
    storage_location?: StringFilter<"RAW_MATERIALS"> | string
    createdAt?: DateTimeFilter<"RAW_MATERIALS"> | Date | string
    updatedAt?: DateTimeFilter<"RAW_MATERIALS"> | Date | string
    deletedAt?: DateTimeNullableFilter<"RAW_MATERIALS"> | Date | string | null
    VariantMaterials?: VARIANT_RAW_MATERIALS_TRACKERListRelationFilter
    RMTransactions?: RM_TRANSACTIONSListRelationFilter
    RMQualityChecks?: RM_QCListRelationFilter
    RMWastageLogs?: RM_WASTAGE_LOGSListRelationFilter
    WIPMaterials?: WIPRawMaterialListRelationFilter
  }

  export type RAW_MATERIALSOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    SKU?: SortOrder
    quantity?: SortOrder
    price?: SortOrder
    image?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    expiry_date?: SortOrder
    quality_status?: SortOrder
    storage_location?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    VariantMaterials?: VARIANT_RAW_MATERIALS_TRACKEROrderByRelationAggregateInput
    RMTransactions?: RM_TRANSACTIONSOrderByRelationAggregateInput
    RMQualityChecks?: RM_QCOrderByRelationAggregateInput
    RMWastageLogs?: RM_WASTAGE_LOGSOrderByRelationAggregateInput
    WIPMaterials?: WIPRawMaterialOrderByRelationAggregateInput
    _relevance?: RAW_MATERIALSOrderByRelevanceInput
  }

  export type RAW_MATERIALSWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    AND?: RAW_MATERIALSWhereInput | RAW_MATERIALSWhereInput[]
    OR?: RAW_MATERIALSWhereInput[]
    NOT?: RAW_MATERIALSWhereInput | RAW_MATERIALSWhereInput[]
    name?: StringFilter<"RAW_MATERIALS"> | string
    SKU?: StringFilter<"RAW_MATERIALS"> | string
    quantity?: IntFilter<"RAW_MATERIALS"> | number
    price?: DecimalFilter<"RAW_MATERIALS"> | Decimal | DecimalJsLike | number | string
    image?: StringNullableFilter<"RAW_MATERIALS"> | string | null
    description?: StringNullableFilter<"RAW_MATERIALS"> | string | null
    expiry_date?: DateTimeFilter<"RAW_MATERIALS"> | Date | string
    quality_status?: EnumQualityStatusFilter<"RAW_MATERIALS"> | $Enums.QualityStatus
    storage_location?: StringFilter<"RAW_MATERIALS"> | string
    createdAt?: DateTimeFilter<"RAW_MATERIALS"> | Date | string
    updatedAt?: DateTimeFilter<"RAW_MATERIALS"> | Date | string
    deletedAt?: DateTimeNullableFilter<"RAW_MATERIALS"> | Date | string | null
    VariantMaterials?: VARIANT_RAW_MATERIALS_TRACKERListRelationFilter
    RMTransactions?: RM_TRANSACTIONSListRelationFilter
    RMQualityChecks?: RM_QCListRelationFilter
    RMWastageLogs?: RM_WASTAGE_LOGSListRelationFilter
    WIPMaterials?: WIPRawMaterialListRelationFilter
  }, "id">

  export type RAW_MATERIALSOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    SKU?: SortOrder
    quantity?: SortOrder
    price?: SortOrder
    image?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    expiry_date?: SortOrder
    quality_status?: SortOrder
    storage_location?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    _count?: RAW_MATERIALSCountOrderByAggregateInput
    _avg?: RAW_MATERIALSAvgOrderByAggregateInput
    _max?: RAW_MATERIALSMaxOrderByAggregateInput
    _min?: RAW_MATERIALSMinOrderByAggregateInput
    _sum?: RAW_MATERIALSSumOrderByAggregateInput
  }

  export type RAW_MATERIALSScalarWhereWithAggregatesInput = {
    AND?: RAW_MATERIALSScalarWhereWithAggregatesInput | RAW_MATERIALSScalarWhereWithAggregatesInput[]
    OR?: RAW_MATERIALSScalarWhereWithAggregatesInput[]
    NOT?: RAW_MATERIALSScalarWhereWithAggregatesInput | RAW_MATERIALSScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<"RAW_MATERIALS"> | bigint | number
    name?: StringWithAggregatesFilter<"RAW_MATERIALS"> | string
    SKU?: StringWithAggregatesFilter<"RAW_MATERIALS"> | string
    quantity?: IntWithAggregatesFilter<"RAW_MATERIALS"> | number
    price?: DecimalWithAggregatesFilter<"RAW_MATERIALS"> | Decimal | DecimalJsLike | number | string
    image?: StringNullableWithAggregatesFilter<"RAW_MATERIALS"> | string | null
    description?: StringNullableWithAggregatesFilter<"RAW_MATERIALS"> | string | null
    expiry_date?: DateTimeWithAggregatesFilter<"RAW_MATERIALS"> | Date | string
    quality_status?: EnumQualityStatusWithAggregatesFilter<"RAW_MATERIALS"> | $Enums.QualityStatus
    storage_location?: StringWithAggregatesFilter<"RAW_MATERIALS"> | string
    createdAt?: DateTimeWithAggregatesFilter<"RAW_MATERIALS"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"RAW_MATERIALS"> | Date | string
    deletedAt?: DateTimeNullableWithAggregatesFilter<"RAW_MATERIALS"> | Date | string | null
  }

  export type SHOPIFY_VARIANTSWhereInput = {
    AND?: SHOPIFY_VARIANTSWhereInput | SHOPIFY_VARIANTSWhereInput[]
    OR?: SHOPIFY_VARIANTSWhereInput[]
    NOT?: SHOPIFY_VARIANTSWhereInput | SHOPIFY_VARIANTSWhereInput[]
    id?: BigIntFilter<"SHOPIFY_VARIANTS"> | bigint | number
    productId?: BigIntFilter<"SHOPIFY_VARIANTS"> | bigint | number
    name?: StringFilter<"SHOPIFY_VARIANTS"> | string
    AvailableQty?: IntFilter<"SHOPIFY_VARIANTS"> | number
    img?: StringNullableFilter<"SHOPIFY_VARIANTS"> | string | null
    createdAt?: DateTimeFilter<"SHOPIFY_VARIANTS"> | Date | string
    updatedAt?: DateTimeFilter<"SHOPIFY_VARIANTS"> | Date | string
    deletedAt?: DateTimeNullableFilter<"SHOPIFY_VARIANTS"> | Date | string | null
    variantName?: StringNullableFilter<"SHOPIFY_VARIANTS"> | string | null
    variantOption?: StringNullableFilter<"SHOPIFY_VARIANTS"> | string | null
    product?: XOR<SHOPIFY_PRODUCTSScalarRelationFilter, SHOPIFY_PRODUCTSWhereInput>
    VariantMaterials?: VARIANT_RAW_MATERIALS_TRACKERListRelationFilter
  }

  export type SHOPIFY_VARIANTSOrderByWithRelationInput = {
    id?: SortOrder
    productId?: SortOrder
    name?: SortOrder
    AvailableQty?: SortOrder
    img?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    variantName?: SortOrderInput | SortOrder
    variantOption?: SortOrderInput | SortOrder
    product?: SHOPIFY_PRODUCTSOrderByWithRelationInput
    VariantMaterials?: VARIANT_RAW_MATERIALS_TRACKEROrderByRelationAggregateInput
    _relevance?: SHOPIFY_VARIANTSOrderByRelevanceInput
  }

  export type SHOPIFY_VARIANTSWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    AND?: SHOPIFY_VARIANTSWhereInput | SHOPIFY_VARIANTSWhereInput[]
    OR?: SHOPIFY_VARIANTSWhereInput[]
    NOT?: SHOPIFY_VARIANTSWhereInput | SHOPIFY_VARIANTSWhereInput[]
    productId?: BigIntFilter<"SHOPIFY_VARIANTS"> | bigint | number
    name?: StringFilter<"SHOPIFY_VARIANTS"> | string
    AvailableQty?: IntFilter<"SHOPIFY_VARIANTS"> | number
    img?: StringNullableFilter<"SHOPIFY_VARIANTS"> | string | null
    createdAt?: DateTimeFilter<"SHOPIFY_VARIANTS"> | Date | string
    updatedAt?: DateTimeFilter<"SHOPIFY_VARIANTS"> | Date | string
    deletedAt?: DateTimeNullableFilter<"SHOPIFY_VARIANTS"> | Date | string | null
    variantName?: StringNullableFilter<"SHOPIFY_VARIANTS"> | string | null
    variantOption?: StringNullableFilter<"SHOPIFY_VARIANTS"> | string | null
    product?: XOR<SHOPIFY_PRODUCTSScalarRelationFilter, SHOPIFY_PRODUCTSWhereInput>
    VariantMaterials?: VARIANT_RAW_MATERIALS_TRACKERListRelationFilter
  }, "id">

  export type SHOPIFY_VARIANTSOrderByWithAggregationInput = {
    id?: SortOrder
    productId?: SortOrder
    name?: SortOrder
    AvailableQty?: SortOrder
    img?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    variantName?: SortOrderInput | SortOrder
    variantOption?: SortOrderInput | SortOrder
    _count?: SHOPIFY_VARIANTSCountOrderByAggregateInput
    _avg?: SHOPIFY_VARIANTSAvgOrderByAggregateInput
    _max?: SHOPIFY_VARIANTSMaxOrderByAggregateInput
    _min?: SHOPIFY_VARIANTSMinOrderByAggregateInput
    _sum?: SHOPIFY_VARIANTSSumOrderByAggregateInput
  }

  export type SHOPIFY_VARIANTSScalarWhereWithAggregatesInput = {
    AND?: SHOPIFY_VARIANTSScalarWhereWithAggregatesInput | SHOPIFY_VARIANTSScalarWhereWithAggregatesInput[]
    OR?: SHOPIFY_VARIANTSScalarWhereWithAggregatesInput[]
    NOT?: SHOPIFY_VARIANTSScalarWhereWithAggregatesInput | SHOPIFY_VARIANTSScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<"SHOPIFY_VARIANTS"> | bigint | number
    productId?: BigIntWithAggregatesFilter<"SHOPIFY_VARIANTS"> | bigint | number
    name?: StringWithAggregatesFilter<"SHOPIFY_VARIANTS"> | string
    AvailableQty?: IntWithAggregatesFilter<"SHOPIFY_VARIANTS"> | number
    img?: StringNullableWithAggregatesFilter<"SHOPIFY_VARIANTS"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"SHOPIFY_VARIANTS"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"SHOPIFY_VARIANTS"> | Date | string
    deletedAt?: DateTimeNullableWithAggregatesFilter<"SHOPIFY_VARIANTS"> | Date | string | null
    variantName?: StringNullableWithAggregatesFilter<"SHOPIFY_VARIANTS"> | string | null
    variantOption?: StringNullableWithAggregatesFilter<"SHOPIFY_VARIANTS"> | string | null
  }

  export type VARIANT_RAW_MATERIALS_TRACKERWhereInput = {
    AND?: VARIANT_RAW_MATERIALS_TRACKERWhereInput | VARIANT_RAW_MATERIALS_TRACKERWhereInput[]
    OR?: VARIANT_RAW_MATERIALS_TRACKERWhereInput[]
    NOT?: VARIANT_RAW_MATERIALS_TRACKERWhereInput | VARIANT_RAW_MATERIALS_TRACKERWhereInput[]
    variantId?: BigIntFilter<"VARIANT_RAW_MATERIALS_TRACKER"> | bigint | number
    rawMaterialId?: BigIntFilter<"VARIANT_RAW_MATERIALS_TRACKER"> | bigint | number
    avgQuantity?: DecimalFilter<"VARIANT_RAW_MATERIALS_TRACKER"> | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFilter<"VARIANT_RAW_MATERIALS_TRACKER"> | Date | string
    updatedAt?: DateTimeFilter<"VARIANT_RAW_MATERIALS_TRACKER"> | Date | string
    deletedAt?: DateTimeNullableFilter<"VARIANT_RAW_MATERIALS_TRACKER"> | Date | string | null
    variant?: XOR<SHOPIFY_VARIANTSScalarRelationFilter, SHOPIFY_VARIANTSWhereInput>
    rawMaterial?: XOR<RAW_MATERIALSScalarRelationFilter, RAW_MATERIALSWhereInput>
  }

  export type VARIANT_RAW_MATERIALS_TRACKEROrderByWithRelationInput = {
    variantId?: SortOrder
    rawMaterialId?: SortOrder
    avgQuantity?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    variant?: SHOPIFY_VARIANTSOrderByWithRelationInput
    rawMaterial?: RAW_MATERIALSOrderByWithRelationInput
  }

  export type VARIANT_RAW_MATERIALS_TRACKERWhereUniqueInput = Prisma.AtLeast<{
    variantId_rawMaterialId?: VARIANT_RAW_MATERIALS_TRACKERVariantIdRawMaterialIdCompoundUniqueInput
    AND?: VARIANT_RAW_MATERIALS_TRACKERWhereInput | VARIANT_RAW_MATERIALS_TRACKERWhereInput[]
    OR?: VARIANT_RAW_MATERIALS_TRACKERWhereInput[]
    NOT?: VARIANT_RAW_MATERIALS_TRACKERWhereInput | VARIANT_RAW_MATERIALS_TRACKERWhereInput[]
    variantId?: BigIntFilter<"VARIANT_RAW_MATERIALS_TRACKER"> | bigint | number
    rawMaterialId?: BigIntFilter<"VARIANT_RAW_MATERIALS_TRACKER"> | bigint | number
    avgQuantity?: DecimalFilter<"VARIANT_RAW_MATERIALS_TRACKER"> | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFilter<"VARIANT_RAW_MATERIALS_TRACKER"> | Date | string
    updatedAt?: DateTimeFilter<"VARIANT_RAW_MATERIALS_TRACKER"> | Date | string
    deletedAt?: DateTimeNullableFilter<"VARIANT_RAW_MATERIALS_TRACKER"> | Date | string | null
    variant?: XOR<SHOPIFY_VARIANTSScalarRelationFilter, SHOPIFY_VARIANTSWhereInput>
    rawMaterial?: XOR<RAW_MATERIALSScalarRelationFilter, RAW_MATERIALSWhereInput>
  }, "variantId_rawMaterialId">

  export type VARIANT_RAW_MATERIALS_TRACKEROrderByWithAggregationInput = {
    variantId?: SortOrder
    rawMaterialId?: SortOrder
    avgQuantity?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    _count?: VARIANT_RAW_MATERIALS_TRACKERCountOrderByAggregateInput
    _avg?: VARIANT_RAW_MATERIALS_TRACKERAvgOrderByAggregateInput
    _max?: VARIANT_RAW_MATERIALS_TRACKERMaxOrderByAggregateInput
    _min?: VARIANT_RAW_MATERIALS_TRACKERMinOrderByAggregateInput
    _sum?: VARIANT_RAW_MATERIALS_TRACKERSumOrderByAggregateInput
  }

  export type VARIANT_RAW_MATERIALS_TRACKERScalarWhereWithAggregatesInput = {
    AND?: VARIANT_RAW_MATERIALS_TRACKERScalarWhereWithAggregatesInput | VARIANT_RAW_MATERIALS_TRACKERScalarWhereWithAggregatesInput[]
    OR?: VARIANT_RAW_MATERIALS_TRACKERScalarWhereWithAggregatesInput[]
    NOT?: VARIANT_RAW_MATERIALS_TRACKERScalarWhereWithAggregatesInput | VARIANT_RAW_MATERIALS_TRACKERScalarWhereWithAggregatesInput[]
    variantId?: BigIntWithAggregatesFilter<"VARIANT_RAW_MATERIALS_TRACKER"> | bigint | number
    rawMaterialId?: BigIntWithAggregatesFilter<"VARIANT_RAW_MATERIALS_TRACKER"> | bigint | number
    avgQuantity?: DecimalWithAggregatesFilter<"VARIANT_RAW_MATERIALS_TRACKER"> | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeWithAggregatesFilter<"VARIANT_RAW_MATERIALS_TRACKER"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"VARIANT_RAW_MATERIALS_TRACKER"> | Date | string
    deletedAt?: DateTimeNullableWithAggregatesFilter<"VARIANT_RAW_MATERIALS_TRACKER"> | Date | string | null
  }

  export type CATEGORIESWhereInput = {
    AND?: CATEGORIESWhereInput | CATEGORIESWhereInput[]
    OR?: CATEGORIESWhereInput[]
    NOT?: CATEGORIESWhereInput | CATEGORIESWhereInput[]
    id?: IntFilter<"CATEGORIES"> | number
    name?: StringFilter<"CATEGORIES"> | string
    createdAt?: DateTimeFilter<"CATEGORIES"> | Date | string
    updatedAt?: DateTimeFilter<"CATEGORIES"> | Date | string
    ShopifyProducts?: SHOPIFY_PRODUCTSListRelationFilter
  }

  export type CATEGORIESOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    ShopifyProducts?: SHOPIFY_PRODUCTSOrderByRelationAggregateInput
    _relevance?: CATEGORIESOrderByRelevanceInput
  }

  export type CATEGORIESWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: CATEGORIESWhereInput | CATEGORIESWhereInput[]
    OR?: CATEGORIESWhereInput[]
    NOT?: CATEGORIESWhereInput | CATEGORIESWhereInput[]
    name?: StringFilter<"CATEGORIES"> | string
    createdAt?: DateTimeFilter<"CATEGORIES"> | Date | string
    updatedAt?: DateTimeFilter<"CATEGORIES"> | Date | string
    ShopifyProducts?: SHOPIFY_PRODUCTSListRelationFilter
  }, "id">

  export type CATEGORIESOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CATEGORIESCountOrderByAggregateInput
    _avg?: CATEGORIESAvgOrderByAggregateInput
    _max?: CATEGORIESMaxOrderByAggregateInput
    _min?: CATEGORIESMinOrderByAggregateInput
    _sum?: CATEGORIESSumOrderByAggregateInput
  }

  export type CATEGORIESScalarWhereWithAggregatesInput = {
    AND?: CATEGORIESScalarWhereWithAggregatesInput | CATEGORIESScalarWhereWithAggregatesInput[]
    OR?: CATEGORIESScalarWhereWithAggregatesInput[]
    NOT?: CATEGORIESScalarWhereWithAggregatesInput | CATEGORIESScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"CATEGORIES"> | number
    name?: StringWithAggregatesFilter<"CATEGORIES"> | string
    createdAt?: DateTimeWithAggregatesFilter<"CATEGORIES"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"CATEGORIES"> | Date | string
  }

  export type SHOPIFY_PRODUCTSWhereInput = {
    AND?: SHOPIFY_PRODUCTSWhereInput | SHOPIFY_PRODUCTSWhereInput[]
    OR?: SHOPIFY_PRODUCTSWhereInput[]
    NOT?: SHOPIFY_PRODUCTSWhereInput | SHOPIFY_PRODUCTSWhereInput[]
    id?: BigIntFilter<"SHOPIFY_PRODUCTS"> | bigint | number
    name?: StringFilter<"SHOPIFY_PRODUCTS"> | string
    categoryId?: IntFilter<"SHOPIFY_PRODUCTS"> | number
    price?: DecimalFilter<"SHOPIFY_PRODUCTS"> | Decimal | DecimalJsLike | number | string
    status?: StringNullableFilter<"SHOPIFY_PRODUCTS"> | string | null
    img?: StringNullableFilter<"SHOPIFY_PRODUCTS"> | string | null
    createdAt?: DateTimeFilter<"SHOPIFY_PRODUCTS"> | Date | string
    updatedAt?: DateTimeFilter<"SHOPIFY_PRODUCTS"> | Date | string
    category?: XOR<CATEGORIESScalarRelationFilter, CATEGORIESWhereInput>
    ShopifyVariants?: SHOPIFY_VARIANTSListRelationFilter
    WIPProducts?: WIP_PRODUCTSListRelationFilter
  }

  export type SHOPIFY_PRODUCTSOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    categoryId?: SortOrder
    price?: SortOrder
    status?: SortOrderInput | SortOrder
    img?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    category?: CATEGORIESOrderByWithRelationInput
    ShopifyVariants?: SHOPIFY_VARIANTSOrderByRelationAggregateInput
    WIPProducts?: WIP_PRODUCTSOrderByRelationAggregateInput
    _relevance?: SHOPIFY_PRODUCTSOrderByRelevanceInput
  }

  export type SHOPIFY_PRODUCTSWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    AND?: SHOPIFY_PRODUCTSWhereInput | SHOPIFY_PRODUCTSWhereInput[]
    OR?: SHOPIFY_PRODUCTSWhereInput[]
    NOT?: SHOPIFY_PRODUCTSWhereInput | SHOPIFY_PRODUCTSWhereInput[]
    name?: StringFilter<"SHOPIFY_PRODUCTS"> | string
    categoryId?: IntFilter<"SHOPIFY_PRODUCTS"> | number
    price?: DecimalFilter<"SHOPIFY_PRODUCTS"> | Decimal | DecimalJsLike | number | string
    status?: StringNullableFilter<"SHOPIFY_PRODUCTS"> | string | null
    img?: StringNullableFilter<"SHOPIFY_PRODUCTS"> | string | null
    createdAt?: DateTimeFilter<"SHOPIFY_PRODUCTS"> | Date | string
    updatedAt?: DateTimeFilter<"SHOPIFY_PRODUCTS"> | Date | string
    category?: XOR<CATEGORIESScalarRelationFilter, CATEGORIESWhereInput>
    ShopifyVariants?: SHOPIFY_VARIANTSListRelationFilter
    WIPProducts?: WIP_PRODUCTSListRelationFilter
  }, "id">

  export type SHOPIFY_PRODUCTSOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    categoryId?: SortOrder
    price?: SortOrder
    status?: SortOrderInput | SortOrder
    img?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SHOPIFY_PRODUCTSCountOrderByAggregateInput
    _avg?: SHOPIFY_PRODUCTSAvgOrderByAggregateInput
    _max?: SHOPIFY_PRODUCTSMaxOrderByAggregateInput
    _min?: SHOPIFY_PRODUCTSMinOrderByAggregateInput
    _sum?: SHOPIFY_PRODUCTSSumOrderByAggregateInput
  }

  export type SHOPIFY_PRODUCTSScalarWhereWithAggregatesInput = {
    AND?: SHOPIFY_PRODUCTSScalarWhereWithAggregatesInput | SHOPIFY_PRODUCTSScalarWhereWithAggregatesInput[]
    OR?: SHOPIFY_PRODUCTSScalarWhereWithAggregatesInput[]
    NOT?: SHOPIFY_PRODUCTSScalarWhereWithAggregatesInput | SHOPIFY_PRODUCTSScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<"SHOPIFY_PRODUCTS"> | bigint | number
    name?: StringWithAggregatesFilter<"SHOPIFY_PRODUCTS"> | string
    categoryId?: IntWithAggregatesFilter<"SHOPIFY_PRODUCTS"> | number
    price?: DecimalWithAggregatesFilter<"SHOPIFY_PRODUCTS"> | Decimal | DecimalJsLike | number | string
    status?: StringNullableWithAggregatesFilter<"SHOPIFY_PRODUCTS"> | string | null
    img?: StringNullableWithAggregatesFilter<"SHOPIFY_PRODUCTS"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"SHOPIFY_PRODUCTS"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"SHOPIFY_PRODUCTS"> | Date | string
  }

  export type RM_TRANSACTIONSWhereInput = {
    AND?: RM_TRANSACTIONSWhereInput | RM_TRANSACTIONSWhereInput[]
    OR?: RM_TRANSACTIONSWhereInput[]
    NOT?: RM_TRANSACTIONSWhereInput | RM_TRANSACTIONSWhereInput[]
    id?: IntFilter<"RM_TRANSACTIONS"> | number
    rawMaterialId?: BigIntFilter<"RM_TRANSACTIONS"> | bigint | number
    quantity?: IntFilter<"RM_TRANSACTIONS"> | number
    transactionType?: EnumTransactionTypeFilter<"RM_TRANSACTIONS"> | $Enums.TransactionType
    reason?: StringFilter<"RM_TRANSACTIONS"> | string
    status?: StringFilter<"RM_TRANSACTIONS"> | string
    initiatedById?: IntFilter<"RM_TRANSACTIONS"> | number
    createdAt?: DateTimeFilter<"RM_TRANSACTIONS"> | Date | string
    updatedAt?: DateTimeFilter<"RM_TRANSACTIONS"> | Date | string
    deletedAt?: DateTimeNullableFilter<"RM_TRANSACTIONS"> | Date | string | null
    rawMaterial?: XOR<RAW_MATERIALSScalarRelationFilter, RAW_MATERIALSWhereInput>
    initiatedBy?: XOR<EmployeeScalarRelationFilter, EmployeeWhereInput>
    RMQualityChecks?: RM_QCListRelationFilter
    RMWastageLogs?: RM_WASTAGE_LOGSListRelationFilter
  }

  export type RM_TRANSACTIONSOrderByWithRelationInput = {
    id?: SortOrder
    rawMaterialId?: SortOrder
    quantity?: SortOrder
    transactionType?: SortOrder
    reason?: SortOrder
    status?: SortOrder
    initiatedById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    rawMaterial?: RAW_MATERIALSOrderByWithRelationInput
    initiatedBy?: EmployeeOrderByWithRelationInput
    RMQualityChecks?: RM_QCOrderByRelationAggregateInput
    RMWastageLogs?: RM_WASTAGE_LOGSOrderByRelationAggregateInput
    _relevance?: RM_TRANSACTIONSOrderByRelevanceInput
  }

  export type RM_TRANSACTIONSWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: RM_TRANSACTIONSWhereInput | RM_TRANSACTIONSWhereInput[]
    OR?: RM_TRANSACTIONSWhereInput[]
    NOT?: RM_TRANSACTIONSWhereInput | RM_TRANSACTIONSWhereInput[]
    rawMaterialId?: BigIntFilter<"RM_TRANSACTIONS"> | bigint | number
    quantity?: IntFilter<"RM_TRANSACTIONS"> | number
    transactionType?: EnumTransactionTypeFilter<"RM_TRANSACTIONS"> | $Enums.TransactionType
    reason?: StringFilter<"RM_TRANSACTIONS"> | string
    status?: StringFilter<"RM_TRANSACTIONS"> | string
    initiatedById?: IntFilter<"RM_TRANSACTIONS"> | number
    createdAt?: DateTimeFilter<"RM_TRANSACTIONS"> | Date | string
    updatedAt?: DateTimeFilter<"RM_TRANSACTIONS"> | Date | string
    deletedAt?: DateTimeNullableFilter<"RM_TRANSACTIONS"> | Date | string | null
    rawMaterial?: XOR<RAW_MATERIALSScalarRelationFilter, RAW_MATERIALSWhereInput>
    initiatedBy?: XOR<EmployeeScalarRelationFilter, EmployeeWhereInput>
    RMQualityChecks?: RM_QCListRelationFilter
    RMWastageLogs?: RM_WASTAGE_LOGSListRelationFilter
  }, "id">

  export type RM_TRANSACTIONSOrderByWithAggregationInput = {
    id?: SortOrder
    rawMaterialId?: SortOrder
    quantity?: SortOrder
    transactionType?: SortOrder
    reason?: SortOrder
    status?: SortOrder
    initiatedById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    _count?: RM_TRANSACTIONSCountOrderByAggregateInput
    _avg?: RM_TRANSACTIONSAvgOrderByAggregateInput
    _max?: RM_TRANSACTIONSMaxOrderByAggregateInput
    _min?: RM_TRANSACTIONSMinOrderByAggregateInput
    _sum?: RM_TRANSACTIONSSumOrderByAggregateInput
  }

  export type RM_TRANSACTIONSScalarWhereWithAggregatesInput = {
    AND?: RM_TRANSACTIONSScalarWhereWithAggregatesInput | RM_TRANSACTIONSScalarWhereWithAggregatesInput[]
    OR?: RM_TRANSACTIONSScalarWhereWithAggregatesInput[]
    NOT?: RM_TRANSACTIONSScalarWhereWithAggregatesInput | RM_TRANSACTIONSScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"RM_TRANSACTIONS"> | number
    rawMaterialId?: BigIntWithAggregatesFilter<"RM_TRANSACTIONS"> | bigint | number
    quantity?: IntWithAggregatesFilter<"RM_TRANSACTIONS"> | number
    transactionType?: EnumTransactionTypeWithAggregatesFilter<"RM_TRANSACTIONS"> | $Enums.TransactionType
    reason?: StringWithAggregatesFilter<"RM_TRANSACTIONS"> | string
    status?: StringWithAggregatesFilter<"RM_TRANSACTIONS"> | string
    initiatedById?: IntWithAggregatesFilter<"RM_TRANSACTIONS"> | number
    createdAt?: DateTimeWithAggregatesFilter<"RM_TRANSACTIONS"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"RM_TRANSACTIONS"> | Date | string
    deletedAt?: DateTimeNullableWithAggregatesFilter<"RM_TRANSACTIONS"> | Date | string | null
  }

  export type RM_QCWhereInput = {
    AND?: RM_QCWhereInput | RM_QCWhereInput[]
    OR?: RM_QCWhereInput[]
    NOT?: RM_QCWhereInput | RM_QCWhereInput[]
    id?: IntFilter<"RM_QC"> | number
    transactionId?: IntFilter<"RM_QC"> | number
    rawMaterialId?: BigIntFilter<"RM_QC"> | bigint | number
    quality_status?: EnumQualityStatusFilter<"RM_QC"> | $Enums.QualityStatus
    checkedById?: IntFilter<"RM_QC"> | number
    doneById?: IntFilter<"RM_QC"> | number
    createdAt?: DateTimeFilter<"RM_QC"> | Date | string
    updatedAt?: DateTimeFilter<"RM_QC"> | Date | string
    deletedAt?: DateTimeNullableFilter<"RM_QC"> | Date | string | null
    rawMaterial?: XOR<RAW_MATERIALSScalarRelationFilter, RAW_MATERIALSWhereInput>
    transaction?: XOR<RM_TRANSACTIONSScalarRelationFilter, RM_TRANSACTIONSWhereInput>
    checkedBy?: XOR<EmployeeScalarRelationFilter, EmployeeWhereInput>
    doneBy?: XOR<EmployeeScalarRelationFilter, EmployeeWhereInput>
  }

  export type RM_QCOrderByWithRelationInput = {
    id?: SortOrder
    transactionId?: SortOrder
    rawMaterialId?: SortOrder
    quality_status?: SortOrder
    checkedById?: SortOrder
    doneById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    rawMaterial?: RAW_MATERIALSOrderByWithRelationInput
    transaction?: RM_TRANSACTIONSOrderByWithRelationInput
    checkedBy?: EmployeeOrderByWithRelationInput
    doneBy?: EmployeeOrderByWithRelationInput
  }

  export type RM_QCWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: RM_QCWhereInput | RM_QCWhereInput[]
    OR?: RM_QCWhereInput[]
    NOT?: RM_QCWhereInput | RM_QCWhereInput[]
    transactionId?: IntFilter<"RM_QC"> | number
    rawMaterialId?: BigIntFilter<"RM_QC"> | bigint | number
    quality_status?: EnumQualityStatusFilter<"RM_QC"> | $Enums.QualityStatus
    checkedById?: IntFilter<"RM_QC"> | number
    doneById?: IntFilter<"RM_QC"> | number
    createdAt?: DateTimeFilter<"RM_QC"> | Date | string
    updatedAt?: DateTimeFilter<"RM_QC"> | Date | string
    deletedAt?: DateTimeNullableFilter<"RM_QC"> | Date | string | null
    rawMaterial?: XOR<RAW_MATERIALSScalarRelationFilter, RAW_MATERIALSWhereInput>
    transaction?: XOR<RM_TRANSACTIONSScalarRelationFilter, RM_TRANSACTIONSWhereInput>
    checkedBy?: XOR<EmployeeScalarRelationFilter, EmployeeWhereInput>
    doneBy?: XOR<EmployeeScalarRelationFilter, EmployeeWhereInput>
  }, "id">

  export type RM_QCOrderByWithAggregationInput = {
    id?: SortOrder
    transactionId?: SortOrder
    rawMaterialId?: SortOrder
    quality_status?: SortOrder
    checkedById?: SortOrder
    doneById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    _count?: RM_QCCountOrderByAggregateInput
    _avg?: RM_QCAvgOrderByAggregateInput
    _max?: RM_QCMaxOrderByAggregateInput
    _min?: RM_QCMinOrderByAggregateInput
    _sum?: RM_QCSumOrderByAggregateInput
  }

  export type RM_QCScalarWhereWithAggregatesInput = {
    AND?: RM_QCScalarWhereWithAggregatesInput | RM_QCScalarWhereWithAggregatesInput[]
    OR?: RM_QCScalarWhereWithAggregatesInput[]
    NOT?: RM_QCScalarWhereWithAggregatesInput | RM_QCScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"RM_QC"> | number
    transactionId?: IntWithAggregatesFilter<"RM_QC"> | number
    rawMaterialId?: BigIntWithAggregatesFilter<"RM_QC"> | bigint | number
    quality_status?: EnumQualityStatusWithAggregatesFilter<"RM_QC"> | $Enums.QualityStatus
    checkedById?: IntWithAggregatesFilter<"RM_QC"> | number
    doneById?: IntWithAggregatesFilter<"RM_QC"> | number
    createdAt?: DateTimeWithAggregatesFilter<"RM_QC"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"RM_QC"> | Date | string
    deletedAt?: DateTimeNullableWithAggregatesFilter<"RM_QC"> | Date | string | null
  }

  export type RM_WASTAGE_LOGSWhereInput = {
    AND?: RM_WASTAGE_LOGSWhereInput | RM_WASTAGE_LOGSWhereInput[]
    OR?: RM_WASTAGE_LOGSWhereInput[]
    NOT?: RM_WASTAGE_LOGSWhereInput | RM_WASTAGE_LOGSWhereInput[]
    id?: IntFilter<"RM_WASTAGE_LOGS"> | number
    transactionId?: IntFilter<"RM_WASTAGE_LOGS"> | number
    rawMaterialId?: BigIntFilter<"RM_WASTAGE_LOGS"> | bigint | number
    quantity?: IntFilter<"RM_WASTAGE_LOGS"> | number
    reason?: StringFilter<"RM_WASTAGE_LOGS"> | string
    createdAt?: DateTimeFilter<"RM_WASTAGE_LOGS"> | Date | string
    updatedAt?: DateTimeFilter<"RM_WASTAGE_LOGS"> | Date | string
    deletedAt?: DateTimeNullableFilter<"RM_WASTAGE_LOGS"> | Date | string | null
    rawMaterial?: XOR<RAW_MATERIALSScalarRelationFilter, RAW_MATERIALSWhereInput>
    transaction?: XOR<RM_TRANSACTIONSScalarRelationFilter, RM_TRANSACTIONSWhereInput>
  }

  export type RM_WASTAGE_LOGSOrderByWithRelationInput = {
    id?: SortOrder
    transactionId?: SortOrder
    rawMaterialId?: SortOrder
    quantity?: SortOrder
    reason?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    rawMaterial?: RAW_MATERIALSOrderByWithRelationInput
    transaction?: RM_TRANSACTIONSOrderByWithRelationInput
    _relevance?: RM_WASTAGE_LOGSOrderByRelevanceInput
  }

  export type RM_WASTAGE_LOGSWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: RM_WASTAGE_LOGSWhereInput | RM_WASTAGE_LOGSWhereInput[]
    OR?: RM_WASTAGE_LOGSWhereInput[]
    NOT?: RM_WASTAGE_LOGSWhereInput | RM_WASTAGE_LOGSWhereInput[]
    transactionId?: IntFilter<"RM_WASTAGE_LOGS"> | number
    rawMaterialId?: BigIntFilter<"RM_WASTAGE_LOGS"> | bigint | number
    quantity?: IntFilter<"RM_WASTAGE_LOGS"> | number
    reason?: StringFilter<"RM_WASTAGE_LOGS"> | string
    createdAt?: DateTimeFilter<"RM_WASTAGE_LOGS"> | Date | string
    updatedAt?: DateTimeFilter<"RM_WASTAGE_LOGS"> | Date | string
    deletedAt?: DateTimeNullableFilter<"RM_WASTAGE_LOGS"> | Date | string | null
    rawMaterial?: XOR<RAW_MATERIALSScalarRelationFilter, RAW_MATERIALSWhereInput>
    transaction?: XOR<RM_TRANSACTIONSScalarRelationFilter, RM_TRANSACTIONSWhereInput>
  }, "id">

  export type RM_WASTAGE_LOGSOrderByWithAggregationInput = {
    id?: SortOrder
    transactionId?: SortOrder
    rawMaterialId?: SortOrder
    quantity?: SortOrder
    reason?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    _count?: RM_WASTAGE_LOGSCountOrderByAggregateInput
    _avg?: RM_WASTAGE_LOGSAvgOrderByAggregateInput
    _max?: RM_WASTAGE_LOGSMaxOrderByAggregateInput
    _min?: RM_WASTAGE_LOGSMinOrderByAggregateInput
    _sum?: RM_WASTAGE_LOGSSumOrderByAggregateInput
  }

  export type RM_WASTAGE_LOGSScalarWhereWithAggregatesInput = {
    AND?: RM_WASTAGE_LOGSScalarWhereWithAggregatesInput | RM_WASTAGE_LOGSScalarWhereWithAggregatesInput[]
    OR?: RM_WASTAGE_LOGSScalarWhereWithAggregatesInput[]
    NOT?: RM_WASTAGE_LOGSScalarWhereWithAggregatesInput | RM_WASTAGE_LOGSScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"RM_WASTAGE_LOGS"> | number
    transactionId?: IntWithAggregatesFilter<"RM_WASTAGE_LOGS"> | number
    rawMaterialId?: BigIntWithAggregatesFilter<"RM_WASTAGE_LOGS"> | bigint | number
    quantity?: IntWithAggregatesFilter<"RM_WASTAGE_LOGS"> | number
    reason?: StringWithAggregatesFilter<"RM_WASTAGE_LOGS"> | string
    createdAt?: DateTimeWithAggregatesFilter<"RM_WASTAGE_LOGS"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"RM_WASTAGE_LOGS"> | Date | string
    deletedAt?: DateTimeNullableWithAggregatesFilter<"RM_WASTAGE_LOGS"> | Date | string | null
  }

  export type EmployeeWhereInput = {
    AND?: EmployeeWhereInput | EmployeeWhereInput[]
    OR?: EmployeeWhereInput[]
    NOT?: EmployeeWhereInput | EmployeeWhereInput[]
    id?: IntFilter<"Employee"> | number
    name?: StringFilter<"Employee"> | string
    role?: EnumRolesFilter<"Employee"> | $Enums.Roles
    createdAt?: DateTimeFilter<"Employee"> | Date | string
    updatedAt?: DateTimeFilter<"Employee"> | Date | string
    deletedAt?: DateTimeNullableFilter<"Employee"> | Date | string | null
    RM_QC?: RM_QCListRelationFilter
    RM_QC2?: RM_QCListRelationFilter
    RMTransactions?: RM_TRANSACTIONSListRelationFilter
    WIPTransactions?: WIP_TRANSACTIONSListRelationFilter
    FGTransactions?: FG_TRANSACTIONSListRelationFilter
    AuditLogs?: AuditLogsListRelationFilter
  }

  export type EmployeeOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    RM_QC?: RM_QCOrderByRelationAggregateInput
    RM_QC2?: RM_QCOrderByRelationAggregateInput
    RMTransactions?: RM_TRANSACTIONSOrderByRelationAggregateInput
    WIPTransactions?: WIP_TRANSACTIONSOrderByRelationAggregateInput
    FGTransactions?: FG_TRANSACTIONSOrderByRelationAggregateInput
    AuditLogs?: AuditLogsOrderByRelationAggregateInput
    _relevance?: EmployeeOrderByRelevanceInput
  }

  export type EmployeeWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: EmployeeWhereInput | EmployeeWhereInput[]
    OR?: EmployeeWhereInput[]
    NOT?: EmployeeWhereInput | EmployeeWhereInput[]
    name?: StringFilter<"Employee"> | string
    role?: EnumRolesFilter<"Employee"> | $Enums.Roles
    createdAt?: DateTimeFilter<"Employee"> | Date | string
    updatedAt?: DateTimeFilter<"Employee"> | Date | string
    deletedAt?: DateTimeNullableFilter<"Employee"> | Date | string | null
    RM_QC?: RM_QCListRelationFilter
    RM_QC2?: RM_QCListRelationFilter
    RMTransactions?: RM_TRANSACTIONSListRelationFilter
    WIPTransactions?: WIP_TRANSACTIONSListRelationFilter
    FGTransactions?: FG_TRANSACTIONSListRelationFilter
    AuditLogs?: AuditLogsListRelationFilter
  }, "id">

  export type EmployeeOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    _count?: EmployeeCountOrderByAggregateInput
    _avg?: EmployeeAvgOrderByAggregateInput
    _max?: EmployeeMaxOrderByAggregateInput
    _min?: EmployeeMinOrderByAggregateInput
    _sum?: EmployeeSumOrderByAggregateInput
  }

  export type EmployeeScalarWhereWithAggregatesInput = {
    AND?: EmployeeScalarWhereWithAggregatesInput | EmployeeScalarWhereWithAggregatesInput[]
    OR?: EmployeeScalarWhereWithAggregatesInput[]
    NOT?: EmployeeScalarWhereWithAggregatesInput | EmployeeScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Employee"> | number
    name?: StringWithAggregatesFilter<"Employee"> | string
    role?: EnumRolesWithAggregatesFilter<"Employee"> | $Enums.Roles
    createdAt?: DateTimeWithAggregatesFilter<"Employee"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Employee"> | Date | string
    deletedAt?: DateTimeNullableWithAggregatesFilter<"Employee"> | Date | string | null
  }

  export type WIPWhereInput = {
    AND?: WIPWhereInput | WIPWhereInput[]
    OR?: WIPWhereInput[]
    NOT?: WIPWhereInput | WIPWhereInput[]
    id?: IntFilter<"WIP"> | number
    orderId?: IntFilter<"WIP"> | number
    status?: EnumStatusFilter<"WIP"> | $Enums.Status
    createdAt?: DateTimeFilter<"WIP"> | Date | string
    updatedAt?: DateTimeFilter<"WIP"> | Date | string
    WIPTransactions?: WIP_TRANSACTIONSListRelationFilter
    WIPQCs?: WIP_QCListRelationFilter
    WIPWastageLogs?: WIP_WASTAGE_LOGSListRelationFilter
    wipProducts?: WIP_PRODUCTSListRelationFilter
    WIPMaterials?: WIPRawMaterialListRelationFilter
  }

  export type WIPOrderByWithRelationInput = {
    id?: SortOrder
    orderId?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    WIPTransactions?: WIP_TRANSACTIONSOrderByRelationAggregateInput
    WIPQCs?: WIP_QCOrderByRelationAggregateInput
    WIPWastageLogs?: WIP_WASTAGE_LOGSOrderByRelationAggregateInput
    wipProducts?: WIP_PRODUCTSOrderByRelationAggregateInput
    WIPMaterials?: WIPRawMaterialOrderByRelationAggregateInput
  }

  export type WIPWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: WIPWhereInput | WIPWhereInput[]
    OR?: WIPWhereInput[]
    NOT?: WIPWhereInput | WIPWhereInput[]
    orderId?: IntFilter<"WIP"> | number
    status?: EnumStatusFilter<"WIP"> | $Enums.Status
    createdAt?: DateTimeFilter<"WIP"> | Date | string
    updatedAt?: DateTimeFilter<"WIP"> | Date | string
    WIPTransactions?: WIP_TRANSACTIONSListRelationFilter
    WIPQCs?: WIP_QCListRelationFilter
    WIPWastageLogs?: WIP_WASTAGE_LOGSListRelationFilter
    wipProducts?: WIP_PRODUCTSListRelationFilter
    WIPMaterials?: WIPRawMaterialListRelationFilter
  }, "id">

  export type WIPOrderByWithAggregationInput = {
    id?: SortOrder
    orderId?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: WIPCountOrderByAggregateInput
    _avg?: WIPAvgOrderByAggregateInput
    _max?: WIPMaxOrderByAggregateInput
    _min?: WIPMinOrderByAggregateInput
    _sum?: WIPSumOrderByAggregateInput
  }

  export type WIPScalarWhereWithAggregatesInput = {
    AND?: WIPScalarWhereWithAggregatesInput | WIPScalarWhereWithAggregatesInput[]
    OR?: WIPScalarWhereWithAggregatesInput[]
    NOT?: WIPScalarWhereWithAggregatesInput | WIPScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"WIP"> | number
    orderId?: IntWithAggregatesFilter<"WIP"> | number
    status?: EnumStatusWithAggregatesFilter<"WIP"> | $Enums.Status
    createdAt?: DateTimeWithAggregatesFilter<"WIP"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"WIP"> | Date | string
  }

  export type WIP_PRODUCTSWhereInput = {
    AND?: WIP_PRODUCTSWhereInput | WIP_PRODUCTSWhereInput[]
    OR?: WIP_PRODUCTSWhereInput[]
    NOT?: WIP_PRODUCTSWhereInput | WIP_PRODUCTSWhereInput[]
    id?: IntFilter<"WIP_PRODUCTS"> | number
    wipId?: IntFilter<"WIP_PRODUCTS"> | number
    productId?: BigIntFilter<"WIP_PRODUCTS"> | bigint | number
    quantity?: IntFilter<"WIP_PRODUCTS"> | number
    wip?: XOR<WIPScalarRelationFilter, WIPWhereInput>
    product?: XOR<SHOPIFY_PRODUCTSScalarRelationFilter, SHOPIFY_PRODUCTSWhereInput>
  }

  export type WIP_PRODUCTSOrderByWithRelationInput = {
    id?: SortOrder
    wipId?: SortOrder
    productId?: SortOrder
    quantity?: SortOrder
    wip?: WIPOrderByWithRelationInput
    product?: SHOPIFY_PRODUCTSOrderByWithRelationInput
  }

  export type WIP_PRODUCTSWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: WIP_PRODUCTSWhereInput | WIP_PRODUCTSWhereInput[]
    OR?: WIP_PRODUCTSWhereInput[]
    NOT?: WIP_PRODUCTSWhereInput | WIP_PRODUCTSWhereInput[]
    wipId?: IntFilter<"WIP_PRODUCTS"> | number
    productId?: BigIntFilter<"WIP_PRODUCTS"> | bigint | number
    quantity?: IntFilter<"WIP_PRODUCTS"> | number
    wip?: XOR<WIPScalarRelationFilter, WIPWhereInput>
    product?: XOR<SHOPIFY_PRODUCTSScalarRelationFilter, SHOPIFY_PRODUCTSWhereInput>
  }, "id">

  export type WIP_PRODUCTSOrderByWithAggregationInput = {
    id?: SortOrder
    wipId?: SortOrder
    productId?: SortOrder
    quantity?: SortOrder
    _count?: WIP_PRODUCTSCountOrderByAggregateInput
    _avg?: WIP_PRODUCTSAvgOrderByAggregateInput
    _max?: WIP_PRODUCTSMaxOrderByAggregateInput
    _min?: WIP_PRODUCTSMinOrderByAggregateInput
    _sum?: WIP_PRODUCTSSumOrderByAggregateInput
  }

  export type WIP_PRODUCTSScalarWhereWithAggregatesInput = {
    AND?: WIP_PRODUCTSScalarWhereWithAggregatesInput | WIP_PRODUCTSScalarWhereWithAggregatesInput[]
    OR?: WIP_PRODUCTSScalarWhereWithAggregatesInput[]
    NOT?: WIP_PRODUCTSScalarWhereWithAggregatesInput | WIP_PRODUCTSScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"WIP_PRODUCTS"> | number
    wipId?: IntWithAggregatesFilter<"WIP_PRODUCTS"> | number
    productId?: BigIntWithAggregatesFilter<"WIP_PRODUCTS"> | bigint | number
    quantity?: IntWithAggregatesFilter<"WIP_PRODUCTS"> | number
  }

  export type WIPRawMaterialWhereInput = {
    AND?: WIPRawMaterialWhereInput | WIPRawMaterialWhereInput[]
    OR?: WIPRawMaterialWhereInput[]
    NOT?: WIPRawMaterialWhereInput | WIPRawMaterialWhereInput[]
    id?: IntFilter<"WIPRawMaterial"> | number
    wipId?: IntFilter<"WIPRawMaterial"> | number
    rawMaterialId?: BigIntFilter<"WIPRawMaterial"> | bigint | number
    quantity?: IntFilter<"WIPRawMaterial"> | number
    wip?: XOR<WIPScalarRelationFilter, WIPWhereInput>
    rawMaterial?: XOR<RAW_MATERIALSScalarRelationFilter, RAW_MATERIALSWhereInput>
  }

  export type WIPRawMaterialOrderByWithRelationInput = {
    id?: SortOrder
    wipId?: SortOrder
    rawMaterialId?: SortOrder
    quantity?: SortOrder
    wip?: WIPOrderByWithRelationInput
    rawMaterial?: RAW_MATERIALSOrderByWithRelationInput
  }

  export type WIPRawMaterialWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: WIPRawMaterialWhereInput | WIPRawMaterialWhereInput[]
    OR?: WIPRawMaterialWhereInput[]
    NOT?: WIPRawMaterialWhereInput | WIPRawMaterialWhereInput[]
    wipId?: IntFilter<"WIPRawMaterial"> | number
    rawMaterialId?: BigIntFilter<"WIPRawMaterial"> | bigint | number
    quantity?: IntFilter<"WIPRawMaterial"> | number
    wip?: XOR<WIPScalarRelationFilter, WIPWhereInput>
    rawMaterial?: XOR<RAW_MATERIALSScalarRelationFilter, RAW_MATERIALSWhereInput>
  }, "id">

  export type WIPRawMaterialOrderByWithAggregationInput = {
    id?: SortOrder
    wipId?: SortOrder
    rawMaterialId?: SortOrder
    quantity?: SortOrder
    _count?: WIPRawMaterialCountOrderByAggregateInput
    _avg?: WIPRawMaterialAvgOrderByAggregateInput
    _max?: WIPRawMaterialMaxOrderByAggregateInput
    _min?: WIPRawMaterialMinOrderByAggregateInput
    _sum?: WIPRawMaterialSumOrderByAggregateInput
  }

  export type WIPRawMaterialScalarWhereWithAggregatesInput = {
    AND?: WIPRawMaterialScalarWhereWithAggregatesInput | WIPRawMaterialScalarWhereWithAggregatesInput[]
    OR?: WIPRawMaterialScalarWhereWithAggregatesInput[]
    NOT?: WIPRawMaterialScalarWhereWithAggregatesInput | WIPRawMaterialScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"WIPRawMaterial"> | number
    wipId?: IntWithAggregatesFilter<"WIPRawMaterial"> | number
    rawMaterialId?: BigIntWithAggregatesFilter<"WIPRawMaterial"> | bigint | number
    quantity?: IntWithAggregatesFilter<"WIPRawMaterial"> | number
  }

  export type FGWhereInput = {
    AND?: FGWhereInput | FGWhereInput[]
    OR?: FGWhereInput[]
    NOT?: FGWhereInput | FGWhereInput[]
    id?: IntFilter<"FG"> | number
    orderId?: IntFilter<"FG"> | number
    customerName?: StringFilter<"FG"> | string
    price?: DecimalFilter<"FG"> | Decimal | DecimalJsLike | number | string
    status?: EnumStatusFilter<"FG"> | $Enums.Status
    createdAt?: DateTimeFilter<"FG"> | Date | string
    deliveryDate?: DateTimeFilter<"FG"> | Date | string
    FGTransactions?: FG_TRANSACTIONSListRelationFilter
    FGQCs?: FG_QCListRelationFilter
    FGWastageLogs?: FG_WASTAGE_LOGSListRelationFilter
    fgProducts?: FG_PRODUCTSListRelationFilter
  }

  export type FGOrderByWithRelationInput = {
    id?: SortOrder
    orderId?: SortOrder
    customerName?: SortOrder
    price?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    deliveryDate?: SortOrder
    FGTransactions?: FG_TRANSACTIONSOrderByRelationAggregateInput
    FGQCs?: FG_QCOrderByRelationAggregateInput
    FGWastageLogs?: FG_WASTAGE_LOGSOrderByRelationAggregateInput
    fgProducts?: FG_PRODUCTSOrderByRelationAggregateInput
    _relevance?: FGOrderByRelevanceInput
  }

  export type FGWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: FGWhereInput | FGWhereInput[]
    OR?: FGWhereInput[]
    NOT?: FGWhereInput | FGWhereInput[]
    orderId?: IntFilter<"FG"> | number
    customerName?: StringFilter<"FG"> | string
    price?: DecimalFilter<"FG"> | Decimal | DecimalJsLike | number | string
    status?: EnumStatusFilter<"FG"> | $Enums.Status
    createdAt?: DateTimeFilter<"FG"> | Date | string
    deliveryDate?: DateTimeFilter<"FG"> | Date | string
    FGTransactions?: FG_TRANSACTIONSListRelationFilter
    FGQCs?: FG_QCListRelationFilter
    FGWastageLogs?: FG_WASTAGE_LOGSListRelationFilter
    fgProducts?: FG_PRODUCTSListRelationFilter
  }, "id">

  export type FGOrderByWithAggregationInput = {
    id?: SortOrder
    orderId?: SortOrder
    customerName?: SortOrder
    price?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    deliveryDate?: SortOrder
    _count?: FGCountOrderByAggregateInput
    _avg?: FGAvgOrderByAggregateInput
    _max?: FGMaxOrderByAggregateInput
    _min?: FGMinOrderByAggregateInput
    _sum?: FGSumOrderByAggregateInput
  }

  export type FGScalarWhereWithAggregatesInput = {
    AND?: FGScalarWhereWithAggregatesInput | FGScalarWhereWithAggregatesInput[]
    OR?: FGScalarWhereWithAggregatesInput[]
    NOT?: FGScalarWhereWithAggregatesInput | FGScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"FG"> | number
    orderId?: IntWithAggregatesFilter<"FG"> | number
    customerName?: StringWithAggregatesFilter<"FG"> | string
    price?: DecimalWithAggregatesFilter<"FG"> | Decimal | DecimalJsLike | number | string
    status?: EnumStatusWithAggregatesFilter<"FG"> | $Enums.Status
    createdAt?: DateTimeWithAggregatesFilter<"FG"> | Date | string
    deliveryDate?: DateTimeWithAggregatesFilter<"FG"> | Date | string
  }

  export type FG_PRODUCTSWhereInput = {
    AND?: FG_PRODUCTSWhereInput | FG_PRODUCTSWhereInput[]
    OR?: FG_PRODUCTSWhereInput[]
    NOT?: FG_PRODUCTSWhereInput | FG_PRODUCTSWhereInput[]
    id?: IntFilter<"FG_PRODUCTS"> | number
    fgId?: IntFilter<"FG_PRODUCTS"> | number
    productId?: IntFilter<"FG_PRODUCTS"> | number
    quantity?: IntFilter<"FG_PRODUCTS"> | number
    fg?: XOR<FGScalarRelationFilter, FGWhereInput>
  }

  export type FG_PRODUCTSOrderByWithRelationInput = {
    id?: SortOrder
    fgId?: SortOrder
    productId?: SortOrder
    quantity?: SortOrder
    fg?: FGOrderByWithRelationInput
  }

  export type FG_PRODUCTSWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: FG_PRODUCTSWhereInput | FG_PRODUCTSWhereInput[]
    OR?: FG_PRODUCTSWhereInput[]
    NOT?: FG_PRODUCTSWhereInput | FG_PRODUCTSWhereInput[]
    fgId?: IntFilter<"FG_PRODUCTS"> | number
    productId?: IntFilter<"FG_PRODUCTS"> | number
    quantity?: IntFilter<"FG_PRODUCTS"> | number
    fg?: XOR<FGScalarRelationFilter, FGWhereInput>
  }, "id">

  export type FG_PRODUCTSOrderByWithAggregationInput = {
    id?: SortOrder
    fgId?: SortOrder
    productId?: SortOrder
    quantity?: SortOrder
    _count?: FG_PRODUCTSCountOrderByAggregateInput
    _avg?: FG_PRODUCTSAvgOrderByAggregateInput
    _max?: FG_PRODUCTSMaxOrderByAggregateInput
    _min?: FG_PRODUCTSMinOrderByAggregateInput
    _sum?: FG_PRODUCTSSumOrderByAggregateInput
  }

  export type FG_PRODUCTSScalarWhereWithAggregatesInput = {
    AND?: FG_PRODUCTSScalarWhereWithAggregatesInput | FG_PRODUCTSScalarWhereWithAggregatesInput[]
    OR?: FG_PRODUCTSScalarWhereWithAggregatesInput[]
    NOT?: FG_PRODUCTSScalarWhereWithAggregatesInput | FG_PRODUCTSScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"FG_PRODUCTS"> | number
    fgId?: IntWithAggregatesFilter<"FG_PRODUCTS"> | number
    productId?: IntWithAggregatesFilter<"FG_PRODUCTS"> | number
    quantity?: IntWithAggregatesFilter<"FG_PRODUCTS"> | number
  }

  export type WIP_TRANSACTIONSWhereInput = {
    AND?: WIP_TRANSACTIONSWhereInput | WIP_TRANSACTIONSWhereInput[]
    OR?: WIP_TRANSACTIONSWhereInput[]
    NOT?: WIP_TRANSACTIONSWhereInput | WIP_TRANSACTIONSWhereInput[]
    id?: IntFilter<"WIP_TRANSACTIONS"> | number
    wipId?: IntFilter<"WIP_TRANSACTIONS"> | number
    quantity?: IntFilter<"WIP_TRANSACTIONS"> | number
    transactionType?: EnumTransactionTypeFilter<"WIP_TRANSACTIONS"> | $Enums.TransactionType
    reason?: StringFilter<"WIP_TRANSACTIONS"> | string
    status?: EnumStatusFilter<"WIP_TRANSACTIONS"> | $Enums.Status
    initiatedById?: IntFilter<"WIP_TRANSACTIONS"> | number
    createdAt?: DateTimeFilter<"WIP_TRANSACTIONS"> | Date | string
    updatedAt?: DateTimeFilter<"WIP_TRANSACTIONS"> | Date | string
    wip?: XOR<WIPScalarRelationFilter, WIPWhereInput>
    initiatedBy?: XOR<EmployeeScalarRelationFilter, EmployeeWhereInput>
    wipQC?: WIP_QCListRelationFilter
    wipWasteLogs?: WIP_WASTAGE_LOGSListRelationFilter
  }

  export type WIP_TRANSACTIONSOrderByWithRelationInput = {
    id?: SortOrder
    wipId?: SortOrder
    quantity?: SortOrder
    transactionType?: SortOrder
    reason?: SortOrder
    status?: SortOrder
    initiatedById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    wip?: WIPOrderByWithRelationInput
    initiatedBy?: EmployeeOrderByWithRelationInput
    wipQC?: WIP_QCOrderByRelationAggregateInput
    wipWasteLogs?: WIP_WASTAGE_LOGSOrderByRelationAggregateInput
    _relevance?: WIP_TRANSACTIONSOrderByRelevanceInput
  }

  export type WIP_TRANSACTIONSWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: WIP_TRANSACTIONSWhereInput | WIP_TRANSACTIONSWhereInput[]
    OR?: WIP_TRANSACTIONSWhereInput[]
    NOT?: WIP_TRANSACTIONSWhereInput | WIP_TRANSACTIONSWhereInput[]
    wipId?: IntFilter<"WIP_TRANSACTIONS"> | number
    quantity?: IntFilter<"WIP_TRANSACTIONS"> | number
    transactionType?: EnumTransactionTypeFilter<"WIP_TRANSACTIONS"> | $Enums.TransactionType
    reason?: StringFilter<"WIP_TRANSACTIONS"> | string
    status?: EnumStatusFilter<"WIP_TRANSACTIONS"> | $Enums.Status
    initiatedById?: IntFilter<"WIP_TRANSACTIONS"> | number
    createdAt?: DateTimeFilter<"WIP_TRANSACTIONS"> | Date | string
    updatedAt?: DateTimeFilter<"WIP_TRANSACTIONS"> | Date | string
    wip?: XOR<WIPScalarRelationFilter, WIPWhereInput>
    initiatedBy?: XOR<EmployeeScalarRelationFilter, EmployeeWhereInput>
    wipQC?: WIP_QCListRelationFilter
    wipWasteLogs?: WIP_WASTAGE_LOGSListRelationFilter
  }, "id">

  export type WIP_TRANSACTIONSOrderByWithAggregationInput = {
    id?: SortOrder
    wipId?: SortOrder
    quantity?: SortOrder
    transactionType?: SortOrder
    reason?: SortOrder
    status?: SortOrder
    initiatedById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: WIP_TRANSACTIONSCountOrderByAggregateInput
    _avg?: WIP_TRANSACTIONSAvgOrderByAggregateInput
    _max?: WIP_TRANSACTIONSMaxOrderByAggregateInput
    _min?: WIP_TRANSACTIONSMinOrderByAggregateInput
    _sum?: WIP_TRANSACTIONSSumOrderByAggregateInput
  }

  export type WIP_TRANSACTIONSScalarWhereWithAggregatesInput = {
    AND?: WIP_TRANSACTIONSScalarWhereWithAggregatesInput | WIP_TRANSACTIONSScalarWhereWithAggregatesInput[]
    OR?: WIP_TRANSACTIONSScalarWhereWithAggregatesInput[]
    NOT?: WIP_TRANSACTIONSScalarWhereWithAggregatesInput | WIP_TRANSACTIONSScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"WIP_TRANSACTIONS"> | number
    wipId?: IntWithAggregatesFilter<"WIP_TRANSACTIONS"> | number
    quantity?: IntWithAggregatesFilter<"WIP_TRANSACTIONS"> | number
    transactionType?: EnumTransactionTypeWithAggregatesFilter<"WIP_TRANSACTIONS"> | $Enums.TransactionType
    reason?: StringWithAggregatesFilter<"WIP_TRANSACTIONS"> | string
    status?: EnumStatusWithAggregatesFilter<"WIP_TRANSACTIONS"> | $Enums.Status
    initiatedById?: IntWithAggregatesFilter<"WIP_TRANSACTIONS"> | number
    createdAt?: DateTimeWithAggregatesFilter<"WIP_TRANSACTIONS"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"WIP_TRANSACTIONS"> | Date | string
  }

  export type FG_TRANSACTIONSWhereInput = {
    AND?: FG_TRANSACTIONSWhereInput | FG_TRANSACTIONSWhereInput[]
    OR?: FG_TRANSACTIONSWhereInput[]
    NOT?: FG_TRANSACTIONSWhereInput | FG_TRANSACTIONSWhereInput[]
    id?: IntFilter<"FG_TRANSACTIONS"> | number
    fgId?: IntFilter<"FG_TRANSACTIONS"> | number
    quantity?: IntFilter<"FG_TRANSACTIONS"> | number
    transactionType?: EnumTransactionTypeFilter<"FG_TRANSACTIONS"> | $Enums.TransactionType
    status?: EnumStatusFilter<"FG_TRANSACTIONS"> | $Enums.Status
    reason?: StringFilter<"FG_TRANSACTIONS"> | string
    IntiatedById?: IntFilter<"FG_TRANSACTIONS"> | number
    createdAt?: DateTimeFilter<"FG_TRANSACTIONS"> | Date | string
    updatedAt?: DateTimeFilter<"FG_TRANSACTIONS"> | Date | string
    deletedAt?: DateTimeNullableFilter<"FG_TRANSACTIONS"> | Date | string | null
    fg?: XOR<FGScalarRelationFilter, FGWhereInput>
    initiatedBy?: XOR<EmployeeScalarRelationFilter, EmployeeWhereInput>
    fgQC?: FG_QCListRelationFilter
    fgWasteLogs?: FG_WASTAGE_LOGSListRelationFilter
  }

  export type FG_TRANSACTIONSOrderByWithRelationInput = {
    id?: SortOrder
    fgId?: SortOrder
    quantity?: SortOrder
    transactionType?: SortOrder
    status?: SortOrder
    reason?: SortOrder
    IntiatedById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    fg?: FGOrderByWithRelationInput
    initiatedBy?: EmployeeOrderByWithRelationInput
    fgQC?: FG_QCOrderByRelationAggregateInput
    fgWasteLogs?: FG_WASTAGE_LOGSOrderByRelationAggregateInput
    _relevance?: FG_TRANSACTIONSOrderByRelevanceInput
  }

  export type FG_TRANSACTIONSWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: FG_TRANSACTIONSWhereInput | FG_TRANSACTIONSWhereInput[]
    OR?: FG_TRANSACTIONSWhereInput[]
    NOT?: FG_TRANSACTIONSWhereInput | FG_TRANSACTIONSWhereInput[]
    fgId?: IntFilter<"FG_TRANSACTIONS"> | number
    quantity?: IntFilter<"FG_TRANSACTIONS"> | number
    transactionType?: EnumTransactionTypeFilter<"FG_TRANSACTIONS"> | $Enums.TransactionType
    status?: EnumStatusFilter<"FG_TRANSACTIONS"> | $Enums.Status
    reason?: StringFilter<"FG_TRANSACTIONS"> | string
    IntiatedById?: IntFilter<"FG_TRANSACTIONS"> | number
    createdAt?: DateTimeFilter<"FG_TRANSACTIONS"> | Date | string
    updatedAt?: DateTimeFilter<"FG_TRANSACTIONS"> | Date | string
    deletedAt?: DateTimeNullableFilter<"FG_TRANSACTIONS"> | Date | string | null
    fg?: XOR<FGScalarRelationFilter, FGWhereInput>
    initiatedBy?: XOR<EmployeeScalarRelationFilter, EmployeeWhereInput>
    fgQC?: FG_QCListRelationFilter
    fgWasteLogs?: FG_WASTAGE_LOGSListRelationFilter
  }, "id">

  export type FG_TRANSACTIONSOrderByWithAggregationInput = {
    id?: SortOrder
    fgId?: SortOrder
    quantity?: SortOrder
    transactionType?: SortOrder
    status?: SortOrder
    reason?: SortOrder
    IntiatedById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    _count?: FG_TRANSACTIONSCountOrderByAggregateInput
    _avg?: FG_TRANSACTIONSAvgOrderByAggregateInput
    _max?: FG_TRANSACTIONSMaxOrderByAggregateInput
    _min?: FG_TRANSACTIONSMinOrderByAggregateInput
    _sum?: FG_TRANSACTIONSSumOrderByAggregateInput
  }

  export type FG_TRANSACTIONSScalarWhereWithAggregatesInput = {
    AND?: FG_TRANSACTIONSScalarWhereWithAggregatesInput | FG_TRANSACTIONSScalarWhereWithAggregatesInput[]
    OR?: FG_TRANSACTIONSScalarWhereWithAggregatesInput[]
    NOT?: FG_TRANSACTIONSScalarWhereWithAggregatesInput | FG_TRANSACTIONSScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"FG_TRANSACTIONS"> | number
    fgId?: IntWithAggregatesFilter<"FG_TRANSACTIONS"> | number
    quantity?: IntWithAggregatesFilter<"FG_TRANSACTIONS"> | number
    transactionType?: EnumTransactionTypeWithAggregatesFilter<"FG_TRANSACTIONS"> | $Enums.TransactionType
    status?: EnumStatusWithAggregatesFilter<"FG_TRANSACTIONS"> | $Enums.Status
    reason?: StringWithAggregatesFilter<"FG_TRANSACTIONS"> | string
    IntiatedById?: IntWithAggregatesFilter<"FG_TRANSACTIONS"> | number
    createdAt?: DateTimeWithAggregatesFilter<"FG_TRANSACTIONS"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"FG_TRANSACTIONS"> | Date | string
    deletedAt?: DateTimeNullableWithAggregatesFilter<"FG_TRANSACTIONS"> | Date | string | null
  }

  export type WIP_QCWhereInput = {
    AND?: WIP_QCWhereInput | WIP_QCWhereInput[]
    OR?: WIP_QCWhereInput[]
    NOT?: WIP_QCWhereInput | WIP_QCWhereInput[]
    id?: IntFilter<"WIP_QC"> | number
    transactionId?: IntFilter<"WIP_QC"> | number
    transactionType?: EnumTransactionTypeFilter<"WIP_QC"> | $Enums.TransactionType
    wipId?: IntFilter<"WIP_QC"> | number
    quality_status?: EnumQualityStatusFilter<"WIP_QC"> | $Enums.QualityStatus
    createdAt?: DateTimeFilter<"WIP_QC"> | Date | string
    updatedAt?: DateTimeFilter<"WIP_QC"> | Date | string
    wip?: XOR<WIPScalarRelationFilter, WIPWhereInput>
    WIPTransactions?: XOR<WIP_TRANSACTIONSScalarRelationFilter, WIP_TRANSACTIONSWhereInput>
  }

  export type WIP_QCOrderByWithRelationInput = {
    id?: SortOrder
    transactionId?: SortOrder
    transactionType?: SortOrder
    wipId?: SortOrder
    quality_status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    wip?: WIPOrderByWithRelationInput
    WIPTransactions?: WIP_TRANSACTIONSOrderByWithRelationInput
  }

  export type WIP_QCWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: WIP_QCWhereInput | WIP_QCWhereInput[]
    OR?: WIP_QCWhereInput[]
    NOT?: WIP_QCWhereInput | WIP_QCWhereInput[]
    transactionId?: IntFilter<"WIP_QC"> | number
    transactionType?: EnumTransactionTypeFilter<"WIP_QC"> | $Enums.TransactionType
    wipId?: IntFilter<"WIP_QC"> | number
    quality_status?: EnumQualityStatusFilter<"WIP_QC"> | $Enums.QualityStatus
    createdAt?: DateTimeFilter<"WIP_QC"> | Date | string
    updatedAt?: DateTimeFilter<"WIP_QC"> | Date | string
    wip?: XOR<WIPScalarRelationFilter, WIPWhereInput>
    WIPTransactions?: XOR<WIP_TRANSACTIONSScalarRelationFilter, WIP_TRANSACTIONSWhereInput>
  }, "id">

  export type WIP_QCOrderByWithAggregationInput = {
    id?: SortOrder
    transactionId?: SortOrder
    transactionType?: SortOrder
    wipId?: SortOrder
    quality_status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: WIP_QCCountOrderByAggregateInput
    _avg?: WIP_QCAvgOrderByAggregateInput
    _max?: WIP_QCMaxOrderByAggregateInput
    _min?: WIP_QCMinOrderByAggregateInput
    _sum?: WIP_QCSumOrderByAggregateInput
  }

  export type WIP_QCScalarWhereWithAggregatesInput = {
    AND?: WIP_QCScalarWhereWithAggregatesInput | WIP_QCScalarWhereWithAggregatesInput[]
    OR?: WIP_QCScalarWhereWithAggregatesInput[]
    NOT?: WIP_QCScalarWhereWithAggregatesInput | WIP_QCScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"WIP_QC"> | number
    transactionId?: IntWithAggregatesFilter<"WIP_QC"> | number
    transactionType?: EnumTransactionTypeWithAggregatesFilter<"WIP_QC"> | $Enums.TransactionType
    wipId?: IntWithAggregatesFilter<"WIP_QC"> | number
    quality_status?: EnumQualityStatusWithAggregatesFilter<"WIP_QC"> | $Enums.QualityStatus
    createdAt?: DateTimeWithAggregatesFilter<"WIP_QC"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"WIP_QC"> | Date | string
  }

  export type FG_QCWhereInput = {
    AND?: FG_QCWhereInput | FG_QCWhereInput[]
    OR?: FG_QCWhereInput[]
    NOT?: FG_QCWhereInput | FG_QCWhereInput[]
    id?: IntFilter<"FG_QC"> | number
    transactionId?: IntFilter<"FG_QC"> | number
    transactionType?: EnumTransactionTypeFilter<"FG_QC"> | $Enums.TransactionType
    fgId?: IntFilter<"FG_QC"> | number
    quality_status?: EnumQualityStatusFilter<"FG_QC"> | $Enums.QualityStatus
    createdAt?: DateTimeFilter<"FG_QC"> | Date | string
    updatedAt?: DateTimeFilter<"FG_QC"> | Date | string
    fg?: XOR<FGScalarRelationFilter, FGWhereInput>
    FGTransactions?: XOR<FG_TRANSACTIONSScalarRelationFilter, FG_TRANSACTIONSWhereInput>
  }

  export type FG_QCOrderByWithRelationInput = {
    id?: SortOrder
    transactionId?: SortOrder
    transactionType?: SortOrder
    fgId?: SortOrder
    quality_status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    fg?: FGOrderByWithRelationInput
    FGTransactions?: FG_TRANSACTIONSOrderByWithRelationInput
  }

  export type FG_QCWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: FG_QCWhereInput | FG_QCWhereInput[]
    OR?: FG_QCWhereInput[]
    NOT?: FG_QCWhereInput | FG_QCWhereInput[]
    transactionId?: IntFilter<"FG_QC"> | number
    transactionType?: EnumTransactionTypeFilter<"FG_QC"> | $Enums.TransactionType
    fgId?: IntFilter<"FG_QC"> | number
    quality_status?: EnumQualityStatusFilter<"FG_QC"> | $Enums.QualityStatus
    createdAt?: DateTimeFilter<"FG_QC"> | Date | string
    updatedAt?: DateTimeFilter<"FG_QC"> | Date | string
    fg?: XOR<FGScalarRelationFilter, FGWhereInput>
    FGTransactions?: XOR<FG_TRANSACTIONSScalarRelationFilter, FG_TRANSACTIONSWhereInput>
  }, "id">

  export type FG_QCOrderByWithAggregationInput = {
    id?: SortOrder
    transactionId?: SortOrder
    transactionType?: SortOrder
    fgId?: SortOrder
    quality_status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: FG_QCCountOrderByAggregateInput
    _avg?: FG_QCAvgOrderByAggregateInput
    _max?: FG_QCMaxOrderByAggregateInput
    _min?: FG_QCMinOrderByAggregateInput
    _sum?: FG_QCSumOrderByAggregateInput
  }

  export type FG_QCScalarWhereWithAggregatesInput = {
    AND?: FG_QCScalarWhereWithAggregatesInput | FG_QCScalarWhereWithAggregatesInput[]
    OR?: FG_QCScalarWhereWithAggregatesInput[]
    NOT?: FG_QCScalarWhereWithAggregatesInput | FG_QCScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"FG_QC"> | number
    transactionId?: IntWithAggregatesFilter<"FG_QC"> | number
    transactionType?: EnumTransactionTypeWithAggregatesFilter<"FG_QC"> | $Enums.TransactionType
    fgId?: IntWithAggregatesFilter<"FG_QC"> | number
    quality_status?: EnumQualityStatusWithAggregatesFilter<"FG_QC"> | $Enums.QualityStatus
    createdAt?: DateTimeWithAggregatesFilter<"FG_QC"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"FG_QC"> | Date | string
  }

  export type WIP_WASTAGE_LOGSWhereInput = {
    AND?: WIP_WASTAGE_LOGSWhereInput | WIP_WASTAGE_LOGSWhereInput[]
    OR?: WIP_WASTAGE_LOGSWhereInput[]
    NOT?: WIP_WASTAGE_LOGSWhereInput | WIP_WASTAGE_LOGSWhereInput[]
    id?: IntFilter<"WIP_WASTAGE_LOGS"> | number
    transactionId?: IntFilter<"WIP_WASTAGE_LOGS"> | number
    transactionType?: EnumTransactionTypeFilter<"WIP_WASTAGE_LOGS"> | $Enums.TransactionType
    wipId?: IntFilter<"WIP_WASTAGE_LOGS"> | number
    quantity?: IntFilter<"WIP_WASTAGE_LOGS"> | number
    reason?: StringFilter<"WIP_WASTAGE_LOGS"> | string
    createdAt?: DateTimeFilter<"WIP_WASTAGE_LOGS"> | Date | string
    updatedAt?: DateTimeFilter<"WIP_WASTAGE_LOGS"> | Date | string
    wip?: XOR<WIPScalarRelationFilter, WIPWhereInput>
    WIPTransactions?: XOR<WIP_TRANSACTIONSScalarRelationFilter, WIP_TRANSACTIONSWhereInput>
  }

  export type WIP_WASTAGE_LOGSOrderByWithRelationInput = {
    id?: SortOrder
    transactionId?: SortOrder
    transactionType?: SortOrder
    wipId?: SortOrder
    quantity?: SortOrder
    reason?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    wip?: WIPOrderByWithRelationInput
    WIPTransactions?: WIP_TRANSACTIONSOrderByWithRelationInput
    _relevance?: WIP_WASTAGE_LOGSOrderByRelevanceInput
  }

  export type WIP_WASTAGE_LOGSWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: WIP_WASTAGE_LOGSWhereInput | WIP_WASTAGE_LOGSWhereInput[]
    OR?: WIP_WASTAGE_LOGSWhereInput[]
    NOT?: WIP_WASTAGE_LOGSWhereInput | WIP_WASTAGE_LOGSWhereInput[]
    transactionId?: IntFilter<"WIP_WASTAGE_LOGS"> | number
    transactionType?: EnumTransactionTypeFilter<"WIP_WASTAGE_LOGS"> | $Enums.TransactionType
    wipId?: IntFilter<"WIP_WASTAGE_LOGS"> | number
    quantity?: IntFilter<"WIP_WASTAGE_LOGS"> | number
    reason?: StringFilter<"WIP_WASTAGE_LOGS"> | string
    createdAt?: DateTimeFilter<"WIP_WASTAGE_LOGS"> | Date | string
    updatedAt?: DateTimeFilter<"WIP_WASTAGE_LOGS"> | Date | string
    wip?: XOR<WIPScalarRelationFilter, WIPWhereInput>
    WIPTransactions?: XOR<WIP_TRANSACTIONSScalarRelationFilter, WIP_TRANSACTIONSWhereInput>
  }, "id">

  export type WIP_WASTAGE_LOGSOrderByWithAggregationInput = {
    id?: SortOrder
    transactionId?: SortOrder
    transactionType?: SortOrder
    wipId?: SortOrder
    quantity?: SortOrder
    reason?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: WIP_WASTAGE_LOGSCountOrderByAggregateInput
    _avg?: WIP_WASTAGE_LOGSAvgOrderByAggregateInput
    _max?: WIP_WASTAGE_LOGSMaxOrderByAggregateInput
    _min?: WIP_WASTAGE_LOGSMinOrderByAggregateInput
    _sum?: WIP_WASTAGE_LOGSSumOrderByAggregateInput
  }

  export type WIP_WASTAGE_LOGSScalarWhereWithAggregatesInput = {
    AND?: WIP_WASTAGE_LOGSScalarWhereWithAggregatesInput | WIP_WASTAGE_LOGSScalarWhereWithAggregatesInput[]
    OR?: WIP_WASTAGE_LOGSScalarWhereWithAggregatesInput[]
    NOT?: WIP_WASTAGE_LOGSScalarWhereWithAggregatesInput | WIP_WASTAGE_LOGSScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"WIP_WASTAGE_LOGS"> | number
    transactionId?: IntWithAggregatesFilter<"WIP_WASTAGE_LOGS"> | number
    transactionType?: EnumTransactionTypeWithAggregatesFilter<"WIP_WASTAGE_LOGS"> | $Enums.TransactionType
    wipId?: IntWithAggregatesFilter<"WIP_WASTAGE_LOGS"> | number
    quantity?: IntWithAggregatesFilter<"WIP_WASTAGE_LOGS"> | number
    reason?: StringWithAggregatesFilter<"WIP_WASTAGE_LOGS"> | string
    createdAt?: DateTimeWithAggregatesFilter<"WIP_WASTAGE_LOGS"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"WIP_WASTAGE_LOGS"> | Date | string
  }

  export type FG_WASTAGE_LOGSWhereInput = {
    AND?: FG_WASTAGE_LOGSWhereInput | FG_WASTAGE_LOGSWhereInput[]
    OR?: FG_WASTAGE_LOGSWhereInput[]
    NOT?: FG_WASTAGE_LOGSWhereInput | FG_WASTAGE_LOGSWhereInput[]
    id?: IntFilter<"FG_WASTAGE_LOGS"> | number
    transactionId?: IntFilter<"FG_WASTAGE_LOGS"> | number
    transactionType?: EnumTransactionTypeFilter<"FG_WASTAGE_LOGS"> | $Enums.TransactionType
    fgId?: IntFilter<"FG_WASTAGE_LOGS"> | number
    quantity?: IntFilter<"FG_WASTAGE_LOGS"> | number
    reason?: StringFilter<"FG_WASTAGE_LOGS"> | string
    createdAt?: DateTimeFilter<"FG_WASTAGE_LOGS"> | Date | string
    updatedAt?: DateTimeFilter<"FG_WASTAGE_LOGS"> | Date | string
    fg?: XOR<FGScalarRelationFilter, FGWhereInput>
    FGTransactions?: XOR<FG_TRANSACTIONSScalarRelationFilter, FG_TRANSACTIONSWhereInput>
  }

  export type FG_WASTAGE_LOGSOrderByWithRelationInput = {
    id?: SortOrder
    transactionId?: SortOrder
    transactionType?: SortOrder
    fgId?: SortOrder
    quantity?: SortOrder
    reason?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    fg?: FGOrderByWithRelationInput
    FGTransactions?: FG_TRANSACTIONSOrderByWithRelationInput
    _relevance?: FG_WASTAGE_LOGSOrderByRelevanceInput
  }

  export type FG_WASTAGE_LOGSWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: FG_WASTAGE_LOGSWhereInput | FG_WASTAGE_LOGSWhereInput[]
    OR?: FG_WASTAGE_LOGSWhereInput[]
    NOT?: FG_WASTAGE_LOGSWhereInput | FG_WASTAGE_LOGSWhereInput[]
    transactionId?: IntFilter<"FG_WASTAGE_LOGS"> | number
    transactionType?: EnumTransactionTypeFilter<"FG_WASTAGE_LOGS"> | $Enums.TransactionType
    fgId?: IntFilter<"FG_WASTAGE_LOGS"> | number
    quantity?: IntFilter<"FG_WASTAGE_LOGS"> | number
    reason?: StringFilter<"FG_WASTAGE_LOGS"> | string
    createdAt?: DateTimeFilter<"FG_WASTAGE_LOGS"> | Date | string
    updatedAt?: DateTimeFilter<"FG_WASTAGE_LOGS"> | Date | string
    fg?: XOR<FGScalarRelationFilter, FGWhereInput>
    FGTransactions?: XOR<FG_TRANSACTIONSScalarRelationFilter, FG_TRANSACTIONSWhereInput>
  }, "id">

  export type FG_WASTAGE_LOGSOrderByWithAggregationInput = {
    id?: SortOrder
    transactionId?: SortOrder
    transactionType?: SortOrder
    fgId?: SortOrder
    quantity?: SortOrder
    reason?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: FG_WASTAGE_LOGSCountOrderByAggregateInput
    _avg?: FG_WASTAGE_LOGSAvgOrderByAggregateInput
    _max?: FG_WASTAGE_LOGSMaxOrderByAggregateInput
    _min?: FG_WASTAGE_LOGSMinOrderByAggregateInput
    _sum?: FG_WASTAGE_LOGSSumOrderByAggregateInput
  }

  export type FG_WASTAGE_LOGSScalarWhereWithAggregatesInput = {
    AND?: FG_WASTAGE_LOGSScalarWhereWithAggregatesInput | FG_WASTAGE_LOGSScalarWhereWithAggregatesInput[]
    OR?: FG_WASTAGE_LOGSScalarWhereWithAggregatesInput[]
    NOT?: FG_WASTAGE_LOGSScalarWhereWithAggregatesInput | FG_WASTAGE_LOGSScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"FG_WASTAGE_LOGS"> | number
    transactionId?: IntWithAggregatesFilter<"FG_WASTAGE_LOGS"> | number
    transactionType?: EnumTransactionTypeWithAggregatesFilter<"FG_WASTAGE_LOGS"> | $Enums.TransactionType
    fgId?: IntWithAggregatesFilter<"FG_WASTAGE_LOGS"> | number
    quantity?: IntWithAggregatesFilter<"FG_WASTAGE_LOGS"> | number
    reason?: StringWithAggregatesFilter<"FG_WASTAGE_LOGS"> | string
    createdAt?: DateTimeWithAggregatesFilter<"FG_WASTAGE_LOGS"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"FG_WASTAGE_LOGS"> | Date | string
  }

  export type AuditLogsWhereInput = {
    AND?: AuditLogsWhereInput | AuditLogsWhereInput[]
    OR?: AuditLogsWhereInput[]
    NOT?: AuditLogsWhereInput | AuditLogsWhereInput[]
    id?: IntFilter<"AuditLogs"> | number
    tableName?: StringFilter<"AuditLogs"> | string
    action?: EnumActionsFilter<"AuditLogs"> | $Enums.Actions
    oldValue?: JsonNullableFilter<"AuditLogs">
    newValue?: JsonNullableFilter<"AuditLogs">
    changedById?: IntFilter<"AuditLogs"> | number
    createdAt?: DateTimeFilter<"AuditLogs"> | Date | string
    changedBy?: XOR<EmployeeScalarRelationFilter, EmployeeWhereInput>
  }

  export type AuditLogsOrderByWithRelationInput = {
    id?: SortOrder
    tableName?: SortOrder
    action?: SortOrder
    oldValue?: SortOrderInput | SortOrder
    newValue?: SortOrderInput | SortOrder
    changedById?: SortOrder
    createdAt?: SortOrder
    changedBy?: EmployeeOrderByWithRelationInput
    _relevance?: AuditLogsOrderByRelevanceInput
  }

  export type AuditLogsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: AuditLogsWhereInput | AuditLogsWhereInput[]
    OR?: AuditLogsWhereInput[]
    NOT?: AuditLogsWhereInput | AuditLogsWhereInput[]
    tableName?: StringFilter<"AuditLogs"> | string
    action?: EnumActionsFilter<"AuditLogs"> | $Enums.Actions
    oldValue?: JsonNullableFilter<"AuditLogs">
    newValue?: JsonNullableFilter<"AuditLogs">
    changedById?: IntFilter<"AuditLogs"> | number
    createdAt?: DateTimeFilter<"AuditLogs"> | Date | string
    changedBy?: XOR<EmployeeScalarRelationFilter, EmployeeWhereInput>
  }, "id">

  export type AuditLogsOrderByWithAggregationInput = {
    id?: SortOrder
    tableName?: SortOrder
    action?: SortOrder
    oldValue?: SortOrderInput | SortOrder
    newValue?: SortOrderInput | SortOrder
    changedById?: SortOrder
    createdAt?: SortOrder
    _count?: AuditLogsCountOrderByAggregateInput
    _avg?: AuditLogsAvgOrderByAggregateInput
    _max?: AuditLogsMaxOrderByAggregateInput
    _min?: AuditLogsMinOrderByAggregateInput
    _sum?: AuditLogsSumOrderByAggregateInput
  }

  export type AuditLogsScalarWhereWithAggregatesInput = {
    AND?: AuditLogsScalarWhereWithAggregatesInput | AuditLogsScalarWhereWithAggregatesInput[]
    OR?: AuditLogsScalarWhereWithAggregatesInput[]
    NOT?: AuditLogsScalarWhereWithAggregatesInput | AuditLogsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"AuditLogs"> | number
    tableName?: StringWithAggregatesFilter<"AuditLogs"> | string
    action?: EnumActionsWithAggregatesFilter<"AuditLogs"> | $Enums.Actions
    oldValue?: JsonNullableWithAggregatesFilter<"AuditLogs">
    newValue?: JsonNullableWithAggregatesFilter<"AuditLogs">
    changedById?: IntWithAggregatesFilter<"AuditLogs"> | number
    createdAt?: DateTimeWithAggregatesFilter<"AuditLogs"> | Date | string
  }

  export type RAW_MATERIALSCreateInput = {
    id: bigint | number
    name: string
    SKU: string
    quantity: number
    price: Decimal | DecimalJsLike | number | string
    image?: string | null
    description?: string | null
    expiry_date: Date | string
    quality_status: $Enums.QualityStatus
    storage_location: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    VariantMaterials?: VARIANT_RAW_MATERIALS_TRACKERCreateNestedManyWithoutRawMaterialInput
    RMTransactions?: RM_TRANSACTIONSCreateNestedManyWithoutRawMaterialInput
    RMQualityChecks?: RM_QCCreateNestedManyWithoutRawMaterialInput
    RMWastageLogs?: RM_WASTAGE_LOGSCreateNestedManyWithoutRawMaterialInput
    WIPMaterials?: WIPRawMaterialCreateNestedManyWithoutRawMaterialInput
  }

  export type RAW_MATERIALSUncheckedCreateInput = {
    id: bigint | number
    name: string
    SKU: string
    quantity: number
    price: Decimal | DecimalJsLike | number | string
    image?: string | null
    description?: string | null
    expiry_date: Date | string
    quality_status: $Enums.QualityStatus
    storage_location: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    VariantMaterials?: VARIANT_RAW_MATERIALS_TRACKERUncheckedCreateNestedManyWithoutRawMaterialInput
    RMTransactions?: RM_TRANSACTIONSUncheckedCreateNestedManyWithoutRawMaterialInput
    RMQualityChecks?: RM_QCUncheckedCreateNestedManyWithoutRawMaterialInput
    RMWastageLogs?: RM_WASTAGE_LOGSUncheckedCreateNestedManyWithoutRawMaterialInput
    WIPMaterials?: WIPRawMaterialUncheckedCreateNestedManyWithoutRawMaterialInput
  }

  export type RAW_MATERIALSUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    SKU?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    expiry_date?: DateTimeFieldUpdateOperationsInput | Date | string
    quality_status?: EnumQualityStatusFieldUpdateOperationsInput | $Enums.QualityStatus
    storage_location?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    VariantMaterials?: VARIANT_RAW_MATERIALS_TRACKERUpdateManyWithoutRawMaterialNestedInput
    RMTransactions?: RM_TRANSACTIONSUpdateManyWithoutRawMaterialNestedInput
    RMQualityChecks?: RM_QCUpdateManyWithoutRawMaterialNestedInput
    RMWastageLogs?: RM_WASTAGE_LOGSUpdateManyWithoutRawMaterialNestedInput
    WIPMaterials?: WIPRawMaterialUpdateManyWithoutRawMaterialNestedInput
  }

  export type RAW_MATERIALSUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    SKU?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    expiry_date?: DateTimeFieldUpdateOperationsInput | Date | string
    quality_status?: EnumQualityStatusFieldUpdateOperationsInput | $Enums.QualityStatus
    storage_location?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    VariantMaterials?: VARIANT_RAW_MATERIALS_TRACKERUncheckedUpdateManyWithoutRawMaterialNestedInput
    RMTransactions?: RM_TRANSACTIONSUncheckedUpdateManyWithoutRawMaterialNestedInput
    RMQualityChecks?: RM_QCUncheckedUpdateManyWithoutRawMaterialNestedInput
    RMWastageLogs?: RM_WASTAGE_LOGSUncheckedUpdateManyWithoutRawMaterialNestedInput
    WIPMaterials?: WIPRawMaterialUncheckedUpdateManyWithoutRawMaterialNestedInput
  }

  export type RAW_MATERIALSCreateManyInput = {
    id: bigint | number
    name: string
    SKU: string
    quantity: number
    price: Decimal | DecimalJsLike | number | string
    image?: string | null
    description?: string | null
    expiry_date: Date | string
    quality_status: $Enums.QualityStatus
    storage_location: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type RAW_MATERIALSUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    SKU?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    expiry_date?: DateTimeFieldUpdateOperationsInput | Date | string
    quality_status?: EnumQualityStatusFieldUpdateOperationsInput | $Enums.QualityStatus
    storage_location?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type RAW_MATERIALSUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    SKU?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    expiry_date?: DateTimeFieldUpdateOperationsInput | Date | string
    quality_status?: EnumQualityStatusFieldUpdateOperationsInput | $Enums.QualityStatus
    storage_location?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SHOPIFY_VARIANTSCreateInput = {
    id: bigint | number
    name: string
    AvailableQty: number
    img?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    variantName?: string | null
    variantOption?: string | null
    product: SHOPIFY_PRODUCTSCreateNestedOneWithoutShopifyVariantsInput
    VariantMaterials?: VARIANT_RAW_MATERIALS_TRACKERCreateNestedManyWithoutVariantInput
  }

  export type SHOPIFY_VARIANTSUncheckedCreateInput = {
    id: bigint | number
    productId: bigint | number
    name: string
    AvailableQty: number
    img?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    variantName?: string | null
    variantOption?: string | null
    VariantMaterials?: VARIANT_RAW_MATERIALS_TRACKERUncheckedCreateNestedManyWithoutVariantInput
  }

  export type SHOPIFY_VARIANTSUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    AvailableQty?: IntFieldUpdateOperationsInput | number
    img?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    variantName?: NullableStringFieldUpdateOperationsInput | string | null
    variantOption?: NullableStringFieldUpdateOperationsInput | string | null
    product?: SHOPIFY_PRODUCTSUpdateOneRequiredWithoutShopifyVariantsNestedInput
    VariantMaterials?: VARIANT_RAW_MATERIALS_TRACKERUpdateManyWithoutVariantNestedInput
  }

  export type SHOPIFY_VARIANTSUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    productId?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    AvailableQty?: IntFieldUpdateOperationsInput | number
    img?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    variantName?: NullableStringFieldUpdateOperationsInput | string | null
    variantOption?: NullableStringFieldUpdateOperationsInput | string | null
    VariantMaterials?: VARIANT_RAW_MATERIALS_TRACKERUncheckedUpdateManyWithoutVariantNestedInput
  }

  export type SHOPIFY_VARIANTSCreateManyInput = {
    id: bigint | number
    productId: bigint | number
    name: string
    AvailableQty: number
    img?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    variantName?: string | null
    variantOption?: string | null
  }

  export type SHOPIFY_VARIANTSUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    AvailableQty?: IntFieldUpdateOperationsInput | number
    img?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    variantName?: NullableStringFieldUpdateOperationsInput | string | null
    variantOption?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SHOPIFY_VARIANTSUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    productId?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    AvailableQty?: IntFieldUpdateOperationsInput | number
    img?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    variantName?: NullableStringFieldUpdateOperationsInput | string | null
    variantOption?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type VARIANT_RAW_MATERIALS_TRACKERCreateInput = {
    avgQuantity: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    variant: SHOPIFY_VARIANTSCreateNestedOneWithoutVariantMaterialsInput
    rawMaterial: RAW_MATERIALSCreateNestedOneWithoutVariantMaterialsInput
  }

  export type VARIANT_RAW_MATERIALS_TRACKERUncheckedCreateInput = {
    variantId: bigint | number
    rawMaterialId: bigint | number
    avgQuantity: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type VARIANT_RAW_MATERIALS_TRACKERUpdateInput = {
    avgQuantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    variant?: SHOPIFY_VARIANTSUpdateOneRequiredWithoutVariantMaterialsNestedInput
    rawMaterial?: RAW_MATERIALSUpdateOneRequiredWithoutVariantMaterialsNestedInput
  }

  export type VARIANT_RAW_MATERIALS_TRACKERUncheckedUpdateInput = {
    variantId?: BigIntFieldUpdateOperationsInput | bigint | number
    rawMaterialId?: BigIntFieldUpdateOperationsInput | bigint | number
    avgQuantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type VARIANT_RAW_MATERIALS_TRACKERCreateManyInput = {
    variantId: bigint | number
    rawMaterialId: bigint | number
    avgQuantity: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type VARIANT_RAW_MATERIALS_TRACKERUpdateManyMutationInput = {
    avgQuantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type VARIANT_RAW_MATERIALS_TRACKERUncheckedUpdateManyInput = {
    variantId?: BigIntFieldUpdateOperationsInput | bigint | number
    rawMaterialId?: BigIntFieldUpdateOperationsInput | bigint | number
    avgQuantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CATEGORIESCreateInput = {
    id: number
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    ShopifyProducts?: SHOPIFY_PRODUCTSCreateNestedManyWithoutCategoryInput
  }

  export type CATEGORIESUncheckedCreateInput = {
    id: number
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    ShopifyProducts?: SHOPIFY_PRODUCTSUncheckedCreateNestedManyWithoutCategoryInput
  }

  export type CATEGORIESUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ShopifyProducts?: SHOPIFY_PRODUCTSUpdateManyWithoutCategoryNestedInput
  }

  export type CATEGORIESUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ShopifyProducts?: SHOPIFY_PRODUCTSUncheckedUpdateManyWithoutCategoryNestedInput
  }

  export type CATEGORIESCreateManyInput = {
    id: number
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CATEGORIESUpdateManyMutationInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CATEGORIESUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SHOPIFY_PRODUCTSCreateInput = {
    id: bigint | number
    name: string
    price: Decimal | DecimalJsLike | number | string
    status?: string | null
    img?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    category: CATEGORIESCreateNestedOneWithoutShopifyProductsInput
    ShopifyVariants?: SHOPIFY_VARIANTSCreateNestedManyWithoutProductInput
    WIPProducts?: WIP_PRODUCTSCreateNestedManyWithoutProductInput
  }

  export type SHOPIFY_PRODUCTSUncheckedCreateInput = {
    id: bigint | number
    name: string
    categoryId: number
    price: Decimal | DecimalJsLike | number | string
    status?: string | null
    img?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    ShopifyVariants?: SHOPIFY_VARIANTSUncheckedCreateNestedManyWithoutProductInput
    WIPProducts?: WIP_PRODUCTSUncheckedCreateNestedManyWithoutProductInput
  }

  export type SHOPIFY_PRODUCTSUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
    img?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: CATEGORIESUpdateOneRequiredWithoutShopifyProductsNestedInput
    ShopifyVariants?: SHOPIFY_VARIANTSUpdateManyWithoutProductNestedInput
    WIPProducts?: WIP_PRODUCTSUpdateManyWithoutProductNestedInput
  }

  export type SHOPIFY_PRODUCTSUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    categoryId?: IntFieldUpdateOperationsInput | number
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
    img?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ShopifyVariants?: SHOPIFY_VARIANTSUncheckedUpdateManyWithoutProductNestedInput
    WIPProducts?: WIP_PRODUCTSUncheckedUpdateManyWithoutProductNestedInput
  }

  export type SHOPIFY_PRODUCTSCreateManyInput = {
    id: bigint | number
    name: string
    categoryId: number
    price: Decimal | DecimalJsLike | number | string
    status?: string | null
    img?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SHOPIFY_PRODUCTSUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
    img?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SHOPIFY_PRODUCTSUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    categoryId?: IntFieldUpdateOperationsInput | number
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
    img?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RM_TRANSACTIONSCreateInput = {
    quantity: number
    transactionType: $Enums.TransactionType
    reason: string
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    rawMaterial: RAW_MATERIALSCreateNestedOneWithoutRMTransactionsInput
    initiatedBy: EmployeeCreateNestedOneWithoutRMTransactionsInput
    RMQualityChecks?: RM_QCCreateNestedManyWithoutTransactionInput
    RMWastageLogs?: RM_WASTAGE_LOGSCreateNestedManyWithoutTransactionInput
  }

  export type RM_TRANSACTIONSUncheckedCreateInput = {
    id?: number
    rawMaterialId: bigint | number
    quantity: number
    transactionType: $Enums.TransactionType
    reason: string
    status: string
    initiatedById: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    RMQualityChecks?: RM_QCUncheckedCreateNestedManyWithoutTransactionInput
    RMWastageLogs?: RM_WASTAGE_LOGSUncheckedCreateNestedManyWithoutTransactionInput
  }

  export type RM_TRANSACTIONSUpdateInput = {
    quantity?: IntFieldUpdateOperationsInput | number
    transactionType?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    reason?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rawMaterial?: RAW_MATERIALSUpdateOneRequiredWithoutRMTransactionsNestedInput
    initiatedBy?: EmployeeUpdateOneRequiredWithoutRMTransactionsNestedInput
    RMQualityChecks?: RM_QCUpdateManyWithoutTransactionNestedInput
    RMWastageLogs?: RM_WASTAGE_LOGSUpdateManyWithoutTransactionNestedInput
  }

  export type RM_TRANSACTIONSUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    rawMaterialId?: BigIntFieldUpdateOperationsInput | bigint | number
    quantity?: IntFieldUpdateOperationsInput | number
    transactionType?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    reason?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    initiatedById?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    RMQualityChecks?: RM_QCUncheckedUpdateManyWithoutTransactionNestedInput
    RMWastageLogs?: RM_WASTAGE_LOGSUncheckedUpdateManyWithoutTransactionNestedInput
  }

  export type RM_TRANSACTIONSCreateManyInput = {
    id?: number
    rawMaterialId: bigint | number
    quantity: number
    transactionType: $Enums.TransactionType
    reason: string
    status: string
    initiatedById: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type RM_TRANSACTIONSUpdateManyMutationInput = {
    quantity?: IntFieldUpdateOperationsInput | number
    transactionType?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    reason?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type RM_TRANSACTIONSUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    rawMaterialId?: BigIntFieldUpdateOperationsInput | bigint | number
    quantity?: IntFieldUpdateOperationsInput | number
    transactionType?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    reason?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    initiatedById?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type RM_QCCreateInput = {
    quality_status: $Enums.QualityStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    rawMaterial: RAW_MATERIALSCreateNestedOneWithoutRMQualityChecksInput
    transaction: RM_TRANSACTIONSCreateNestedOneWithoutRMQualityChecksInput
    checkedBy: EmployeeCreateNestedOneWithoutRM_QCInput
    doneBy: EmployeeCreateNestedOneWithoutRM_QC2Input
  }

  export type RM_QCUncheckedCreateInput = {
    id?: number
    transactionId: number
    rawMaterialId: bigint | number
    quality_status: $Enums.QualityStatus
    checkedById: number
    doneById: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type RM_QCUpdateInput = {
    quality_status?: EnumQualityStatusFieldUpdateOperationsInput | $Enums.QualityStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rawMaterial?: RAW_MATERIALSUpdateOneRequiredWithoutRMQualityChecksNestedInput
    transaction?: RM_TRANSACTIONSUpdateOneRequiredWithoutRMQualityChecksNestedInput
    checkedBy?: EmployeeUpdateOneRequiredWithoutRM_QCNestedInput
    doneBy?: EmployeeUpdateOneRequiredWithoutRM_QC2NestedInput
  }

  export type RM_QCUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    transactionId?: IntFieldUpdateOperationsInput | number
    rawMaterialId?: BigIntFieldUpdateOperationsInput | bigint | number
    quality_status?: EnumQualityStatusFieldUpdateOperationsInput | $Enums.QualityStatus
    checkedById?: IntFieldUpdateOperationsInput | number
    doneById?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type RM_QCCreateManyInput = {
    id?: number
    transactionId: number
    rawMaterialId: bigint | number
    quality_status: $Enums.QualityStatus
    checkedById: number
    doneById: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type RM_QCUpdateManyMutationInput = {
    quality_status?: EnumQualityStatusFieldUpdateOperationsInput | $Enums.QualityStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type RM_QCUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    transactionId?: IntFieldUpdateOperationsInput | number
    rawMaterialId?: BigIntFieldUpdateOperationsInput | bigint | number
    quality_status?: EnumQualityStatusFieldUpdateOperationsInput | $Enums.QualityStatus
    checkedById?: IntFieldUpdateOperationsInput | number
    doneById?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type RM_WASTAGE_LOGSCreateInput = {
    quantity: number
    reason: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    rawMaterial: RAW_MATERIALSCreateNestedOneWithoutRMWastageLogsInput
    transaction: RM_TRANSACTIONSCreateNestedOneWithoutRMWastageLogsInput
  }

  export type RM_WASTAGE_LOGSUncheckedCreateInput = {
    id?: number
    transactionId: number
    rawMaterialId: bigint | number
    quantity: number
    reason: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type RM_WASTAGE_LOGSUpdateInput = {
    quantity?: IntFieldUpdateOperationsInput | number
    reason?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rawMaterial?: RAW_MATERIALSUpdateOneRequiredWithoutRMWastageLogsNestedInput
    transaction?: RM_TRANSACTIONSUpdateOneRequiredWithoutRMWastageLogsNestedInput
  }

  export type RM_WASTAGE_LOGSUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    transactionId?: IntFieldUpdateOperationsInput | number
    rawMaterialId?: BigIntFieldUpdateOperationsInput | bigint | number
    quantity?: IntFieldUpdateOperationsInput | number
    reason?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type RM_WASTAGE_LOGSCreateManyInput = {
    id?: number
    transactionId: number
    rawMaterialId: bigint | number
    quantity: number
    reason: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type RM_WASTAGE_LOGSUpdateManyMutationInput = {
    quantity?: IntFieldUpdateOperationsInput | number
    reason?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type RM_WASTAGE_LOGSUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    transactionId?: IntFieldUpdateOperationsInput | number
    rawMaterialId?: BigIntFieldUpdateOperationsInput | bigint | number
    quantity?: IntFieldUpdateOperationsInput | number
    reason?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type EmployeeCreateInput = {
    name: string
    role: $Enums.Roles
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    RM_QC?: RM_QCCreateNestedManyWithoutCheckedByInput
    RM_QC2?: RM_QCCreateNestedManyWithoutDoneByInput
    RMTransactions?: RM_TRANSACTIONSCreateNestedManyWithoutInitiatedByInput
    WIPTransactions?: WIP_TRANSACTIONSCreateNestedManyWithoutInitiatedByInput
    FGTransactions?: FG_TRANSACTIONSCreateNestedManyWithoutInitiatedByInput
    AuditLogs?: AuditLogsCreateNestedManyWithoutChangedByInput
  }

  export type EmployeeUncheckedCreateInput = {
    id?: number
    name: string
    role: $Enums.Roles
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    RM_QC?: RM_QCUncheckedCreateNestedManyWithoutCheckedByInput
    RM_QC2?: RM_QCUncheckedCreateNestedManyWithoutDoneByInput
    RMTransactions?: RM_TRANSACTIONSUncheckedCreateNestedManyWithoutInitiatedByInput
    WIPTransactions?: WIP_TRANSACTIONSUncheckedCreateNestedManyWithoutInitiatedByInput
    FGTransactions?: FG_TRANSACTIONSUncheckedCreateNestedManyWithoutInitiatedByInput
    AuditLogs?: AuditLogsUncheckedCreateNestedManyWithoutChangedByInput
  }

  export type EmployeeUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumRolesFieldUpdateOperationsInput | $Enums.Roles
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    RM_QC?: RM_QCUpdateManyWithoutCheckedByNestedInput
    RM_QC2?: RM_QCUpdateManyWithoutDoneByNestedInput
    RMTransactions?: RM_TRANSACTIONSUpdateManyWithoutInitiatedByNestedInput
    WIPTransactions?: WIP_TRANSACTIONSUpdateManyWithoutInitiatedByNestedInput
    FGTransactions?: FG_TRANSACTIONSUpdateManyWithoutInitiatedByNestedInput
    AuditLogs?: AuditLogsUpdateManyWithoutChangedByNestedInput
  }

  export type EmployeeUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumRolesFieldUpdateOperationsInput | $Enums.Roles
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    RM_QC?: RM_QCUncheckedUpdateManyWithoutCheckedByNestedInput
    RM_QC2?: RM_QCUncheckedUpdateManyWithoutDoneByNestedInput
    RMTransactions?: RM_TRANSACTIONSUncheckedUpdateManyWithoutInitiatedByNestedInput
    WIPTransactions?: WIP_TRANSACTIONSUncheckedUpdateManyWithoutInitiatedByNestedInput
    FGTransactions?: FG_TRANSACTIONSUncheckedUpdateManyWithoutInitiatedByNestedInput
    AuditLogs?: AuditLogsUncheckedUpdateManyWithoutChangedByNestedInput
  }

  export type EmployeeCreateManyInput = {
    id?: number
    name: string
    role: $Enums.Roles
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type EmployeeUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumRolesFieldUpdateOperationsInput | $Enums.Roles
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type EmployeeUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumRolesFieldUpdateOperationsInput | $Enums.Roles
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type WIPCreateInput = {
    orderId: number
    status: $Enums.Status
    createdAt?: Date | string
    updatedAt?: Date | string
    WIPTransactions?: WIP_TRANSACTIONSCreateNestedManyWithoutWipInput
    WIPQCs?: WIP_QCCreateNestedManyWithoutWipInput
    WIPWastageLogs?: WIP_WASTAGE_LOGSCreateNestedManyWithoutWipInput
    wipProducts?: WIP_PRODUCTSCreateNestedManyWithoutWipInput
    WIPMaterials?: WIPRawMaterialCreateNestedManyWithoutWipInput
  }

  export type WIPUncheckedCreateInput = {
    id?: number
    orderId: number
    status: $Enums.Status
    createdAt?: Date | string
    updatedAt?: Date | string
    WIPTransactions?: WIP_TRANSACTIONSUncheckedCreateNestedManyWithoutWipInput
    WIPQCs?: WIP_QCUncheckedCreateNestedManyWithoutWipInput
    WIPWastageLogs?: WIP_WASTAGE_LOGSUncheckedCreateNestedManyWithoutWipInput
    wipProducts?: WIP_PRODUCTSUncheckedCreateNestedManyWithoutWipInput
    WIPMaterials?: WIPRawMaterialUncheckedCreateNestedManyWithoutWipInput
  }

  export type WIPUpdateInput = {
    orderId?: IntFieldUpdateOperationsInput | number
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    WIPTransactions?: WIP_TRANSACTIONSUpdateManyWithoutWipNestedInput
    WIPQCs?: WIP_QCUpdateManyWithoutWipNestedInput
    WIPWastageLogs?: WIP_WASTAGE_LOGSUpdateManyWithoutWipNestedInput
    wipProducts?: WIP_PRODUCTSUpdateManyWithoutWipNestedInput
    WIPMaterials?: WIPRawMaterialUpdateManyWithoutWipNestedInput
  }

  export type WIPUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    orderId?: IntFieldUpdateOperationsInput | number
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    WIPTransactions?: WIP_TRANSACTIONSUncheckedUpdateManyWithoutWipNestedInput
    WIPQCs?: WIP_QCUncheckedUpdateManyWithoutWipNestedInput
    WIPWastageLogs?: WIP_WASTAGE_LOGSUncheckedUpdateManyWithoutWipNestedInput
    wipProducts?: WIP_PRODUCTSUncheckedUpdateManyWithoutWipNestedInput
    WIPMaterials?: WIPRawMaterialUncheckedUpdateManyWithoutWipNestedInput
  }

  export type WIPCreateManyInput = {
    id?: number
    orderId: number
    status: $Enums.Status
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WIPUpdateManyMutationInput = {
    orderId?: IntFieldUpdateOperationsInput | number
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WIPUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    orderId?: IntFieldUpdateOperationsInput | number
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WIP_PRODUCTSCreateInput = {
    quantity: number
    wip: WIPCreateNestedOneWithoutWipProductsInput
    product: SHOPIFY_PRODUCTSCreateNestedOneWithoutWIPProductsInput
  }

  export type WIP_PRODUCTSUncheckedCreateInput = {
    id?: number
    wipId: number
    productId: bigint | number
    quantity: number
  }

  export type WIP_PRODUCTSUpdateInput = {
    quantity?: IntFieldUpdateOperationsInput | number
    wip?: WIPUpdateOneRequiredWithoutWipProductsNestedInput
    product?: SHOPIFY_PRODUCTSUpdateOneRequiredWithoutWIPProductsNestedInput
  }

  export type WIP_PRODUCTSUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    wipId?: IntFieldUpdateOperationsInput | number
    productId?: BigIntFieldUpdateOperationsInput | bigint | number
    quantity?: IntFieldUpdateOperationsInput | number
  }

  export type WIP_PRODUCTSCreateManyInput = {
    id?: number
    wipId: number
    productId: bigint | number
    quantity: number
  }

  export type WIP_PRODUCTSUpdateManyMutationInput = {
    quantity?: IntFieldUpdateOperationsInput | number
  }

  export type WIP_PRODUCTSUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    wipId?: IntFieldUpdateOperationsInput | number
    productId?: BigIntFieldUpdateOperationsInput | bigint | number
    quantity?: IntFieldUpdateOperationsInput | number
  }

  export type WIPRawMaterialCreateInput = {
    quantity: number
    wip: WIPCreateNestedOneWithoutWIPMaterialsInput
    rawMaterial: RAW_MATERIALSCreateNestedOneWithoutWIPMaterialsInput
  }

  export type WIPRawMaterialUncheckedCreateInput = {
    id?: number
    wipId: number
    rawMaterialId: bigint | number
    quantity: number
  }

  export type WIPRawMaterialUpdateInput = {
    quantity?: IntFieldUpdateOperationsInput | number
    wip?: WIPUpdateOneRequiredWithoutWIPMaterialsNestedInput
    rawMaterial?: RAW_MATERIALSUpdateOneRequiredWithoutWIPMaterialsNestedInput
  }

  export type WIPRawMaterialUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    wipId?: IntFieldUpdateOperationsInput | number
    rawMaterialId?: BigIntFieldUpdateOperationsInput | bigint | number
    quantity?: IntFieldUpdateOperationsInput | number
  }

  export type WIPRawMaterialCreateManyInput = {
    id?: number
    wipId: number
    rawMaterialId: bigint | number
    quantity: number
  }

  export type WIPRawMaterialUpdateManyMutationInput = {
    quantity?: IntFieldUpdateOperationsInput | number
  }

  export type WIPRawMaterialUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    wipId?: IntFieldUpdateOperationsInput | number
    rawMaterialId?: BigIntFieldUpdateOperationsInput | bigint | number
    quantity?: IntFieldUpdateOperationsInput | number
  }

  export type FGCreateInput = {
    orderId: number
    customerName: string
    price: Decimal | DecimalJsLike | number | string
    status: $Enums.Status
    createdAt?: Date | string
    deliveryDate: Date | string
    FGTransactions?: FG_TRANSACTIONSCreateNestedManyWithoutFgInput
    FGQCs?: FG_QCCreateNestedManyWithoutFgInput
    FGWastageLogs?: FG_WASTAGE_LOGSCreateNestedManyWithoutFgInput
    fgProducts?: FG_PRODUCTSCreateNestedManyWithoutFgInput
  }

  export type FGUncheckedCreateInput = {
    id?: number
    orderId: number
    customerName: string
    price: Decimal | DecimalJsLike | number | string
    status: $Enums.Status
    createdAt?: Date | string
    deliveryDate: Date | string
    FGTransactions?: FG_TRANSACTIONSUncheckedCreateNestedManyWithoutFgInput
    FGQCs?: FG_QCUncheckedCreateNestedManyWithoutFgInput
    FGWastageLogs?: FG_WASTAGE_LOGSUncheckedCreateNestedManyWithoutFgInput
    fgProducts?: FG_PRODUCTSUncheckedCreateNestedManyWithoutFgInput
  }

  export type FGUpdateInput = {
    orderId?: IntFieldUpdateOperationsInput | number
    customerName?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deliveryDate?: DateTimeFieldUpdateOperationsInput | Date | string
    FGTransactions?: FG_TRANSACTIONSUpdateManyWithoutFgNestedInput
    FGQCs?: FG_QCUpdateManyWithoutFgNestedInput
    FGWastageLogs?: FG_WASTAGE_LOGSUpdateManyWithoutFgNestedInput
    fgProducts?: FG_PRODUCTSUpdateManyWithoutFgNestedInput
  }

  export type FGUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    orderId?: IntFieldUpdateOperationsInput | number
    customerName?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deliveryDate?: DateTimeFieldUpdateOperationsInput | Date | string
    FGTransactions?: FG_TRANSACTIONSUncheckedUpdateManyWithoutFgNestedInput
    FGQCs?: FG_QCUncheckedUpdateManyWithoutFgNestedInput
    FGWastageLogs?: FG_WASTAGE_LOGSUncheckedUpdateManyWithoutFgNestedInput
    fgProducts?: FG_PRODUCTSUncheckedUpdateManyWithoutFgNestedInput
  }

  export type FGCreateManyInput = {
    id?: number
    orderId: number
    customerName: string
    price: Decimal | DecimalJsLike | number | string
    status: $Enums.Status
    createdAt?: Date | string
    deliveryDate: Date | string
  }

  export type FGUpdateManyMutationInput = {
    orderId?: IntFieldUpdateOperationsInput | number
    customerName?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deliveryDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FGUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    orderId?: IntFieldUpdateOperationsInput | number
    customerName?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deliveryDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FG_PRODUCTSCreateInput = {
    productId: number
    quantity: number
    fg: FGCreateNestedOneWithoutFgProductsInput
  }

  export type FG_PRODUCTSUncheckedCreateInput = {
    id?: number
    fgId: number
    productId: number
    quantity: number
  }

  export type FG_PRODUCTSUpdateInput = {
    productId?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    fg?: FGUpdateOneRequiredWithoutFgProductsNestedInput
  }

  export type FG_PRODUCTSUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    fgId?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
  }

  export type FG_PRODUCTSCreateManyInput = {
    id?: number
    fgId: number
    productId: number
    quantity: number
  }

  export type FG_PRODUCTSUpdateManyMutationInput = {
    productId?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
  }

  export type FG_PRODUCTSUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    fgId?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
  }

  export type WIP_TRANSACTIONSCreateInput = {
    quantity: number
    transactionType: $Enums.TransactionType
    reason: string
    status: $Enums.Status
    createdAt?: Date | string
    updatedAt?: Date | string
    wip: WIPCreateNestedOneWithoutWIPTransactionsInput
    initiatedBy: EmployeeCreateNestedOneWithoutWIPTransactionsInput
    wipQC?: WIP_QCCreateNestedManyWithoutWIPTransactionsInput
    wipWasteLogs?: WIP_WASTAGE_LOGSCreateNestedManyWithoutWIPTransactionsInput
  }

  export type WIP_TRANSACTIONSUncheckedCreateInput = {
    id?: number
    wipId: number
    quantity: number
    transactionType: $Enums.TransactionType
    reason: string
    status: $Enums.Status
    initiatedById: number
    createdAt?: Date | string
    updatedAt?: Date | string
    wipQC?: WIP_QCUncheckedCreateNestedManyWithoutWIPTransactionsInput
    wipWasteLogs?: WIP_WASTAGE_LOGSUncheckedCreateNestedManyWithoutWIPTransactionsInput
  }

  export type WIP_TRANSACTIONSUpdateInput = {
    quantity?: IntFieldUpdateOperationsInput | number
    transactionType?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    reason?: StringFieldUpdateOperationsInput | string
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    wip?: WIPUpdateOneRequiredWithoutWIPTransactionsNestedInput
    initiatedBy?: EmployeeUpdateOneRequiredWithoutWIPTransactionsNestedInput
    wipQC?: WIP_QCUpdateManyWithoutWIPTransactionsNestedInput
    wipWasteLogs?: WIP_WASTAGE_LOGSUpdateManyWithoutWIPTransactionsNestedInput
  }

  export type WIP_TRANSACTIONSUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    wipId?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    transactionType?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    reason?: StringFieldUpdateOperationsInput | string
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    initiatedById?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    wipQC?: WIP_QCUncheckedUpdateManyWithoutWIPTransactionsNestedInput
    wipWasteLogs?: WIP_WASTAGE_LOGSUncheckedUpdateManyWithoutWIPTransactionsNestedInput
  }

  export type WIP_TRANSACTIONSCreateManyInput = {
    id?: number
    wipId: number
    quantity: number
    transactionType: $Enums.TransactionType
    reason: string
    status: $Enums.Status
    initiatedById: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WIP_TRANSACTIONSUpdateManyMutationInput = {
    quantity?: IntFieldUpdateOperationsInput | number
    transactionType?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    reason?: StringFieldUpdateOperationsInput | string
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WIP_TRANSACTIONSUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    wipId?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    transactionType?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    reason?: StringFieldUpdateOperationsInput | string
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    initiatedById?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FG_TRANSACTIONSCreateInput = {
    quantity: number
    transactionType: $Enums.TransactionType
    status: $Enums.Status
    reason: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    fg: FGCreateNestedOneWithoutFGTransactionsInput
    initiatedBy: EmployeeCreateNestedOneWithoutFGTransactionsInput
    fgQC?: FG_QCCreateNestedManyWithoutFGTransactionsInput
    fgWasteLogs?: FG_WASTAGE_LOGSCreateNestedManyWithoutFGTransactionsInput
  }

  export type FG_TRANSACTIONSUncheckedCreateInput = {
    id?: number
    fgId: number
    quantity: number
    transactionType: $Enums.TransactionType
    status: $Enums.Status
    reason: string
    IntiatedById: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    fgQC?: FG_QCUncheckedCreateNestedManyWithoutFGTransactionsInput
    fgWasteLogs?: FG_WASTAGE_LOGSUncheckedCreateNestedManyWithoutFGTransactionsInput
  }

  export type FG_TRANSACTIONSUpdateInput = {
    quantity?: IntFieldUpdateOperationsInput | number
    transactionType?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    reason?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fg?: FGUpdateOneRequiredWithoutFGTransactionsNestedInput
    initiatedBy?: EmployeeUpdateOneRequiredWithoutFGTransactionsNestedInput
    fgQC?: FG_QCUpdateManyWithoutFGTransactionsNestedInput
    fgWasteLogs?: FG_WASTAGE_LOGSUpdateManyWithoutFGTransactionsNestedInput
  }

  export type FG_TRANSACTIONSUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    fgId?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    transactionType?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    reason?: StringFieldUpdateOperationsInput | string
    IntiatedById?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fgQC?: FG_QCUncheckedUpdateManyWithoutFGTransactionsNestedInput
    fgWasteLogs?: FG_WASTAGE_LOGSUncheckedUpdateManyWithoutFGTransactionsNestedInput
  }

  export type FG_TRANSACTIONSCreateManyInput = {
    id?: number
    fgId: number
    quantity: number
    transactionType: $Enums.TransactionType
    status: $Enums.Status
    reason: string
    IntiatedById: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type FG_TRANSACTIONSUpdateManyMutationInput = {
    quantity?: IntFieldUpdateOperationsInput | number
    transactionType?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    reason?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type FG_TRANSACTIONSUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    fgId?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    transactionType?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    reason?: StringFieldUpdateOperationsInput | string
    IntiatedById?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type WIP_QCCreateInput = {
    transactionType: $Enums.TransactionType
    quality_status: $Enums.QualityStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    wip: WIPCreateNestedOneWithoutWIPQCsInput
    WIPTransactions: WIP_TRANSACTIONSCreateNestedOneWithoutWipQCInput
  }

  export type WIP_QCUncheckedCreateInput = {
    id?: number
    transactionId: number
    transactionType: $Enums.TransactionType
    wipId: number
    quality_status: $Enums.QualityStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WIP_QCUpdateInput = {
    transactionType?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    quality_status?: EnumQualityStatusFieldUpdateOperationsInput | $Enums.QualityStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    wip?: WIPUpdateOneRequiredWithoutWIPQCsNestedInput
    WIPTransactions?: WIP_TRANSACTIONSUpdateOneRequiredWithoutWipQCNestedInput
  }

  export type WIP_QCUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    transactionId?: IntFieldUpdateOperationsInput | number
    transactionType?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    wipId?: IntFieldUpdateOperationsInput | number
    quality_status?: EnumQualityStatusFieldUpdateOperationsInput | $Enums.QualityStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WIP_QCCreateManyInput = {
    id?: number
    transactionId: number
    transactionType: $Enums.TransactionType
    wipId: number
    quality_status: $Enums.QualityStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WIP_QCUpdateManyMutationInput = {
    transactionType?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    quality_status?: EnumQualityStatusFieldUpdateOperationsInput | $Enums.QualityStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WIP_QCUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    transactionId?: IntFieldUpdateOperationsInput | number
    transactionType?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    wipId?: IntFieldUpdateOperationsInput | number
    quality_status?: EnumQualityStatusFieldUpdateOperationsInput | $Enums.QualityStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FG_QCCreateInput = {
    transactionType: $Enums.TransactionType
    quality_status: $Enums.QualityStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    fg: FGCreateNestedOneWithoutFGQCsInput
    FGTransactions: FG_TRANSACTIONSCreateNestedOneWithoutFgQCInput
  }

  export type FG_QCUncheckedCreateInput = {
    id?: number
    transactionId: number
    transactionType: $Enums.TransactionType
    fgId: number
    quality_status: $Enums.QualityStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FG_QCUpdateInput = {
    transactionType?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    quality_status?: EnumQualityStatusFieldUpdateOperationsInput | $Enums.QualityStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fg?: FGUpdateOneRequiredWithoutFGQCsNestedInput
    FGTransactions?: FG_TRANSACTIONSUpdateOneRequiredWithoutFgQCNestedInput
  }

  export type FG_QCUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    transactionId?: IntFieldUpdateOperationsInput | number
    transactionType?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    fgId?: IntFieldUpdateOperationsInput | number
    quality_status?: EnumQualityStatusFieldUpdateOperationsInput | $Enums.QualityStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FG_QCCreateManyInput = {
    id?: number
    transactionId: number
    transactionType: $Enums.TransactionType
    fgId: number
    quality_status: $Enums.QualityStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FG_QCUpdateManyMutationInput = {
    transactionType?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    quality_status?: EnumQualityStatusFieldUpdateOperationsInput | $Enums.QualityStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FG_QCUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    transactionId?: IntFieldUpdateOperationsInput | number
    transactionType?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    fgId?: IntFieldUpdateOperationsInput | number
    quality_status?: EnumQualityStatusFieldUpdateOperationsInput | $Enums.QualityStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WIP_WASTAGE_LOGSCreateInput = {
    transactionType: $Enums.TransactionType
    quantity: number
    reason: string
    createdAt?: Date | string
    updatedAt?: Date | string
    wip: WIPCreateNestedOneWithoutWIPWastageLogsInput
    WIPTransactions: WIP_TRANSACTIONSCreateNestedOneWithoutWipWasteLogsInput
  }

  export type WIP_WASTAGE_LOGSUncheckedCreateInput = {
    id?: number
    transactionId: number
    transactionType: $Enums.TransactionType
    wipId: number
    quantity: number
    reason: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WIP_WASTAGE_LOGSUpdateInput = {
    transactionType?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    quantity?: IntFieldUpdateOperationsInput | number
    reason?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    wip?: WIPUpdateOneRequiredWithoutWIPWastageLogsNestedInput
    WIPTransactions?: WIP_TRANSACTIONSUpdateOneRequiredWithoutWipWasteLogsNestedInput
  }

  export type WIP_WASTAGE_LOGSUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    transactionId?: IntFieldUpdateOperationsInput | number
    transactionType?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    wipId?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    reason?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WIP_WASTAGE_LOGSCreateManyInput = {
    id?: number
    transactionId: number
    transactionType: $Enums.TransactionType
    wipId: number
    quantity: number
    reason: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WIP_WASTAGE_LOGSUpdateManyMutationInput = {
    transactionType?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    quantity?: IntFieldUpdateOperationsInput | number
    reason?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WIP_WASTAGE_LOGSUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    transactionId?: IntFieldUpdateOperationsInput | number
    transactionType?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    wipId?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    reason?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FG_WASTAGE_LOGSCreateInput = {
    transactionType: $Enums.TransactionType
    quantity: number
    reason: string
    createdAt?: Date | string
    updatedAt?: Date | string
    fg: FGCreateNestedOneWithoutFGWastageLogsInput
    FGTransactions: FG_TRANSACTIONSCreateNestedOneWithoutFgWasteLogsInput
  }

  export type FG_WASTAGE_LOGSUncheckedCreateInput = {
    id?: number
    transactionId: number
    transactionType: $Enums.TransactionType
    fgId: number
    quantity: number
    reason: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FG_WASTAGE_LOGSUpdateInput = {
    transactionType?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    quantity?: IntFieldUpdateOperationsInput | number
    reason?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fg?: FGUpdateOneRequiredWithoutFGWastageLogsNestedInput
    FGTransactions?: FG_TRANSACTIONSUpdateOneRequiredWithoutFgWasteLogsNestedInput
  }

  export type FG_WASTAGE_LOGSUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    transactionId?: IntFieldUpdateOperationsInput | number
    transactionType?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    fgId?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    reason?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FG_WASTAGE_LOGSCreateManyInput = {
    id?: number
    transactionId: number
    transactionType: $Enums.TransactionType
    fgId: number
    quantity: number
    reason: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FG_WASTAGE_LOGSUpdateManyMutationInput = {
    transactionType?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    quantity?: IntFieldUpdateOperationsInput | number
    reason?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FG_WASTAGE_LOGSUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    transactionId?: IntFieldUpdateOperationsInput | number
    transactionType?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    fgId?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    reason?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogsCreateInput = {
    tableName: string
    action: $Enums.Actions
    oldValue?: NullableJsonNullValueInput | InputJsonValue
    newValue?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    changedBy: EmployeeCreateNestedOneWithoutAuditLogsInput
  }

  export type AuditLogsUncheckedCreateInput = {
    id?: number
    tableName: string
    action: $Enums.Actions
    oldValue?: NullableJsonNullValueInput | InputJsonValue
    newValue?: NullableJsonNullValueInput | InputJsonValue
    changedById: number
    createdAt?: Date | string
  }

  export type AuditLogsUpdateInput = {
    tableName?: StringFieldUpdateOperationsInput | string
    action?: EnumActionsFieldUpdateOperationsInput | $Enums.Actions
    oldValue?: NullableJsonNullValueInput | InputJsonValue
    newValue?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    changedBy?: EmployeeUpdateOneRequiredWithoutAuditLogsNestedInput
  }

  export type AuditLogsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    tableName?: StringFieldUpdateOperationsInput | string
    action?: EnumActionsFieldUpdateOperationsInput | $Enums.Actions
    oldValue?: NullableJsonNullValueInput | InputJsonValue
    newValue?: NullableJsonNullValueInput | InputJsonValue
    changedById?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogsCreateManyInput = {
    id?: number
    tableName: string
    action: $Enums.Actions
    oldValue?: NullableJsonNullValueInput | InputJsonValue
    newValue?: NullableJsonNullValueInput | InputJsonValue
    changedById: number
    createdAt?: Date | string
  }

  export type AuditLogsUpdateManyMutationInput = {
    tableName?: StringFieldUpdateOperationsInput | string
    action?: EnumActionsFieldUpdateOperationsInput | $Enums.Actions
    oldValue?: NullableJsonNullValueInput | InputJsonValue
    newValue?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    tableName?: StringFieldUpdateOperationsInput | string
    action?: EnumActionsFieldUpdateOperationsInput | $Enums.Actions
    oldValue?: NullableJsonNullValueInput | InputJsonValue
    newValue?: NullableJsonNullValueInput | InputJsonValue
    changedById?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BigIntFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[]
    notIn?: bigint[] | number[]
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntFilter<$PrismaModel> | bigint | number
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type DecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[]
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[]
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type EnumQualityStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.QualityStatus | EnumQualityStatusFieldRefInput<$PrismaModel>
    in?: $Enums.QualityStatus[]
    notIn?: $Enums.QualityStatus[]
    not?: NestedEnumQualityStatusFilter<$PrismaModel> | $Enums.QualityStatus
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type VARIANT_RAW_MATERIALS_TRACKERListRelationFilter = {
    every?: VARIANT_RAW_MATERIALS_TRACKERWhereInput
    some?: VARIANT_RAW_MATERIALS_TRACKERWhereInput
    none?: VARIANT_RAW_MATERIALS_TRACKERWhereInput
  }

  export type RM_TRANSACTIONSListRelationFilter = {
    every?: RM_TRANSACTIONSWhereInput
    some?: RM_TRANSACTIONSWhereInput
    none?: RM_TRANSACTIONSWhereInput
  }

  export type RM_QCListRelationFilter = {
    every?: RM_QCWhereInput
    some?: RM_QCWhereInput
    none?: RM_QCWhereInput
  }

  export type RM_WASTAGE_LOGSListRelationFilter = {
    every?: RM_WASTAGE_LOGSWhereInput
    some?: RM_WASTAGE_LOGSWhereInput
    none?: RM_WASTAGE_LOGSWhereInput
  }

  export type WIPRawMaterialListRelationFilter = {
    every?: WIPRawMaterialWhereInput
    some?: WIPRawMaterialWhereInput
    none?: WIPRawMaterialWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type VARIANT_RAW_MATERIALS_TRACKEROrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RM_TRANSACTIONSOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RM_QCOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RM_WASTAGE_LOGSOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type WIPRawMaterialOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RAW_MATERIALSOrderByRelevanceInput = {
    fields: RAW_MATERIALSOrderByRelevanceFieldEnum | RAW_MATERIALSOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type RAW_MATERIALSCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    SKU?: SortOrder
    quantity?: SortOrder
    price?: SortOrder
    image?: SortOrder
    description?: SortOrder
    expiry_date?: SortOrder
    quality_status?: SortOrder
    storage_location?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type RAW_MATERIALSAvgOrderByAggregateInput = {
    id?: SortOrder
    quantity?: SortOrder
    price?: SortOrder
  }

  export type RAW_MATERIALSMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    SKU?: SortOrder
    quantity?: SortOrder
    price?: SortOrder
    image?: SortOrder
    description?: SortOrder
    expiry_date?: SortOrder
    quality_status?: SortOrder
    storage_location?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type RAW_MATERIALSMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    SKU?: SortOrder
    quantity?: SortOrder
    price?: SortOrder
    image?: SortOrder
    description?: SortOrder
    expiry_date?: SortOrder
    quality_status?: SortOrder
    storage_location?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type RAW_MATERIALSSumOrderByAggregateInput = {
    id?: SortOrder
    quantity?: SortOrder
    price?: SortOrder
  }

  export type BigIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[]
    notIn?: bigint[] | number[]
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntWithAggregatesFilter<$PrismaModel> | bigint | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedBigIntFilter<$PrismaModel>
    _min?: NestedBigIntFilter<$PrismaModel>
    _max?: NestedBigIntFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type DecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[]
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[]
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type EnumQualityStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.QualityStatus | EnumQualityStatusFieldRefInput<$PrismaModel>
    in?: $Enums.QualityStatus[]
    notIn?: $Enums.QualityStatus[]
    not?: NestedEnumQualityStatusWithAggregatesFilter<$PrismaModel> | $Enums.QualityStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumQualityStatusFilter<$PrismaModel>
    _max?: NestedEnumQualityStatusFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type SHOPIFY_PRODUCTSScalarRelationFilter = {
    is?: SHOPIFY_PRODUCTSWhereInput
    isNot?: SHOPIFY_PRODUCTSWhereInput
  }

  export type SHOPIFY_VARIANTSOrderByRelevanceInput = {
    fields: SHOPIFY_VARIANTSOrderByRelevanceFieldEnum | SHOPIFY_VARIANTSOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type SHOPIFY_VARIANTSCountOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    name?: SortOrder
    AvailableQty?: SortOrder
    img?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
    variantName?: SortOrder
    variantOption?: SortOrder
  }

  export type SHOPIFY_VARIANTSAvgOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    AvailableQty?: SortOrder
  }

  export type SHOPIFY_VARIANTSMaxOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    name?: SortOrder
    AvailableQty?: SortOrder
    img?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
    variantName?: SortOrder
    variantOption?: SortOrder
  }

  export type SHOPIFY_VARIANTSMinOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    name?: SortOrder
    AvailableQty?: SortOrder
    img?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
    variantName?: SortOrder
    variantOption?: SortOrder
  }

  export type SHOPIFY_VARIANTSSumOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    AvailableQty?: SortOrder
  }

  export type SHOPIFY_VARIANTSScalarRelationFilter = {
    is?: SHOPIFY_VARIANTSWhereInput
    isNot?: SHOPIFY_VARIANTSWhereInput
  }

  export type RAW_MATERIALSScalarRelationFilter = {
    is?: RAW_MATERIALSWhereInput
    isNot?: RAW_MATERIALSWhereInput
  }

  export type VARIANT_RAW_MATERIALS_TRACKERVariantIdRawMaterialIdCompoundUniqueInput = {
    variantId: bigint | number
    rawMaterialId: bigint | number
  }

  export type VARIANT_RAW_MATERIALS_TRACKERCountOrderByAggregateInput = {
    variantId?: SortOrder
    rawMaterialId?: SortOrder
    avgQuantity?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type VARIANT_RAW_MATERIALS_TRACKERAvgOrderByAggregateInput = {
    variantId?: SortOrder
    rawMaterialId?: SortOrder
    avgQuantity?: SortOrder
  }

  export type VARIANT_RAW_MATERIALS_TRACKERMaxOrderByAggregateInput = {
    variantId?: SortOrder
    rawMaterialId?: SortOrder
    avgQuantity?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type VARIANT_RAW_MATERIALS_TRACKERMinOrderByAggregateInput = {
    variantId?: SortOrder
    rawMaterialId?: SortOrder
    avgQuantity?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type VARIANT_RAW_MATERIALS_TRACKERSumOrderByAggregateInput = {
    variantId?: SortOrder
    rawMaterialId?: SortOrder
    avgQuantity?: SortOrder
  }

  export type SHOPIFY_PRODUCTSListRelationFilter = {
    every?: SHOPIFY_PRODUCTSWhereInput
    some?: SHOPIFY_PRODUCTSWhereInput
    none?: SHOPIFY_PRODUCTSWhereInput
  }

  export type SHOPIFY_PRODUCTSOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CATEGORIESOrderByRelevanceInput = {
    fields: CATEGORIESOrderByRelevanceFieldEnum | CATEGORIESOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type CATEGORIESCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CATEGORIESAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type CATEGORIESMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CATEGORIESMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CATEGORIESSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type CATEGORIESScalarRelationFilter = {
    is?: CATEGORIESWhereInput
    isNot?: CATEGORIESWhereInput
  }

  export type SHOPIFY_VARIANTSListRelationFilter = {
    every?: SHOPIFY_VARIANTSWhereInput
    some?: SHOPIFY_VARIANTSWhereInput
    none?: SHOPIFY_VARIANTSWhereInput
  }

  export type WIP_PRODUCTSListRelationFilter = {
    every?: WIP_PRODUCTSWhereInput
    some?: WIP_PRODUCTSWhereInput
    none?: WIP_PRODUCTSWhereInput
  }

  export type SHOPIFY_VARIANTSOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type WIP_PRODUCTSOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SHOPIFY_PRODUCTSOrderByRelevanceInput = {
    fields: SHOPIFY_PRODUCTSOrderByRelevanceFieldEnum | SHOPIFY_PRODUCTSOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type SHOPIFY_PRODUCTSCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    categoryId?: SortOrder
    price?: SortOrder
    status?: SortOrder
    img?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SHOPIFY_PRODUCTSAvgOrderByAggregateInput = {
    id?: SortOrder
    categoryId?: SortOrder
    price?: SortOrder
  }

  export type SHOPIFY_PRODUCTSMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    categoryId?: SortOrder
    price?: SortOrder
    status?: SortOrder
    img?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SHOPIFY_PRODUCTSMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    categoryId?: SortOrder
    price?: SortOrder
    status?: SortOrder
    img?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SHOPIFY_PRODUCTSSumOrderByAggregateInput = {
    id?: SortOrder
    categoryId?: SortOrder
    price?: SortOrder
  }

  export type EnumTransactionTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.TransactionType | EnumTransactionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TransactionType[]
    notIn?: $Enums.TransactionType[]
    not?: NestedEnumTransactionTypeFilter<$PrismaModel> | $Enums.TransactionType
  }

  export type EmployeeScalarRelationFilter = {
    is?: EmployeeWhereInput
    isNot?: EmployeeWhereInput
  }

  export type RM_TRANSACTIONSOrderByRelevanceInput = {
    fields: RM_TRANSACTIONSOrderByRelevanceFieldEnum | RM_TRANSACTIONSOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type RM_TRANSACTIONSCountOrderByAggregateInput = {
    id?: SortOrder
    rawMaterialId?: SortOrder
    quantity?: SortOrder
    transactionType?: SortOrder
    reason?: SortOrder
    status?: SortOrder
    initiatedById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type RM_TRANSACTIONSAvgOrderByAggregateInput = {
    id?: SortOrder
    rawMaterialId?: SortOrder
    quantity?: SortOrder
    initiatedById?: SortOrder
  }

  export type RM_TRANSACTIONSMaxOrderByAggregateInput = {
    id?: SortOrder
    rawMaterialId?: SortOrder
    quantity?: SortOrder
    transactionType?: SortOrder
    reason?: SortOrder
    status?: SortOrder
    initiatedById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type RM_TRANSACTIONSMinOrderByAggregateInput = {
    id?: SortOrder
    rawMaterialId?: SortOrder
    quantity?: SortOrder
    transactionType?: SortOrder
    reason?: SortOrder
    status?: SortOrder
    initiatedById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type RM_TRANSACTIONSSumOrderByAggregateInput = {
    id?: SortOrder
    rawMaterialId?: SortOrder
    quantity?: SortOrder
    initiatedById?: SortOrder
  }

  export type EnumTransactionTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TransactionType | EnumTransactionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TransactionType[]
    notIn?: $Enums.TransactionType[]
    not?: NestedEnumTransactionTypeWithAggregatesFilter<$PrismaModel> | $Enums.TransactionType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTransactionTypeFilter<$PrismaModel>
    _max?: NestedEnumTransactionTypeFilter<$PrismaModel>
  }

  export type RM_TRANSACTIONSScalarRelationFilter = {
    is?: RM_TRANSACTIONSWhereInput
    isNot?: RM_TRANSACTIONSWhereInput
  }

  export type RM_QCCountOrderByAggregateInput = {
    id?: SortOrder
    transactionId?: SortOrder
    rawMaterialId?: SortOrder
    quality_status?: SortOrder
    checkedById?: SortOrder
    doneById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type RM_QCAvgOrderByAggregateInput = {
    id?: SortOrder
    transactionId?: SortOrder
    rawMaterialId?: SortOrder
    checkedById?: SortOrder
    doneById?: SortOrder
  }

  export type RM_QCMaxOrderByAggregateInput = {
    id?: SortOrder
    transactionId?: SortOrder
    rawMaterialId?: SortOrder
    quality_status?: SortOrder
    checkedById?: SortOrder
    doneById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type RM_QCMinOrderByAggregateInput = {
    id?: SortOrder
    transactionId?: SortOrder
    rawMaterialId?: SortOrder
    quality_status?: SortOrder
    checkedById?: SortOrder
    doneById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type RM_QCSumOrderByAggregateInput = {
    id?: SortOrder
    transactionId?: SortOrder
    rawMaterialId?: SortOrder
    checkedById?: SortOrder
    doneById?: SortOrder
  }

  export type RM_WASTAGE_LOGSOrderByRelevanceInput = {
    fields: RM_WASTAGE_LOGSOrderByRelevanceFieldEnum | RM_WASTAGE_LOGSOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type RM_WASTAGE_LOGSCountOrderByAggregateInput = {
    id?: SortOrder
    transactionId?: SortOrder
    rawMaterialId?: SortOrder
    quantity?: SortOrder
    reason?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type RM_WASTAGE_LOGSAvgOrderByAggregateInput = {
    id?: SortOrder
    transactionId?: SortOrder
    rawMaterialId?: SortOrder
    quantity?: SortOrder
  }

  export type RM_WASTAGE_LOGSMaxOrderByAggregateInput = {
    id?: SortOrder
    transactionId?: SortOrder
    rawMaterialId?: SortOrder
    quantity?: SortOrder
    reason?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type RM_WASTAGE_LOGSMinOrderByAggregateInput = {
    id?: SortOrder
    transactionId?: SortOrder
    rawMaterialId?: SortOrder
    quantity?: SortOrder
    reason?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type RM_WASTAGE_LOGSSumOrderByAggregateInput = {
    id?: SortOrder
    transactionId?: SortOrder
    rawMaterialId?: SortOrder
    quantity?: SortOrder
  }

  export type EnumRolesFilter<$PrismaModel = never> = {
    equals?: $Enums.Roles | EnumRolesFieldRefInput<$PrismaModel>
    in?: $Enums.Roles[]
    notIn?: $Enums.Roles[]
    not?: NestedEnumRolesFilter<$PrismaModel> | $Enums.Roles
  }

  export type WIP_TRANSACTIONSListRelationFilter = {
    every?: WIP_TRANSACTIONSWhereInput
    some?: WIP_TRANSACTIONSWhereInput
    none?: WIP_TRANSACTIONSWhereInput
  }

  export type FG_TRANSACTIONSListRelationFilter = {
    every?: FG_TRANSACTIONSWhereInput
    some?: FG_TRANSACTIONSWhereInput
    none?: FG_TRANSACTIONSWhereInput
  }

  export type AuditLogsListRelationFilter = {
    every?: AuditLogsWhereInput
    some?: AuditLogsWhereInput
    none?: AuditLogsWhereInput
  }

  export type WIP_TRANSACTIONSOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FG_TRANSACTIONSOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AuditLogsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EmployeeOrderByRelevanceInput = {
    fields: EmployeeOrderByRelevanceFieldEnum | EmployeeOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type EmployeeCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type EmployeeAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type EmployeeMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type EmployeeMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type EmployeeSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type EnumRolesWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Roles | EnumRolesFieldRefInput<$PrismaModel>
    in?: $Enums.Roles[]
    notIn?: $Enums.Roles[]
    not?: NestedEnumRolesWithAggregatesFilter<$PrismaModel> | $Enums.Roles
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRolesFilter<$PrismaModel>
    _max?: NestedEnumRolesFilter<$PrismaModel>
  }

  export type EnumStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.Status | EnumStatusFieldRefInput<$PrismaModel>
    in?: $Enums.Status[]
    notIn?: $Enums.Status[]
    not?: NestedEnumStatusFilter<$PrismaModel> | $Enums.Status
  }

  export type WIP_QCListRelationFilter = {
    every?: WIP_QCWhereInput
    some?: WIP_QCWhereInput
    none?: WIP_QCWhereInput
  }

  export type WIP_WASTAGE_LOGSListRelationFilter = {
    every?: WIP_WASTAGE_LOGSWhereInput
    some?: WIP_WASTAGE_LOGSWhereInput
    none?: WIP_WASTAGE_LOGSWhereInput
  }

  export type WIP_QCOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type WIP_WASTAGE_LOGSOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type WIPCountOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WIPAvgOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
  }

  export type WIPMaxOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WIPMinOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WIPSumOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
  }

  export type EnumStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Status | EnumStatusFieldRefInput<$PrismaModel>
    in?: $Enums.Status[]
    notIn?: $Enums.Status[]
    not?: NestedEnumStatusWithAggregatesFilter<$PrismaModel> | $Enums.Status
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumStatusFilter<$PrismaModel>
    _max?: NestedEnumStatusFilter<$PrismaModel>
  }

  export type WIPScalarRelationFilter = {
    is?: WIPWhereInput
    isNot?: WIPWhereInput
  }

  export type WIP_PRODUCTSCountOrderByAggregateInput = {
    id?: SortOrder
    wipId?: SortOrder
    productId?: SortOrder
    quantity?: SortOrder
  }

  export type WIP_PRODUCTSAvgOrderByAggregateInput = {
    id?: SortOrder
    wipId?: SortOrder
    productId?: SortOrder
    quantity?: SortOrder
  }

  export type WIP_PRODUCTSMaxOrderByAggregateInput = {
    id?: SortOrder
    wipId?: SortOrder
    productId?: SortOrder
    quantity?: SortOrder
  }

  export type WIP_PRODUCTSMinOrderByAggregateInput = {
    id?: SortOrder
    wipId?: SortOrder
    productId?: SortOrder
    quantity?: SortOrder
  }

  export type WIP_PRODUCTSSumOrderByAggregateInput = {
    id?: SortOrder
    wipId?: SortOrder
    productId?: SortOrder
    quantity?: SortOrder
  }

  export type WIPRawMaterialCountOrderByAggregateInput = {
    id?: SortOrder
    wipId?: SortOrder
    rawMaterialId?: SortOrder
    quantity?: SortOrder
  }

  export type WIPRawMaterialAvgOrderByAggregateInput = {
    id?: SortOrder
    wipId?: SortOrder
    rawMaterialId?: SortOrder
    quantity?: SortOrder
  }

  export type WIPRawMaterialMaxOrderByAggregateInput = {
    id?: SortOrder
    wipId?: SortOrder
    rawMaterialId?: SortOrder
    quantity?: SortOrder
  }

  export type WIPRawMaterialMinOrderByAggregateInput = {
    id?: SortOrder
    wipId?: SortOrder
    rawMaterialId?: SortOrder
    quantity?: SortOrder
  }

  export type WIPRawMaterialSumOrderByAggregateInput = {
    id?: SortOrder
    wipId?: SortOrder
    rawMaterialId?: SortOrder
    quantity?: SortOrder
  }

  export type FG_QCListRelationFilter = {
    every?: FG_QCWhereInput
    some?: FG_QCWhereInput
    none?: FG_QCWhereInput
  }

  export type FG_WASTAGE_LOGSListRelationFilter = {
    every?: FG_WASTAGE_LOGSWhereInput
    some?: FG_WASTAGE_LOGSWhereInput
    none?: FG_WASTAGE_LOGSWhereInput
  }

  export type FG_PRODUCTSListRelationFilter = {
    every?: FG_PRODUCTSWhereInput
    some?: FG_PRODUCTSWhereInput
    none?: FG_PRODUCTSWhereInput
  }

  export type FG_QCOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FG_WASTAGE_LOGSOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FG_PRODUCTSOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FGOrderByRelevanceInput = {
    fields: FGOrderByRelevanceFieldEnum | FGOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type FGCountOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    customerName?: SortOrder
    price?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    deliveryDate?: SortOrder
  }

  export type FGAvgOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    price?: SortOrder
  }

  export type FGMaxOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    customerName?: SortOrder
    price?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    deliveryDate?: SortOrder
  }

  export type FGMinOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    customerName?: SortOrder
    price?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    deliveryDate?: SortOrder
  }

  export type FGSumOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    price?: SortOrder
  }

  export type FGScalarRelationFilter = {
    is?: FGWhereInput
    isNot?: FGWhereInput
  }

  export type FG_PRODUCTSCountOrderByAggregateInput = {
    id?: SortOrder
    fgId?: SortOrder
    productId?: SortOrder
    quantity?: SortOrder
  }

  export type FG_PRODUCTSAvgOrderByAggregateInput = {
    id?: SortOrder
    fgId?: SortOrder
    productId?: SortOrder
    quantity?: SortOrder
  }

  export type FG_PRODUCTSMaxOrderByAggregateInput = {
    id?: SortOrder
    fgId?: SortOrder
    productId?: SortOrder
    quantity?: SortOrder
  }

  export type FG_PRODUCTSMinOrderByAggregateInput = {
    id?: SortOrder
    fgId?: SortOrder
    productId?: SortOrder
    quantity?: SortOrder
  }

  export type FG_PRODUCTSSumOrderByAggregateInput = {
    id?: SortOrder
    fgId?: SortOrder
    productId?: SortOrder
    quantity?: SortOrder
  }

  export type WIP_TRANSACTIONSOrderByRelevanceInput = {
    fields: WIP_TRANSACTIONSOrderByRelevanceFieldEnum | WIP_TRANSACTIONSOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type WIP_TRANSACTIONSCountOrderByAggregateInput = {
    id?: SortOrder
    wipId?: SortOrder
    quantity?: SortOrder
    transactionType?: SortOrder
    reason?: SortOrder
    status?: SortOrder
    initiatedById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WIP_TRANSACTIONSAvgOrderByAggregateInput = {
    id?: SortOrder
    wipId?: SortOrder
    quantity?: SortOrder
    initiatedById?: SortOrder
  }

  export type WIP_TRANSACTIONSMaxOrderByAggregateInput = {
    id?: SortOrder
    wipId?: SortOrder
    quantity?: SortOrder
    transactionType?: SortOrder
    reason?: SortOrder
    status?: SortOrder
    initiatedById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WIP_TRANSACTIONSMinOrderByAggregateInput = {
    id?: SortOrder
    wipId?: SortOrder
    quantity?: SortOrder
    transactionType?: SortOrder
    reason?: SortOrder
    status?: SortOrder
    initiatedById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WIP_TRANSACTIONSSumOrderByAggregateInput = {
    id?: SortOrder
    wipId?: SortOrder
    quantity?: SortOrder
    initiatedById?: SortOrder
  }

  export type FG_TRANSACTIONSOrderByRelevanceInput = {
    fields: FG_TRANSACTIONSOrderByRelevanceFieldEnum | FG_TRANSACTIONSOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type FG_TRANSACTIONSCountOrderByAggregateInput = {
    id?: SortOrder
    fgId?: SortOrder
    quantity?: SortOrder
    transactionType?: SortOrder
    status?: SortOrder
    reason?: SortOrder
    IntiatedById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type FG_TRANSACTIONSAvgOrderByAggregateInput = {
    id?: SortOrder
    fgId?: SortOrder
    quantity?: SortOrder
    IntiatedById?: SortOrder
  }

  export type FG_TRANSACTIONSMaxOrderByAggregateInput = {
    id?: SortOrder
    fgId?: SortOrder
    quantity?: SortOrder
    transactionType?: SortOrder
    status?: SortOrder
    reason?: SortOrder
    IntiatedById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type FG_TRANSACTIONSMinOrderByAggregateInput = {
    id?: SortOrder
    fgId?: SortOrder
    quantity?: SortOrder
    transactionType?: SortOrder
    status?: SortOrder
    reason?: SortOrder
    IntiatedById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type FG_TRANSACTIONSSumOrderByAggregateInput = {
    id?: SortOrder
    fgId?: SortOrder
    quantity?: SortOrder
    IntiatedById?: SortOrder
  }

  export type WIP_TRANSACTIONSScalarRelationFilter = {
    is?: WIP_TRANSACTIONSWhereInput
    isNot?: WIP_TRANSACTIONSWhereInput
  }

  export type WIP_QCCountOrderByAggregateInput = {
    id?: SortOrder
    transactionId?: SortOrder
    transactionType?: SortOrder
    wipId?: SortOrder
    quality_status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WIP_QCAvgOrderByAggregateInput = {
    id?: SortOrder
    transactionId?: SortOrder
    wipId?: SortOrder
  }

  export type WIP_QCMaxOrderByAggregateInput = {
    id?: SortOrder
    transactionId?: SortOrder
    transactionType?: SortOrder
    wipId?: SortOrder
    quality_status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WIP_QCMinOrderByAggregateInput = {
    id?: SortOrder
    transactionId?: SortOrder
    transactionType?: SortOrder
    wipId?: SortOrder
    quality_status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WIP_QCSumOrderByAggregateInput = {
    id?: SortOrder
    transactionId?: SortOrder
    wipId?: SortOrder
  }

  export type FG_TRANSACTIONSScalarRelationFilter = {
    is?: FG_TRANSACTIONSWhereInput
    isNot?: FG_TRANSACTIONSWhereInput
  }

  export type FG_QCCountOrderByAggregateInput = {
    id?: SortOrder
    transactionId?: SortOrder
    transactionType?: SortOrder
    fgId?: SortOrder
    quality_status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FG_QCAvgOrderByAggregateInput = {
    id?: SortOrder
    transactionId?: SortOrder
    fgId?: SortOrder
  }

  export type FG_QCMaxOrderByAggregateInput = {
    id?: SortOrder
    transactionId?: SortOrder
    transactionType?: SortOrder
    fgId?: SortOrder
    quality_status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FG_QCMinOrderByAggregateInput = {
    id?: SortOrder
    transactionId?: SortOrder
    transactionType?: SortOrder
    fgId?: SortOrder
    quality_status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FG_QCSumOrderByAggregateInput = {
    id?: SortOrder
    transactionId?: SortOrder
    fgId?: SortOrder
  }

  export type WIP_WASTAGE_LOGSOrderByRelevanceInput = {
    fields: WIP_WASTAGE_LOGSOrderByRelevanceFieldEnum | WIP_WASTAGE_LOGSOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type WIP_WASTAGE_LOGSCountOrderByAggregateInput = {
    id?: SortOrder
    transactionId?: SortOrder
    transactionType?: SortOrder
    wipId?: SortOrder
    quantity?: SortOrder
    reason?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WIP_WASTAGE_LOGSAvgOrderByAggregateInput = {
    id?: SortOrder
    transactionId?: SortOrder
    wipId?: SortOrder
    quantity?: SortOrder
  }

  export type WIP_WASTAGE_LOGSMaxOrderByAggregateInput = {
    id?: SortOrder
    transactionId?: SortOrder
    transactionType?: SortOrder
    wipId?: SortOrder
    quantity?: SortOrder
    reason?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WIP_WASTAGE_LOGSMinOrderByAggregateInput = {
    id?: SortOrder
    transactionId?: SortOrder
    transactionType?: SortOrder
    wipId?: SortOrder
    quantity?: SortOrder
    reason?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WIP_WASTAGE_LOGSSumOrderByAggregateInput = {
    id?: SortOrder
    transactionId?: SortOrder
    wipId?: SortOrder
    quantity?: SortOrder
  }

  export type FG_WASTAGE_LOGSOrderByRelevanceInput = {
    fields: FG_WASTAGE_LOGSOrderByRelevanceFieldEnum | FG_WASTAGE_LOGSOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type FG_WASTAGE_LOGSCountOrderByAggregateInput = {
    id?: SortOrder
    transactionId?: SortOrder
    transactionType?: SortOrder
    fgId?: SortOrder
    quantity?: SortOrder
    reason?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FG_WASTAGE_LOGSAvgOrderByAggregateInput = {
    id?: SortOrder
    transactionId?: SortOrder
    fgId?: SortOrder
    quantity?: SortOrder
  }

  export type FG_WASTAGE_LOGSMaxOrderByAggregateInput = {
    id?: SortOrder
    transactionId?: SortOrder
    transactionType?: SortOrder
    fgId?: SortOrder
    quantity?: SortOrder
    reason?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FG_WASTAGE_LOGSMinOrderByAggregateInput = {
    id?: SortOrder
    transactionId?: SortOrder
    transactionType?: SortOrder
    fgId?: SortOrder
    quantity?: SortOrder
    reason?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FG_WASTAGE_LOGSSumOrderByAggregateInput = {
    id?: SortOrder
    transactionId?: SortOrder
    fgId?: SortOrder
    quantity?: SortOrder
  }

  export type EnumActionsFilter<$PrismaModel = never> = {
    equals?: $Enums.Actions | EnumActionsFieldRefInput<$PrismaModel>
    in?: $Enums.Actions[]
    notIn?: $Enums.Actions[]
    not?: NestedEnumActionsFilter<$PrismaModel> | $Enums.Actions
  }
  export type JsonNullableFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue
    lte?: InputJsonValue
    gt?: InputJsonValue
    gte?: InputJsonValue
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type AuditLogsOrderByRelevanceInput = {
    fields: AuditLogsOrderByRelevanceFieldEnum | AuditLogsOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type AuditLogsCountOrderByAggregateInput = {
    id?: SortOrder
    tableName?: SortOrder
    action?: SortOrder
    oldValue?: SortOrder
    newValue?: SortOrder
    changedById?: SortOrder
    createdAt?: SortOrder
  }

  export type AuditLogsAvgOrderByAggregateInput = {
    id?: SortOrder
    changedById?: SortOrder
  }

  export type AuditLogsMaxOrderByAggregateInput = {
    id?: SortOrder
    tableName?: SortOrder
    action?: SortOrder
    changedById?: SortOrder
    createdAt?: SortOrder
  }

  export type AuditLogsMinOrderByAggregateInput = {
    id?: SortOrder
    tableName?: SortOrder
    action?: SortOrder
    changedById?: SortOrder
    createdAt?: SortOrder
  }

  export type AuditLogsSumOrderByAggregateInput = {
    id?: SortOrder
    changedById?: SortOrder
  }

  export type EnumActionsWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Actions | EnumActionsFieldRefInput<$PrismaModel>
    in?: $Enums.Actions[]
    notIn?: $Enums.Actions[]
    not?: NestedEnumActionsWithAggregatesFilter<$PrismaModel> | $Enums.Actions
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumActionsFilter<$PrismaModel>
    _max?: NestedEnumActionsFilter<$PrismaModel>
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue
    lte?: InputJsonValue
    gt?: InputJsonValue
    gte?: InputJsonValue
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type VARIANT_RAW_MATERIALS_TRACKERCreateNestedManyWithoutRawMaterialInput = {
    create?: XOR<VARIANT_RAW_MATERIALS_TRACKERCreateWithoutRawMaterialInput, VARIANT_RAW_MATERIALS_TRACKERUncheckedCreateWithoutRawMaterialInput> | VARIANT_RAW_MATERIALS_TRACKERCreateWithoutRawMaterialInput[] | VARIANT_RAW_MATERIALS_TRACKERUncheckedCreateWithoutRawMaterialInput[]
    connectOrCreate?: VARIANT_RAW_MATERIALS_TRACKERCreateOrConnectWithoutRawMaterialInput | VARIANT_RAW_MATERIALS_TRACKERCreateOrConnectWithoutRawMaterialInput[]
    createMany?: VARIANT_RAW_MATERIALS_TRACKERCreateManyRawMaterialInputEnvelope
    connect?: VARIANT_RAW_MATERIALS_TRACKERWhereUniqueInput | VARIANT_RAW_MATERIALS_TRACKERWhereUniqueInput[]
  }

  export type RM_TRANSACTIONSCreateNestedManyWithoutRawMaterialInput = {
    create?: XOR<RM_TRANSACTIONSCreateWithoutRawMaterialInput, RM_TRANSACTIONSUncheckedCreateWithoutRawMaterialInput> | RM_TRANSACTIONSCreateWithoutRawMaterialInput[] | RM_TRANSACTIONSUncheckedCreateWithoutRawMaterialInput[]
    connectOrCreate?: RM_TRANSACTIONSCreateOrConnectWithoutRawMaterialInput | RM_TRANSACTIONSCreateOrConnectWithoutRawMaterialInput[]
    createMany?: RM_TRANSACTIONSCreateManyRawMaterialInputEnvelope
    connect?: RM_TRANSACTIONSWhereUniqueInput | RM_TRANSACTIONSWhereUniqueInput[]
  }

  export type RM_QCCreateNestedManyWithoutRawMaterialInput = {
    create?: XOR<RM_QCCreateWithoutRawMaterialInput, RM_QCUncheckedCreateWithoutRawMaterialInput> | RM_QCCreateWithoutRawMaterialInput[] | RM_QCUncheckedCreateWithoutRawMaterialInput[]
    connectOrCreate?: RM_QCCreateOrConnectWithoutRawMaterialInput | RM_QCCreateOrConnectWithoutRawMaterialInput[]
    createMany?: RM_QCCreateManyRawMaterialInputEnvelope
    connect?: RM_QCWhereUniqueInput | RM_QCWhereUniqueInput[]
  }

  export type RM_WASTAGE_LOGSCreateNestedManyWithoutRawMaterialInput = {
    create?: XOR<RM_WASTAGE_LOGSCreateWithoutRawMaterialInput, RM_WASTAGE_LOGSUncheckedCreateWithoutRawMaterialInput> | RM_WASTAGE_LOGSCreateWithoutRawMaterialInput[] | RM_WASTAGE_LOGSUncheckedCreateWithoutRawMaterialInput[]
    connectOrCreate?: RM_WASTAGE_LOGSCreateOrConnectWithoutRawMaterialInput | RM_WASTAGE_LOGSCreateOrConnectWithoutRawMaterialInput[]
    createMany?: RM_WASTAGE_LOGSCreateManyRawMaterialInputEnvelope
    connect?: RM_WASTAGE_LOGSWhereUniqueInput | RM_WASTAGE_LOGSWhereUniqueInput[]
  }

  export type WIPRawMaterialCreateNestedManyWithoutRawMaterialInput = {
    create?: XOR<WIPRawMaterialCreateWithoutRawMaterialInput, WIPRawMaterialUncheckedCreateWithoutRawMaterialInput> | WIPRawMaterialCreateWithoutRawMaterialInput[] | WIPRawMaterialUncheckedCreateWithoutRawMaterialInput[]
    connectOrCreate?: WIPRawMaterialCreateOrConnectWithoutRawMaterialInput | WIPRawMaterialCreateOrConnectWithoutRawMaterialInput[]
    createMany?: WIPRawMaterialCreateManyRawMaterialInputEnvelope
    connect?: WIPRawMaterialWhereUniqueInput | WIPRawMaterialWhereUniqueInput[]
  }

  export type VARIANT_RAW_MATERIALS_TRACKERUncheckedCreateNestedManyWithoutRawMaterialInput = {
    create?: XOR<VARIANT_RAW_MATERIALS_TRACKERCreateWithoutRawMaterialInput, VARIANT_RAW_MATERIALS_TRACKERUncheckedCreateWithoutRawMaterialInput> | VARIANT_RAW_MATERIALS_TRACKERCreateWithoutRawMaterialInput[] | VARIANT_RAW_MATERIALS_TRACKERUncheckedCreateWithoutRawMaterialInput[]
    connectOrCreate?: VARIANT_RAW_MATERIALS_TRACKERCreateOrConnectWithoutRawMaterialInput | VARIANT_RAW_MATERIALS_TRACKERCreateOrConnectWithoutRawMaterialInput[]
    createMany?: VARIANT_RAW_MATERIALS_TRACKERCreateManyRawMaterialInputEnvelope
    connect?: VARIANT_RAW_MATERIALS_TRACKERWhereUniqueInput | VARIANT_RAW_MATERIALS_TRACKERWhereUniqueInput[]
  }

  export type RM_TRANSACTIONSUncheckedCreateNestedManyWithoutRawMaterialInput = {
    create?: XOR<RM_TRANSACTIONSCreateWithoutRawMaterialInput, RM_TRANSACTIONSUncheckedCreateWithoutRawMaterialInput> | RM_TRANSACTIONSCreateWithoutRawMaterialInput[] | RM_TRANSACTIONSUncheckedCreateWithoutRawMaterialInput[]
    connectOrCreate?: RM_TRANSACTIONSCreateOrConnectWithoutRawMaterialInput | RM_TRANSACTIONSCreateOrConnectWithoutRawMaterialInput[]
    createMany?: RM_TRANSACTIONSCreateManyRawMaterialInputEnvelope
    connect?: RM_TRANSACTIONSWhereUniqueInput | RM_TRANSACTIONSWhereUniqueInput[]
  }

  export type RM_QCUncheckedCreateNestedManyWithoutRawMaterialInput = {
    create?: XOR<RM_QCCreateWithoutRawMaterialInput, RM_QCUncheckedCreateWithoutRawMaterialInput> | RM_QCCreateWithoutRawMaterialInput[] | RM_QCUncheckedCreateWithoutRawMaterialInput[]
    connectOrCreate?: RM_QCCreateOrConnectWithoutRawMaterialInput | RM_QCCreateOrConnectWithoutRawMaterialInput[]
    createMany?: RM_QCCreateManyRawMaterialInputEnvelope
    connect?: RM_QCWhereUniqueInput | RM_QCWhereUniqueInput[]
  }

  export type RM_WASTAGE_LOGSUncheckedCreateNestedManyWithoutRawMaterialInput = {
    create?: XOR<RM_WASTAGE_LOGSCreateWithoutRawMaterialInput, RM_WASTAGE_LOGSUncheckedCreateWithoutRawMaterialInput> | RM_WASTAGE_LOGSCreateWithoutRawMaterialInput[] | RM_WASTAGE_LOGSUncheckedCreateWithoutRawMaterialInput[]
    connectOrCreate?: RM_WASTAGE_LOGSCreateOrConnectWithoutRawMaterialInput | RM_WASTAGE_LOGSCreateOrConnectWithoutRawMaterialInput[]
    createMany?: RM_WASTAGE_LOGSCreateManyRawMaterialInputEnvelope
    connect?: RM_WASTAGE_LOGSWhereUniqueInput | RM_WASTAGE_LOGSWhereUniqueInput[]
  }

  export type WIPRawMaterialUncheckedCreateNestedManyWithoutRawMaterialInput = {
    create?: XOR<WIPRawMaterialCreateWithoutRawMaterialInput, WIPRawMaterialUncheckedCreateWithoutRawMaterialInput> | WIPRawMaterialCreateWithoutRawMaterialInput[] | WIPRawMaterialUncheckedCreateWithoutRawMaterialInput[]
    connectOrCreate?: WIPRawMaterialCreateOrConnectWithoutRawMaterialInput | WIPRawMaterialCreateOrConnectWithoutRawMaterialInput[]
    createMany?: WIPRawMaterialCreateManyRawMaterialInputEnvelope
    connect?: WIPRawMaterialWhereUniqueInput | WIPRawMaterialWhereUniqueInput[]
  }

  export type BigIntFieldUpdateOperationsInput = {
    set?: bigint | number
    increment?: bigint | number
    decrement?: bigint | number
    multiply?: bigint | number
    divide?: bigint | number
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type DecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type EnumQualityStatusFieldUpdateOperationsInput = {
    set?: $Enums.QualityStatus
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type VARIANT_RAW_MATERIALS_TRACKERUpdateManyWithoutRawMaterialNestedInput = {
    create?: XOR<VARIANT_RAW_MATERIALS_TRACKERCreateWithoutRawMaterialInput, VARIANT_RAW_MATERIALS_TRACKERUncheckedCreateWithoutRawMaterialInput> | VARIANT_RAW_MATERIALS_TRACKERCreateWithoutRawMaterialInput[] | VARIANT_RAW_MATERIALS_TRACKERUncheckedCreateWithoutRawMaterialInput[]
    connectOrCreate?: VARIANT_RAW_MATERIALS_TRACKERCreateOrConnectWithoutRawMaterialInput | VARIANT_RAW_MATERIALS_TRACKERCreateOrConnectWithoutRawMaterialInput[]
    upsert?: VARIANT_RAW_MATERIALS_TRACKERUpsertWithWhereUniqueWithoutRawMaterialInput | VARIANT_RAW_MATERIALS_TRACKERUpsertWithWhereUniqueWithoutRawMaterialInput[]
    createMany?: VARIANT_RAW_MATERIALS_TRACKERCreateManyRawMaterialInputEnvelope
    set?: VARIANT_RAW_MATERIALS_TRACKERWhereUniqueInput | VARIANT_RAW_MATERIALS_TRACKERWhereUniqueInput[]
    disconnect?: VARIANT_RAW_MATERIALS_TRACKERWhereUniqueInput | VARIANT_RAW_MATERIALS_TRACKERWhereUniqueInput[]
    delete?: VARIANT_RAW_MATERIALS_TRACKERWhereUniqueInput | VARIANT_RAW_MATERIALS_TRACKERWhereUniqueInput[]
    connect?: VARIANT_RAW_MATERIALS_TRACKERWhereUniqueInput | VARIANT_RAW_MATERIALS_TRACKERWhereUniqueInput[]
    update?: VARIANT_RAW_MATERIALS_TRACKERUpdateWithWhereUniqueWithoutRawMaterialInput | VARIANT_RAW_MATERIALS_TRACKERUpdateWithWhereUniqueWithoutRawMaterialInput[]
    updateMany?: VARIANT_RAW_MATERIALS_TRACKERUpdateManyWithWhereWithoutRawMaterialInput | VARIANT_RAW_MATERIALS_TRACKERUpdateManyWithWhereWithoutRawMaterialInput[]
    deleteMany?: VARIANT_RAW_MATERIALS_TRACKERScalarWhereInput | VARIANT_RAW_MATERIALS_TRACKERScalarWhereInput[]
  }

  export type RM_TRANSACTIONSUpdateManyWithoutRawMaterialNestedInput = {
    create?: XOR<RM_TRANSACTIONSCreateWithoutRawMaterialInput, RM_TRANSACTIONSUncheckedCreateWithoutRawMaterialInput> | RM_TRANSACTIONSCreateWithoutRawMaterialInput[] | RM_TRANSACTIONSUncheckedCreateWithoutRawMaterialInput[]
    connectOrCreate?: RM_TRANSACTIONSCreateOrConnectWithoutRawMaterialInput | RM_TRANSACTIONSCreateOrConnectWithoutRawMaterialInput[]
    upsert?: RM_TRANSACTIONSUpsertWithWhereUniqueWithoutRawMaterialInput | RM_TRANSACTIONSUpsertWithWhereUniqueWithoutRawMaterialInput[]
    createMany?: RM_TRANSACTIONSCreateManyRawMaterialInputEnvelope
    set?: RM_TRANSACTIONSWhereUniqueInput | RM_TRANSACTIONSWhereUniqueInput[]
    disconnect?: RM_TRANSACTIONSWhereUniqueInput | RM_TRANSACTIONSWhereUniqueInput[]
    delete?: RM_TRANSACTIONSWhereUniqueInput | RM_TRANSACTIONSWhereUniqueInput[]
    connect?: RM_TRANSACTIONSWhereUniqueInput | RM_TRANSACTIONSWhereUniqueInput[]
    update?: RM_TRANSACTIONSUpdateWithWhereUniqueWithoutRawMaterialInput | RM_TRANSACTIONSUpdateWithWhereUniqueWithoutRawMaterialInput[]
    updateMany?: RM_TRANSACTIONSUpdateManyWithWhereWithoutRawMaterialInput | RM_TRANSACTIONSUpdateManyWithWhereWithoutRawMaterialInput[]
    deleteMany?: RM_TRANSACTIONSScalarWhereInput | RM_TRANSACTIONSScalarWhereInput[]
  }

  export type RM_QCUpdateManyWithoutRawMaterialNestedInput = {
    create?: XOR<RM_QCCreateWithoutRawMaterialInput, RM_QCUncheckedCreateWithoutRawMaterialInput> | RM_QCCreateWithoutRawMaterialInput[] | RM_QCUncheckedCreateWithoutRawMaterialInput[]
    connectOrCreate?: RM_QCCreateOrConnectWithoutRawMaterialInput | RM_QCCreateOrConnectWithoutRawMaterialInput[]
    upsert?: RM_QCUpsertWithWhereUniqueWithoutRawMaterialInput | RM_QCUpsertWithWhereUniqueWithoutRawMaterialInput[]
    createMany?: RM_QCCreateManyRawMaterialInputEnvelope
    set?: RM_QCWhereUniqueInput | RM_QCWhereUniqueInput[]
    disconnect?: RM_QCWhereUniqueInput | RM_QCWhereUniqueInput[]
    delete?: RM_QCWhereUniqueInput | RM_QCWhereUniqueInput[]
    connect?: RM_QCWhereUniqueInput | RM_QCWhereUniqueInput[]
    update?: RM_QCUpdateWithWhereUniqueWithoutRawMaterialInput | RM_QCUpdateWithWhereUniqueWithoutRawMaterialInput[]
    updateMany?: RM_QCUpdateManyWithWhereWithoutRawMaterialInput | RM_QCUpdateManyWithWhereWithoutRawMaterialInput[]
    deleteMany?: RM_QCScalarWhereInput | RM_QCScalarWhereInput[]
  }

  export type RM_WASTAGE_LOGSUpdateManyWithoutRawMaterialNestedInput = {
    create?: XOR<RM_WASTAGE_LOGSCreateWithoutRawMaterialInput, RM_WASTAGE_LOGSUncheckedCreateWithoutRawMaterialInput> | RM_WASTAGE_LOGSCreateWithoutRawMaterialInput[] | RM_WASTAGE_LOGSUncheckedCreateWithoutRawMaterialInput[]
    connectOrCreate?: RM_WASTAGE_LOGSCreateOrConnectWithoutRawMaterialInput | RM_WASTAGE_LOGSCreateOrConnectWithoutRawMaterialInput[]
    upsert?: RM_WASTAGE_LOGSUpsertWithWhereUniqueWithoutRawMaterialInput | RM_WASTAGE_LOGSUpsertWithWhereUniqueWithoutRawMaterialInput[]
    createMany?: RM_WASTAGE_LOGSCreateManyRawMaterialInputEnvelope
    set?: RM_WASTAGE_LOGSWhereUniqueInput | RM_WASTAGE_LOGSWhereUniqueInput[]
    disconnect?: RM_WASTAGE_LOGSWhereUniqueInput | RM_WASTAGE_LOGSWhereUniqueInput[]
    delete?: RM_WASTAGE_LOGSWhereUniqueInput | RM_WASTAGE_LOGSWhereUniqueInput[]
    connect?: RM_WASTAGE_LOGSWhereUniqueInput | RM_WASTAGE_LOGSWhereUniqueInput[]
    update?: RM_WASTAGE_LOGSUpdateWithWhereUniqueWithoutRawMaterialInput | RM_WASTAGE_LOGSUpdateWithWhereUniqueWithoutRawMaterialInput[]
    updateMany?: RM_WASTAGE_LOGSUpdateManyWithWhereWithoutRawMaterialInput | RM_WASTAGE_LOGSUpdateManyWithWhereWithoutRawMaterialInput[]
    deleteMany?: RM_WASTAGE_LOGSScalarWhereInput | RM_WASTAGE_LOGSScalarWhereInput[]
  }

  export type WIPRawMaterialUpdateManyWithoutRawMaterialNestedInput = {
    create?: XOR<WIPRawMaterialCreateWithoutRawMaterialInput, WIPRawMaterialUncheckedCreateWithoutRawMaterialInput> | WIPRawMaterialCreateWithoutRawMaterialInput[] | WIPRawMaterialUncheckedCreateWithoutRawMaterialInput[]
    connectOrCreate?: WIPRawMaterialCreateOrConnectWithoutRawMaterialInput | WIPRawMaterialCreateOrConnectWithoutRawMaterialInput[]
    upsert?: WIPRawMaterialUpsertWithWhereUniqueWithoutRawMaterialInput | WIPRawMaterialUpsertWithWhereUniqueWithoutRawMaterialInput[]
    createMany?: WIPRawMaterialCreateManyRawMaterialInputEnvelope
    set?: WIPRawMaterialWhereUniqueInput | WIPRawMaterialWhereUniqueInput[]
    disconnect?: WIPRawMaterialWhereUniqueInput | WIPRawMaterialWhereUniqueInput[]
    delete?: WIPRawMaterialWhereUniqueInput | WIPRawMaterialWhereUniqueInput[]
    connect?: WIPRawMaterialWhereUniqueInput | WIPRawMaterialWhereUniqueInput[]
    update?: WIPRawMaterialUpdateWithWhereUniqueWithoutRawMaterialInput | WIPRawMaterialUpdateWithWhereUniqueWithoutRawMaterialInput[]
    updateMany?: WIPRawMaterialUpdateManyWithWhereWithoutRawMaterialInput | WIPRawMaterialUpdateManyWithWhereWithoutRawMaterialInput[]
    deleteMany?: WIPRawMaterialScalarWhereInput | WIPRawMaterialScalarWhereInput[]
  }

  export type VARIANT_RAW_MATERIALS_TRACKERUncheckedUpdateManyWithoutRawMaterialNestedInput = {
    create?: XOR<VARIANT_RAW_MATERIALS_TRACKERCreateWithoutRawMaterialInput, VARIANT_RAW_MATERIALS_TRACKERUncheckedCreateWithoutRawMaterialInput> | VARIANT_RAW_MATERIALS_TRACKERCreateWithoutRawMaterialInput[] | VARIANT_RAW_MATERIALS_TRACKERUncheckedCreateWithoutRawMaterialInput[]
    connectOrCreate?: VARIANT_RAW_MATERIALS_TRACKERCreateOrConnectWithoutRawMaterialInput | VARIANT_RAW_MATERIALS_TRACKERCreateOrConnectWithoutRawMaterialInput[]
    upsert?: VARIANT_RAW_MATERIALS_TRACKERUpsertWithWhereUniqueWithoutRawMaterialInput | VARIANT_RAW_MATERIALS_TRACKERUpsertWithWhereUniqueWithoutRawMaterialInput[]
    createMany?: VARIANT_RAW_MATERIALS_TRACKERCreateManyRawMaterialInputEnvelope
    set?: VARIANT_RAW_MATERIALS_TRACKERWhereUniqueInput | VARIANT_RAW_MATERIALS_TRACKERWhereUniqueInput[]
    disconnect?: VARIANT_RAW_MATERIALS_TRACKERWhereUniqueInput | VARIANT_RAW_MATERIALS_TRACKERWhereUniqueInput[]
    delete?: VARIANT_RAW_MATERIALS_TRACKERWhereUniqueInput | VARIANT_RAW_MATERIALS_TRACKERWhereUniqueInput[]
    connect?: VARIANT_RAW_MATERIALS_TRACKERWhereUniqueInput | VARIANT_RAW_MATERIALS_TRACKERWhereUniqueInput[]
    update?: VARIANT_RAW_MATERIALS_TRACKERUpdateWithWhereUniqueWithoutRawMaterialInput | VARIANT_RAW_MATERIALS_TRACKERUpdateWithWhereUniqueWithoutRawMaterialInput[]
    updateMany?: VARIANT_RAW_MATERIALS_TRACKERUpdateManyWithWhereWithoutRawMaterialInput | VARIANT_RAW_MATERIALS_TRACKERUpdateManyWithWhereWithoutRawMaterialInput[]
    deleteMany?: VARIANT_RAW_MATERIALS_TRACKERScalarWhereInput | VARIANT_RAW_MATERIALS_TRACKERScalarWhereInput[]
  }

  export type RM_TRANSACTIONSUncheckedUpdateManyWithoutRawMaterialNestedInput = {
    create?: XOR<RM_TRANSACTIONSCreateWithoutRawMaterialInput, RM_TRANSACTIONSUncheckedCreateWithoutRawMaterialInput> | RM_TRANSACTIONSCreateWithoutRawMaterialInput[] | RM_TRANSACTIONSUncheckedCreateWithoutRawMaterialInput[]
    connectOrCreate?: RM_TRANSACTIONSCreateOrConnectWithoutRawMaterialInput | RM_TRANSACTIONSCreateOrConnectWithoutRawMaterialInput[]
    upsert?: RM_TRANSACTIONSUpsertWithWhereUniqueWithoutRawMaterialInput | RM_TRANSACTIONSUpsertWithWhereUniqueWithoutRawMaterialInput[]
    createMany?: RM_TRANSACTIONSCreateManyRawMaterialInputEnvelope
    set?: RM_TRANSACTIONSWhereUniqueInput | RM_TRANSACTIONSWhereUniqueInput[]
    disconnect?: RM_TRANSACTIONSWhereUniqueInput | RM_TRANSACTIONSWhereUniqueInput[]
    delete?: RM_TRANSACTIONSWhereUniqueInput | RM_TRANSACTIONSWhereUniqueInput[]
    connect?: RM_TRANSACTIONSWhereUniqueInput | RM_TRANSACTIONSWhereUniqueInput[]
    update?: RM_TRANSACTIONSUpdateWithWhereUniqueWithoutRawMaterialInput | RM_TRANSACTIONSUpdateWithWhereUniqueWithoutRawMaterialInput[]
    updateMany?: RM_TRANSACTIONSUpdateManyWithWhereWithoutRawMaterialInput | RM_TRANSACTIONSUpdateManyWithWhereWithoutRawMaterialInput[]
    deleteMany?: RM_TRANSACTIONSScalarWhereInput | RM_TRANSACTIONSScalarWhereInput[]
  }

  export type RM_QCUncheckedUpdateManyWithoutRawMaterialNestedInput = {
    create?: XOR<RM_QCCreateWithoutRawMaterialInput, RM_QCUncheckedCreateWithoutRawMaterialInput> | RM_QCCreateWithoutRawMaterialInput[] | RM_QCUncheckedCreateWithoutRawMaterialInput[]
    connectOrCreate?: RM_QCCreateOrConnectWithoutRawMaterialInput | RM_QCCreateOrConnectWithoutRawMaterialInput[]
    upsert?: RM_QCUpsertWithWhereUniqueWithoutRawMaterialInput | RM_QCUpsertWithWhereUniqueWithoutRawMaterialInput[]
    createMany?: RM_QCCreateManyRawMaterialInputEnvelope
    set?: RM_QCWhereUniqueInput | RM_QCWhereUniqueInput[]
    disconnect?: RM_QCWhereUniqueInput | RM_QCWhereUniqueInput[]
    delete?: RM_QCWhereUniqueInput | RM_QCWhereUniqueInput[]
    connect?: RM_QCWhereUniqueInput | RM_QCWhereUniqueInput[]
    update?: RM_QCUpdateWithWhereUniqueWithoutRawMaterialInput | RM_QCUpdateWithWhereUniqueWithoutRawMaterialInput[]
    updateMany?: RM_QCUpdateManyWithWhereWithoutRawMaterialInput | RM_QCUpdateManyWithWhereWithoutRawMaterialInput[]
    deleteMany?: RM_QCScalarWhereInput | RM_QCScalarWhereInput[]
  }

  export type RM_WASTAGE_LOGSUncheckedUpdateManyWithoutRawMaterialNestedInput = {
    create?: XOR<RM_WASTAGE_LOGSCreateWithoutRawMaterialInput, RM_WASTAGE_LOGSUncheckedCreateWithoutRawMaterialInput> | RM_WASTAGE_LOGSCreateWithoutRawMaterialInput[] | RM_WASTAGE_LOGSUncheckedCreateWithoutRawMaterialInput[]
    connectOrCreate?: RM_WASTAGE_LOGSCreateOrConnectWithoutRawMaterialInput | RM_WASTAGE_LOGSCreateOrConnectWithoutRawMaterialInput[]
    upsert?: RM_WASTAGE_LOGSUpsertWithWhereUniqueWithoutRawMaterialInput | RM_WASTAGE_LOGSUpsertWithWhereUniqueWithoutRawMaterialInput[]
    createMany?: RM_WASTAGE_LOGSCreateManyRawMaterialInputEnvelope
    set?: RM_WASTAGE_LOGSWhereUniqueInput | RM_WASTAGE_LOGSWhereUniqueInput[]
    disconnect?: RM_WASTAGE_LOGSWhereUniqueInput | RM_WASTAGE_LOGSWhereUniqueInput[]
    delete?: RM_WASTAGE_LOGSWhereUniqueInput | RM_WASTAGE_LOGSWhereUniqueInput[]
    connect?: RM_WASTAGE_LOGSWhereUniqueInput | RM_WASTAGE_LOGSWhereUniqueInput[]
    update?: RM_WASTAGE_LOGSUpdateWithWhereUniqueWithoutRawMaterialInput | RM_WASTAGE_LOGSUpdateWithWhereUniqueWithoutRawMaterialInput[]
    updateMany?: RM_WASTAGE_LOGSUpdateManyWithWhereWithoutRawMaterialInput | RM_WASTAGE_LOGSUpdateManyWithWhereWithoutRawMaterialInput[]
    deleteMany?: RM_WASTAGE_LOGSScalarWhereInput | RM_WASTAGE_LOGSScalarWhereInput[]
  }

  export type WIPRawMaterialUncheckedUpdateManyWithoutRawMaterialNestedInput = {
    create?: XOR<WIPRawMaterialCreateWithoutRawMaterialInput, WIPRawMaterialUncheckedCreateWithoutRawMaterialInput> | WIPRawMaterialCreateWithoutRawMaterialInput[] | WIPRawMaterialUncheckedCreateWithoutRawMaterialInput[]
    connectOrCreate?: WIPRawMaterialCreateOrConnectWithoutRawMaterialInput | WIPRawMaterialCreateOrConnectWithoutRawMaterialInput[]
    upsert?: WIPRawMaterialUpsertWithWhereUniqueWithoutRawMaterialInput | WIPRawMaterialUpsertWithWhereUniqueWithoutRawMaterialInput[]
    createMany?: WIPRawMaterialCreateManyRawMaterialInputEnvelope
    set?: WIPRawMaterialWhereUniqueInput | WIPRawMaterialWhereUniqueInput[]
    disconnect?: WIPRawMaterialWhereUniqueInput | WIPRawMaterialWhereUniqueInput[]
    delete?: WIPRawMaterialWhereUniqueInput | WIPRawMaterialWhereUniqueInput[]
    connect?: WIPRawMaterialWhereUniqueInput | WIPRawMaterialWhereUniqueInput[]
    update?: WIPRawMaterialUpdateWithWhereUniqueWithoutRawMaterialInput | WIPRawMaterialUpdateWithWhereUniqueWithoutRawMaterialInput[]
    updateMany?: WIPRawMaterialUpdateManyWithWhereWithoutRawMaterialInput | WIPRawMaterialUpdateManyWithWhereWithoutRawMaterialInput[]
    deleteMany?: WIPRawMaterialScalarWhereInput | WIPRawMaterialScalarWhereInput[]
  }

  export type SHOPIFY_PRODUCTSCreateNestedOneWithoutShopifyVariantsInput = {
    create?: XOR<SHOPIFY_PRODUCTSCreateWithoutShopifyVariantsInput, SHOPIFY_PRODUCTSUncheckedCreateWithoutShopifyVariantsInput>
    connectOrCreate?: SHOPIFY_PRODUCTSCreateOrConnectWithoutShopifyVariantsInput
    connect?: SHOPIFY_PRODUCTSWhereUniqueInput
  }

  export type VARIANT_RAW_MATERIALS_TRACKERCreateNestedManyWithoutVariantInput = {
    create?: XOR<VARIANT_RAW_MATERIALS_TRACKERCreateWithoutVariantInput, VARIANT_RAW_MATERIALS_TRACKERUncheckedCreateWithoutVariantInput> | VARIANT_RAW_MATERIALS_TRACKERCreateWithoutVariantInput[] | VARIANT_RAW_MATERIALS_TRACKERUncheckedCreateWithoutVariantInput[]
    connectOrCreate?: VARIANT_RAW_MATERIALS_TRACKERCreateOrConnectWithoutVariantInput | VARIANT_RAW_MATERIALS_TRACKERCreateOrConnectWithoutVariantInput[]
    createMany?: VARIANT_RAW_MATERIALS_TRACKERCreateManyVariantInputEnvelope
    connect?: VARIANT_RAW_MATERIALS_TRACKERWhereUniqueInput | VARIANT_RAW_MATERIALS_TRACKERWhereUniqueInput[]
  }

  export type VARIANT_RAW_MATERIALS_TRACKERUncheckedCreateNestedManyWithoutVariantInput = {
    create?: XOR<VARIANT_RAW_MATERIALS_TRACKERCreateWithoutVariantInput, VARIANT_RAW_MATERIALS_TRACKERUncheckedCreateWithoutVariantInput> | VARIANT_RAW_MATERIALS_TRACKERCreateWithoutVariantInput[] | VARIANT_RAW_MATERIALS_TRACKERUncheckedCreateWithoutVariantInput[]
    connectOrCreate?: VARIANT_RAW_MATERIALS_TRACKERCreateOrConnectWithoutVariantInput | VARIANT_RAW_MATERIALS_TRACKERCreateOrConnectWithoutVariantInput[]
    createMany?: VARIANT_RAW_MATERIALS_TRACKERCreateManyVariantInputEnvelope
    connect?: VARIANT_RAW_MATERIALS_TRACKERWhereUniqueInput | VARIANT_RAW_MATERIALS_TRACKERWhereUniqueInput[]
  }

  export type SHOPIFY_PRODUCTSUpdateOneRequiredWithoutShopifyVariantsNestedInput = {
    create?: XOR<SHOPIFY_PRODUCTSCreateWithoutShopifyVariantsInput, SHOPIFY_PRODUCTSUncheckedCreateWithoutShopifyVariantsInput>
    connectOrCreate?: SHOPIFY_PRODUCTSCreateOrConnectWithoutShopifyVariantsInput
    upsert?: SHOPIFY_PRODUCTSUpsertWithoutShopifyVariantsInput
    connect?: SHOPIFY_PRODUCTSWhereUniqueInput
    update?: XOR<XOR<SHOPIFY_PRODUCTSUpdateToOneWithWhereWithoutShopifyVariantsInput, SHOPIFY_PRODUCTSUpdateWithoutShopifyVariantsInput>, SHOPIFY_PRODUCTSUncheckedUpdateWithoutShopifyVariantsInput>
  }

  export type VARIANT_RAW_MATERIALS_TRACKERUpdateManyWithoutVariantNestedInput = {
    create?: XOR<VARIANT_RAW_MATERIALS_TRACKERCreateWithoutVariantInput, VARIANT_RAW_MATERIALS_TRACKERUncheckedCreateWithoutVariantInput> | VARIANT_RAW_MATERIALS_TRACKERCreateWithoutVariantInput[] | VARIANT_RAW_MATERIALS_TRACKERUncheckedCreateWithoutVariantInput[]
    connectOrCreate?: VARIANT_RAW_MATERIALS_TRACKERCreateOrConnectWithoutVariantInput | VARIANT_RAW_MATERIALS_TRACKERCreateOrConnectWithoutVariantInput[]
    upsert?: VARIANT_RAW_MATERIALS_TRACKERUpsertWithWhereUniqueWithoutVariantInput | VARIANT_RAW_MATERIALS_TRACKERUpsertWithWhereUniqueWithoutVariantInput[]
    createMany?: VARIANT_RAW_MATERIALS_TRACKERCreateManyVariantInputEnvelope
    set?: VARIANT_RAW_MATERIALS_TRACKERWhereUniqueInput | VARIANT_RAW_MATERIALS_TRACKERWhereUniqueInput[]
    disconnect?: VARIANT_RAW_MATERIALS_TRACKERWhereUniqueInput | VARIANT_RAW_MATERIALS_TRACKERWhereUniqueInput[]
    delete?: VARIANT_RAW_MATERIALS_TRACKERWhereUniqueInput | VARIANT_RAW_MATERIALS_TRACKERWhereUniqueInput[]
    connect?: VARIANT_RAW_MATERIALS_TRACKERWhereUniqueInput | VARIANT_RAW_MATERIALS_TRACKERWhereUniqueInput[]
    update?: VARIANT_RAW_MATERIALS_TRACKERUpdateWithWhereUniqueWithoutVariantInput | VARIANT_RAW_MATERIALS_TRACKERUpdateWithWhereUniqueWithoutVariantInput[]
    updateMany?: VARIANT_RAW_MATERIALS_TRACKERUpdateManyWithWhereWithoutVariantInput | VARIANT_RAW_MATERIALS_TRACKERUpdateManyWithWhereWithoutVariantInput[]
    deleteMany?: VARIANT_RAW_MATERIALS_TRACKERScalarWhereInput | VARIANT_RAW_MATERIALS_TRACKERScalarWhereInput[]
  }

  export type VARIANT_RAW_MATERIALS_TRACKERUncheckedUpdateManyWithoutVariantNestedInput = {
    create?: XOR<VARIANT_RAW_MATERIALS_TRACKERCreateWithoutVariantInput, VARIANT_RAW_MATERIALS_TRACKERUncheckedCreateWithoutVariantInput> | VARIANT_RAW_MATERIALS_TRACKERCreateWithoutVariantInput[] | VARIANT_RAW_MATERIALS_TRACKERUncheckedCreateWithoutVariantInput[]
    connectOrCreate?: VARIANT_RAW_MATERIALS_TRACKERCreateOrConnectWithoutVariantInput | VARIANT_RAW_MATERIALS_TRACKERCreateOrConnectWithoutVariantInput[]
    upsert?: VARIANT_RAW_MATERIALS_TRACKERUpsertWithWhereUniqueWithoutVariantInput | VARIANT_RAW_MATERIALS_TRACKERUpsertWithWhereUniqueWithoutVariantInput[]
    createMany?: VARIANT_RAW_MATERIALS_TRACKERCreateManyVariantInputEnvelope
    set?: VARIANT_RAW_MATERIALS_TRACKERWhereUniqueInput | VARIANT_RAW_MATERIALS_TRACKERWhereUniqueInput[]
    disconnect?: VARIANT_RAW_MATERIALS_TRACKERWhereUniqueInput | VARIANT_RAW_MATERIALS_TRACKERWhereUniqueInput[]
    delete?: VARIANT_RAW_MATERIALS_TRACKERWhereUniqueInput | VARIANT_RAW_MATERIALS_TRACKERWhereUniqueInput[]
    connect?: VARIANT_RAW_MATERIALS_TRACKERWhereUniqueInput | VARIANT_RAW_MATERIALS_TRACKERWhereUniqueInput[]
    update?: VARIANT_RAW_MATERIALS_TRACKERUpdateWithWhereUniqueWithoutVariantInput | VARIANT_RAW_MATERIALS_TRACKERUpdateWithWhereUniqueWithoutVariantInput[]
    updateMany?: VARIANT_RAW_MATERIALS_TRACKERUpdateManyWithWhereWithoutVariantInput | VARIANT_RAW_MATERIALS_TRACKERUpdateManyWithWhereWithoutVariantInput[]
    deleteMany?: VARIANT_RAW_MATERIALS_TRACKERScalarWhereInput | VARIANT_RAW_MATERIALS_TRACKERScalarWhereInput[]
  }

  export type SHOPIFY_VARIANTSCreateNestedOneWithoutVariantMaterialsInput = {
    create?: XOR<SHOPIFY_VARIANTSCreateWithoutVariantMaterialsInput, SHOPIFY_VARIANTSUncheckedCreateWithoutVariantMaterialsInput>
    connectOrCreate?: SHOPIFY_VARIANTSCreateOrConnectWithoutVariantMaterialsInput
    connect?: SHOPIFY_VARIANTSWhereUniqueInput
  }

  export type RAW_MATERIALSCreateNestedOneWithoutVariantMaterialsInput = {
    create?: XOR<RAW_MATERIALSCreateWithoutVariantMaterialsInput, RAW_MATERIALSUncheckedCreateWithoutVariantMaterialsInput>
    connectOrCreate?: RAW_MATERIALSCreateOrConnectWithoutVariantMaterialsInput
    connect?: RAW_MATERIALSWhereUniqueInput
  }

  export type SHOPIFY_VARIANTSUpdateOneRequiredWithoutVariantMaterialsNestedInput = {
    create?: XOR<SHOPIFY_VARIANTSCreateWithoutVariantMaterialsInput, SHOPIFY_VARIANTSUncheckedCreateWithoutVariantMaterialsInput>
    connectOrCreate?: SHOPIFY_VARIANTSCreateOrConnectWithoutVariantMaterialsInput
    upsert?: SHOPIFY_VARIANTSUpsertWithoutVariantMaterialsInput
    connect?: SHOPIFY_VARIANTSWhereUniqueInput
    update?: XOR<XOR<SHOPIFY_VARIANTSUpdateToOneWithWhereWithoutVariantMaterialsInput, SHOPIFY_VARIANTSUpdateWithoutVariantMaterialsInput>, SHOPIFY_VARIANTSUncheckedUpdateWithoutVariantMaterialsInput>
  }

  export type RAW_MATERIALSUpdateOneRequiredWithoutVariantMaterialsNestedInput = {
    create?: XOR<RAW_MATERIALSCreateWithoutVariantMaterialsInput, RAW_MATERIALSUncheckedCreateWithoutVariantMaterialsInput>
    connectOrCreate?: RAW_MATERIALSCreateOrConnectWithoutVariantMaterialsInput
    upsert?: RAW_MATERIALSUpsertWithoutVariantMaterialsInput
    connect?: RAW_MATERIALSWhereUniqueInput
    update?: XOR<XOR<RAW_MATERIALSUpdateToOneWithWhereWithoutVariantMaterialsInput, RAW_MATERIALSUpdateWithoutVariantMaterialsInput>, RAW_MATERIALSUncheckedUpdateWithoutVariantMaterialsInput>
  }

  export type SHOPIFY_PRODUCTSCreateNestedManyWithoutCategoryInput = {
    create?: XOR<SHOPIFY_PRODUCTSCreateWithoutCategoryInput, SHOPIFY_PRODUCTSUncheckedCreateWithoutCategoryInput> | SHOPIFY_PRODUCTSCreateWithoutCategoryInput[] | SHOPIFY_PRODUCTSUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: SHOPIFY_PRODUCTSCreateOrConnectWithoutCategoryInput | SHOPIFY_PRODUCTSCreateOrConnectWithoutCategoryInput[]
    createMany?: SHOPIFY_PRODUCTSCreateManyCategoryInputEnvelope
    connect?: SHOPIFY_PRODUCTSWhereUniqueInput | SHOPIFY_PRODUCTSWhereUniqueInput[]
  }

  export type SHOPIFY_PRODUCTSUncheckedCreateNestedManyWithoutCategoryInput = {
    create?: XOR<SHOPIFY_PRODUCTSCreateWithoutCategoryInput, SHOPIFY_PRODUCTSUncheckedCreateWithoutCategoryInput> | SHOPIFY_PRODUCTSCreateWithoutCategoryInput[] | SHOPIFY_PRODUCTSUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: SHOPIFY_PRODUCTSCreateOrConnectWithoutCategoryInput | SHOPIFY_PRODUCTSCreateOrConnectWithoutCategoryInput[]
    createMany?: SHOPIFY_PRODUCTSCreateManyCategoryInputEnvelope
    connect?: SHOPIFY_PRODUCTSWhereUniqueInput | SHOPIFY_PRODUCTSWhereUniqueInput[]
  }

  export type SHOPIFY_PRODUCTSUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<SHOPIFY_PRODUCTSCreateWithoutCategoryInput, SHOPIFY_PRODUCTSUncheckedCreateWithoutCategoryInput> | SHOPIFY_PRODUCTSCreateWithoutCategoryInput[] | SHOPIFY_PRODUCTSUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: SHOPIFY_PRODUCTSCreateOrConnectWithoutCategoryInput | SHOPIFY_PRODUCTSCreateOrConnectWithoutCategoryInput[]
    upsert?: SHOPIFY_PRODUCTSUpsertWithWhereUniqueWithoutCategoryInput | SHOPIFY_PRODUCTSUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: SHOPIFY_PRODUCTSCreateManyCategoryInputEnvelope
    set?: SHOPIFY_PRODUCTSWhereUniqueInput | SHOPIFY_PRODUCTSWhereUniqueInput[]
    disconnect?: SHOPIFY_PRODUCTSWhereUniqueInput | SHOPIFY_PRODUCTSWhereUniqueInput[]
    delete?: SHOPIFY_PRODUCTSWhereUniqueInput | SHOPIFY_PRODUCTSWhereUniqueInput[]
    connect?: SHOPIFY_PRODUCTSWhereUniqueInput | SHOPIFY_PRODUCTSWhereUniqueInput[]
    update?: SHOPIFY_PRODUCTSUpdateWithWhereUniqueWithoutCategoryInput | SHOPIFY_PRODUCTSUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: SHOPIFY_PRODUCTSUpdateManyWithWhereWithoutCategoryInput | SHOPIFY_PRODUCTSUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: SHOPIFY_PRODUCTSScalarWhereInput | SHOPIFY_PRODUCTSScalarWhereInput[]
  }

  export type SHOPIFY_PRODUCTSUncheckedUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<SHOPIFY_PRODUCTSCreateWithoutCategoryInput, SHOPIFY_PRODUCTSUncheckedCreateWithoutCategoryInput> | SHOPIFY_PRODUCTSCreateWithoutCategoryInput[] | SHOPIFY_PRODUCTSUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: SHOPIFY_PRODUCTSCreateOrConnectWithoutCategoryInput | SHOPIFY_PRODUCTSCreateOrConnectWithoutCategoryInput[]
    upsert?: SHOPIFY_PRODUCTSUpsertWithWhereUniqueWithoutCategoryInput | SHOPIFY_PRODUCTSUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: SHOPIFY_PRODUCTSCreateManyCategoryInputEnvelope
    set?: SHOPIFY_PRODUCTSWhereUniqueInput | SHOPIFY_PRODUCTSWhereUniqueInput[]
    disconnect?: SHOPIFY_PRODUCTSWhereUniqueInput | SHOPIFY_PRODUCTSWhereUniqueInput[]
    delete?: SHOPIFY_PRODUCTSWhereUniqueInput | SHOPIFY_PRODUCTSWhereUniqueInput[]
    connect?: SHOPIFY_PRODUCTSWhereUniqueInput | SHOPIFY_PRODUCTSWhereUniqueInput[]
    update?: SHOPIFY_PRODUCTSUpdateWithWhereUniqueWithoutCategoryInput | SHOPIFY_PRODUCTSUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: SHOPIFY_PRODUCTSUpdateManyWithWhereWithoutCategoryInput | SHOPIFY_PRODUCTSUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: SHOPIFY_PRODUCTSScalarWhereInput | SHOPIFY_PRODUCTSScalarWhereInput[]
  }

  export type CATEGORIESCreateNestedOneWithoutShopifyProductsInput = {
    create?: XOR<CATEGORIESCreateWithoutShopifyProductsInput, CATEGORIESUncheckedCreateWithoutShopifyProductsInput>
    connectOrCreate?: CATEGORIESCreateOrConnectWithoutShopifyProductsInput
    connect?: CATEGORIESWhereUniqueInput
  }

  export type SHOPIFY_VARIANTSCreateNestedManyWithoutProductInput = {
    create?: XOR<SHOPIFY_VARIANTSCreateWithoutProductInput, SHOPIFY_VARIANTSUncheckedCreateWithoutProductInput> | SHOPIFY_VARIANTSCreateWithoutProductInput[] | SHOPIFY_VARIANTSUncheckedCreateWithoutProductInput[]
    connectOrCreate?: SHOPIFY_VARIANTSCreateOrConnectWithoutProductInput | SHOPIFY_VARIANTSCreateOrConnectWithoutProductInput[]
    createMany?: SHOPIFY_VARIANTSCreateManyProductInputEnvelope
    connect?: SHOPIFY_VARIANTSWhereUniqueInput | SHOPIFY_VARIANTSWhereUniqueInput[]
  }

  export type WIP_PRODUCTSCreateNestedManyWithoutProductInput = {
    create?: XOR<WIP_PRODUCTSCreateWithoutProductInput, WIP_PRODUCTSUncheckedCreateWithoutProductInput> | WIP_PRODUCTSCreateWithoutProductInput[] | WIP_PRODUCTSUncheckedCreateWithoutProductInput[]
    connectOrCreate?: WIP_PRODUCTSCreateOrConnectWithoutProductInput | WIP_PRODUCTSCreateOrConnectWithoutProductInput[]
    createMany?: WIP_PRODUCTSCreateManyProductInputEnvelope
    connect?: WIP_PRODUCTSWhereUniqueInput | WIP_PRODUCTSWhereUniqueInput[]
  }

  export type SHOPIFY_VARIANTSUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<SHOPIFY_VARIANTSCreateWithoutProductInput, SHOPIFY_VARIANTSUncheckedCreateWithoutProductInput> | SHOPIFY_VARIANTSCreateWithoutProductInput[] | SHOPIFY_VARIANTSUncheckedCreateWithoutProductInput[]
    connectOrCreate?: SHOPIFY_VARIANTSCreateOrConnectWithoutProductInput | SHOPIFY_VARIANTSCreateOrConnectWithoutProductInput[]
    createMany?: SHOPIFY_VARIANTSCreateManyProductInputEnvelope
    connect?: SHOPIFY_VARIANTSWhereUniqueInput | SHOPIFY_VARIANTSWhereUniqueInput[]
  }

  export type WIP_PRODUCTSUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<WIP_PRODUCTSCreateWithoutProductInput, WIP_PRODUCTSUncheckedCreateWithoutProductInput> | WIP_PRODUCTSCreateWithoutProductInput[] | WIP_PRODUCTSUncheckedCreateWithoutProductInput[]
    connectOrCreate?: WIP_PRODUCTSCreateOrConnectWithoutProductInput | WIP_PRODUCTSCreateOrConnectWithoutProductInput[]
    createMany?: WIP_PRODUCTSCreateManyProductInputEnvelope
    connect?: WIP_PRODUCTSWhereUniqueInput | WIP_PRODUCTSWhereUniqueInput[]
  }

  export type CATEGORIESUpdateOneRequiredWithoutShopifyProductsNestedInput = {
    create?: XOR<CATEGORIESCreateWithoutShopifyProductsInput, CATEGORIESUncheckedCreateWithoutShopifyProductsInput>
    connectOrCreate?: CATEGORIESCreateOrConnectWithoutShopifyProductsInput
    upsert?: CATEGORIESUpsertWithoutShopifyProductsInput
    connect?: CATEGORIESWhereUniqueInput
    update?: XOR<XOR<CATEGORIESUpdateToOneWithWhereWithoutShopifyProductsInput, CATEGORIESUpdateWithoutShopifyProductsInput>, CATEGORIESUncheckedUpdateWithoutShopifyProductsInput>
  }

  export type SHOPIFY_VARIANTSUpdateManyWithoutProductNestedInput = {
    create?: XOR<SHOPIFY_VARIANTSCreateWithoutProductInput, SHOPIFY_VARIANTSUncheckedCreateWithoutProductInput> | SHOPIFY_VARIANTSCreateWithoutProductInput[] | SHOPIFY_VARIANTSUncheckedCreateWithoutProductInput[]
    connectOrCreate?: SHOPIFY_VARIANTSCreateOrConnectWithoutProductInput | SHOPIFY_VARIANTSCreateOrConnectWithoutProductInput[]
    upsert?: SHOPIFY_VARIANTSUpsertWithWhereUniqueWithoutProductInput | SHOPIFY_VARIANTSUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: SHOPIFY_VARIANTSCreateManyProductInputEnvelope
    set?: SHOPIFY_VARIANTSWhereUniqueInput | SHOPIFY_VARIANTSWhereUniqueInput[]
    disconnect?: SHOPIFY_VARIANTSWhereUniqueInput | SHOPIFY_VARIANTSWhereUniqueInput[]
    delete?: SHOPIFY_VARIANTSWhereUniqueInput | SHOPIFY_VARIANTSWhereUniqueInput[]
    connect?: SHOPIFY_VARIANTSWhereUniqueInput | SHOPIFY_VARIANTSWhereUniqueInput[]
    update?: SHOPIFY_VARIANTSUpdateWithWhereUniqueWithoutProductInput | SHOPIFY_VARIANTSUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: SHOPIFY_VARIANTSUpdateManyWithWhereWithoutProductInput | SHOPIFY_VARIANTSUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: SHOPIFY_VARIANTSScalarWhereInput | SHOPIFY_VARIANTSScalarWhereInput[]
  }

  export type WIP_PRODUCTSUpdateManyWithoutProductNestedInput = {
    create?: XOR<WIP_PRODUCTSCreateWithoutProductInput, WIP_PRODUCTSUncheckedCreateWithoutProductInput> | WIP_PRODUCTSCreateWithoutProductInput[] | WIP_PRODUCTSUncheckedCreateWithoutProductInput[]
    connectOrCreate?: WIP_PRODUCTSCreateOrConnectWithoutProductInput | WIP_PRODUCTSCreateOrConnectWithoutProductInput[]
    upsert?: WIP_PRODUCTSUpsertWithWhereUniqueWithoutProductInput | WIP_PRODUCTSUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: WIP_PRODUCTSCreateManyProductInputEnvelope
    set?: WIP_PRODUCTSWhereUniqueInput | WIP_PRODUCTSWhereUniqueInput[]
    disconnect?: WIP_PRODUCTSWhereUniqueInput | WIP_PRODUCTSWhereUniqueInput[]
    delete?: WIP_PRODUCTSWhereUniqueInput | WIP_PRODUCTSWhereUniqueInput[]
    connect?: WIP_PRODUCTSWhereUniqueInput | WIP_PRODUCTSWhereUniqueInput[]
    update?: WIP_PRODUCTSUpdateWithWhereUniqueWithoutProductInput | WIP_PRODUCTSUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: WIP_PRODUCTSUpdateManyWithWhereWithoutProductInput | WIP_PRODUCTSUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: WIP_PRODUCTSScalarWhereInput | WIP_PRODUCTSScalarWhereInput[]
  }

  export type SHOPIFY_VARIANTSUncheckedUpdateManyWithoutProductNestedInput = {
    create?: XOR<SHOPIFY_VARIANTSCreateWithoutProductInput, SHOPIFY_VARIANTSUncheckedCreateWithoutProductInput> | SHOPIFY_VARIANTSCreateWithoutProductInput[] | SHOPIFY_VARIANTSUncheckedCreateWithoutProductInput[]
    connectOrCreate?: SHOPIFY_VARIANTSCreateOrConnectWithoutProductInput | SHOPIFY_VARIANTSCreateOrConnectWithoutProductInput[]
    upsert?: SHOPIFY_VARIANTSUpsertWithWhereUniqueWithoutProductInput | SHOPIFY_VARIANTSUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: SHOPIFY_VARIANTSCreateManyProductInputEnvelope
    set?: SHOPIFY_VARIANTSWhereUniqueInput | SHOPIFY_VARIANTSWhereUniqueInput[]
    disconnect?: SHOPIFY_VARIANTSWhereUniqueInput | SHOPIFY_VARIANTSWhereUniqueInput[]
    delete?: SHOPIFY_VARIANTSWhereUniqueInput | SHOPIFY_VARIANTSWhereUniqueInput[]
    connect?: SHOPIFY_VARIANTSWhereUniqueInput | SHOPIFY_VARIANTSWhereUniqueInput[]
    update?: SHOPIFY_VARIANTSUpdateWithWhereUniqueWithoutProductInput | SHOPIFY_VARIANTSUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: SHOPIFY_VARIANTSUpdateManyWithWhereWithoutProductInput | SHOPIFY_VARIANTSUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: SHOPIFY_VARIANTSScalarWhereInput | SHOPIFY_VARIANTSScalarWhereInput[]
  }

  export type WIP_PRODUCTSUncheckedUpdateManyWithoutProductNestedInput = {
    create?: XOR<WIP_PRODUCTSCreateWithoutProductInput, WIP_PRODUCTSUncheckedCreateWithoutProductInput> | WIP_PRODUCTSCreateWithoutProductInput[] | WIP_PRODUCTSUncheckedCreateWithoutProductInput[]
    connectOrCreate?: WIP_PRODUCTSCreateOrConnectWithoutProductInput | WIP_PRODUCTSCreateOrConnectWithoutProductInput[]
    upsert?: WIP_PRODUCTSUpsertWithWhereUniqueWithoutProductInput | WIP_PRODUCTSUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: WIP_PRODUCTSCreateManyProductInputEnvelope
    set?: WIP_PRODUCTSWhereUniqueInput | WIP_PRODUCTSWhereUniqueInput[]
    disconnect?: WIP_PRODUCTSWhereUniqueInput | WIP_PRODUCTSWhereUniqueInput[]
    delete?: WIP_PRODUCTSWhereUniqueInput | WIP_PRODUCTSWhereUniqueInput[]
    connect?: WIP_PRODUCTSWhereUniqueInput | WIP_PRODUCTSWhereUniqueInput[]
    update?: WIP_PRODUCTSUpdateWithWhereUniqueWithoutProductInput | WIP_PRODUCTSUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: WIP_PRODUCTSUpdateManyWithWhereWithoutProductInput | WIP_PRODUCTSUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: WIP_PRODUCTSScalarWhereInput | WIP_PRODUCTSScalarWhereInput[]
  }

  export type RAW_MATERIALSCreateNestedOneWithoutRMTransactionsInput = {
    create?: XOR<RAW_MATERIALSCreateWithoutRMTransactionsInput, RAW_MATERIALSUncheckedCreateWithoutRMTransactionsInput>
    connectOrCreate?: RAW_MATERIALSCreateOrConnectWithoutRMTransactionsInput
    connect?: RAW_MATERIALSWhereUniqueInput
  }

  export type EmployeeCreateNestedOneWithoutRMTransactionsInput = {
    create?: XOR<EmployeeCreateWithoutRMTransactionsInput, EmployeeUncheckedCreateWithoutRMTransactionsInput>
    connectOrCreate?: EmployeeCreateOrConnectWithoutRMTransactionsInput
    connect?: EmployeeWhereUniqueInput
  }

  export type RM_QCCreateNestedManyWithoutTransactionInput = {
    create?: XOR<RM_QCCreateWithoutTransactionInput, RM_QCUncheckedCreateWithoutTransactionInput> | RM_QCCreateWithoutTransactionInput[] | RM_QCUncheckedCreateWithoutTransactionInput[]
    connectOrCreate?: RM_QCCreateOrConnectWithoutTransactionInput | RM_QCCreateOrConnectWithoutTransactionInput[]
    createMany?: RM_QCCreateManyTransactionInputEnvelope
    connect?: RM_QCWhereUniqueInput | RM_QCWhereUniqueInput[]
  }

  export type RM_WASTAGE_LOGSCreateNestedManyWithoutTransactionInput = {
    create?: XOR<RM_WASTAGE_LOGSCreateWithoutTransactionInput, RM_WASTAGE_LOGSUncheckedCreateWithoutTransactionInput> | RM_WASTAGE_LOGSCreateWithoutTransactionInput[] | RM_WASTAGE_LOGSUncheckedCreateWithoutTransactionInput[]
    connectOrCreate?: RM_WASTAGE_LOGSCreateOrConnectWithoutTransactionInput | RM_WASTAGE_LOGSCreateOrConnectWithoutTransactionInput[]
    createMany?: RM_WASTAGE_LOGSCreateManyTransactionInputEnvelope
    connect?: RM_WASTAGE_LOGSWhereUniqueInput | RM_WASTAGE_LOGSWhereUniqueInput[]
  }

  export type RM_QCUncheckedCreateNestedManyWithoutTransactionInput = {
    create?: XOR<RM_QCCreateWithoutTransactionInput, RM_QCUncheckedCreateWithoutTransactionInput> | RM_QCCreateWithoutTransactionInput[] | RM_QCUncheckedCreateWithoutTransactionInput[]
    connectOrCreate?: RM_QCCreateOrConnectWithoutTransactionInput | RM_QCCreateOrConnectWithoutTransactionInput[]
    createMany?: RM_QCCreateManyTransactionInputEnvelope
    connect?: RM_QCWhereUniqueInput | RM_QCWhereUniqueInput[]
  }

  export type RM_WASTAGE_LOGSUncheckedCreateNestedManyWithoutTransactionInput = {
    create?: XOR<RM_WASTAGE_LOGSCreateWithoutTransactionInput, RM_WASTAGE_LOGSUncheckedCreateWithoutTransactionInput> | RM_WASTAGE_LOGSCreateWithoutTransactionInput[] | RM_WASTAGE_LOGSUncheckedCreateWithoutTransactionInput[]
    connectOrCreate?: RM_WASTAGE_LOGSCreateOrConnectWithoutTransactionInput | RM_WASTAGE_LOGSCreateOrConnectWithoutTransactionInput[]
    createMany?: RM_WASTAGE_LOGSCreateManyTransactionInputEnvelope
    connect?: RM_WASTAGE_LOGSWhereUniqueInput | RM_WASTAGE_LOGSWhereUniqueInput[]
  }

  export type EnumTransactionTypeFieldUpdateOperationsInput = {
    set?: $Enums.TransactionType
  }

  export type RAW_MATERIALSUpdateOneRequiredWithoutRMTransactionsNestedInput = {
    create?: XOR<RAW_MATERIALSCreateWithoutRMTransactionsInput, RAW_MATERIALSUncheckedCreateWithoutRMTransactionsInput>
    connectOrCreate?: RAW_MATERIALSCreateOrConnectWithoutRMTransactionsInput
    upsert?: RAW_MATERIALSUpsertWithoutRMTransactionsInput
    connect?: RAW_MATERIALSWhereUniqueInput
    update?: XOR<XOR<RAW_MATERIALSUpdateToOneWithWhereWithoutRMTransactionsInput, RAW_MATERIALSUpdateWithoutRMTransactionsInput>, RAW_MATERIALSUncheckedUpdateWithoutRMTransactionsInput>
  }

  export type EmployeeUpdateOneRequiredWithoutRMTransactionsNestedInput = {
    create?: XOR<EmployeeCreateWithoutRMTransactionsInput, EmployeeUncheckedCreateWithoutRMTransactionsInput>
    connectOrCreate?: EmployeeCreateOrConnectWithoutRMTransactionsInput
    upsert?: EmployeeUpsertWithoutRMTransactionsInput
    connect?: EmployeeWhereUniqueInput
    update?: XOR<XOR<EmployeeUpdateToOneWithWhereWithoutRMTransactionsInput, EmployeeUpdateWithoutRMTransactionsInput>, EmployeeUncheckedUpdateWithoutRMTransactionsInput>
  }

  export type RM_QCUpdateManyWithoutTransactionNestedInput = {
    create?: XOR<RM_QCCreateWithoutTransactionInput, RM_QCUncheckedCreateWithoutTransactionInput> | RM_QCCreateWithoutTransactionInput[] | RM_QCUncheckedCreateWithoutTransactionInput[]
    connectOrCreate?: RM_QCCreateOrConnectWithoutTransactionInput | RM_QCCreateOrConnectWithoutTransactionInput[]
    upsert?: RM_QCUpsertWithWhereUniqueWithoutTransactionInput | RM_QCUpsertWithWhereUniqueWithoutTransactionInput[]
    createMany?: RM_QCCreateManyTransactionInputEnvelope
    set?: RM_QCWhereUniqueInput | RM_QCWhereUniqueInput[]
    disconnect?: RM_QCWhereUniqueInput | RM_QCWhereUniqueInput[]
    delete?: RM_QCWhereUniqueInput | RM_QCWhereUniqueInput[]
    connect?: RM_QCWhereUniqueInput | RM_QCWhereUniqueInput[]
    update?: RM_QCUpdateWithWhereUniqueWithoutTransactionInput | RM_QCUpdateWithWhereUniqueWithoutTransactionInput[]
    updateMany?: RM_QCUpdateManyWithWhereWithoutTransactionInput | RM_QCUpdateManyWithWhereWithoutTransactionInput[]
    deleteMany?: RM_QCScalarWhereInput | RM_QCScalarWhereInput[]
  }

  export type RM_WASTAGE_LOGSUpdateManyWithoutTransactionNestedInput = {
    create?: XOR<RM_WASTAGE_LOGSCreateWithoutTransactionInput, RM_WASTAGE_LOGSUncheckedCreateWithoutTransactionInput> | RM_WASTAGE_LOGSCreateWithoutTransactionInput[] | RM_WASTAGE_LOGSUncheckedCreateWithoutTransactionInput[]
    connectOrCreate?: RM_WASTAGE_LOGSCreateOrConnectWithoutTransactionInput | RM_WASTAGE_LOGSCreateOrConnectWithoutTransactionInput[]
    upsert?: RM_WASTAGE_LOGSUpsertWithWhereUniqueWithoutTransactionInput | RM_WASTAGE_LOGSUpsertWithWhereUniqueWithoutTransactionInput[]
    createMany?: RM_WASTAGE_LOGSCreateManyTransactionInputEnvelope
    set?: RM_WASTAGE_LOGSWhereUniqueInput | RM_WASTAGE_LOGSWhereUniqueInput[]
    disconnect?: RM_WASTAGE_LOGSWhereUniqueInput | RM_WASTAGE_LOGSWhereUniqueInput[]
    delete?: RM_WASTAGE_LOGSWhereUniqueInput | RM_WASTAGE_LOGSWhereUniqueInput[]
    connect?: RM_WASTAGE_LOGSWhereUniqueInput | RM_WASTAGE_LOGSWhereUniqueInput[]
    update?: RM_WASTAGE_LOGSUpdateWithWhereUniqueWithoutTransactionInput | RM_WASTAGE_LOGSUpdateWithWhereUniqueWithoutTransactionInput[]
    updateMany?: RM_WASTAGE_LOGSUpdateManyWithWhereWithoutTransactionInput | RM_WASTAGE_LOGSUpdateManyWithWhereWithoutTransactionInput[]
    deleteMany?: RM_WASTAGE_LOGSScalarWhereInput | RM_WASTAGE_LOGSScalarWhereInput[]
  }

  export type RM_QCUncheckedUpdateManyWithoutTransactionNestedInput = {
    create?: XOR<RM_QCCreateWithoutTransactionInput, RM_QCUncheckedCreateWithoutTransactionInput> | RM_QCCreateWithoutTransactionInput[] | RM_QCUncheckedCreateWithoutTransactionInput[]
    connectOrCreate?: RM_QCCreateOrConnectWithoutTransactionInput | RM_QCCreateOrConnectWithoutTransactionInput[]
    upsert?: RM_QCUpsertWithWhereUniqueWithoutTransactionInput | RM_QCUpsertWithWhereUniqueWithoutTransactionInput[]
    createMany?: RM_QCCreateManyTransactionInputEnvelope
    set?: RM_QCWhereUniqueInput | RM_QCWhereUniqueInput[]
    disconnect?: RM_QCWhereUniqueInput | RM_QCWhereUniqueInput[]
    delete?: RM_QCWhereUniqueInput | RM_QCWhereUniqueInput[]
    connect?: RM_QCWhereUniqueInput | RM_QCWhereUniqueInput[]
    update?: RM_QCUpdateWithWhereUniqueWithoutTransactionInput | RM_QCUpdateWithWhereUniqueWithoutTransactionInput[]
    updateMany?: RM_QCUpdateManyWithWhereWithoutTransactionInput | RM_QCUpdateManyWithWhereWithoutTransactionInput[]
    deleteMany?: RM_QCScalarWhereInput | RM_QCScalarWhereInput[]
  }

  export type RM_WASTAGE_LOGSUncheckedUpdateManyWithoutTransactionNestedInput = {
    create?: XOR<RM_WASTAGE_LOGSCreateWithoutTransactionInput, RM_WASTAGE_LOGSUncheckedCreateWithoutTransactionInput> | RM_WASTAGE_LOGSCreateWithoutTransactionInput[] | RM_WASTAGE_LOGSUncheckedCreateWithoutTransactionInput[]
    connectOrCreate?: RM_WASTAGE_LOGSCreateOrConnectWithoutTransactionInput | RM_WASTAGE_LOGSCreateOrConnectWithoutTransactionInput[]
    upsert?: RM_WASTAGE_LOGSUpsertWithWhereUniqueWithoutTransactionInput | RM_WASTAGE_LOGSUpsertWithWhereUniqueWithoutTransactionInput[]
    createMany?: RM_WASTAGE_LOGSCreateManyTransactionInputEnvelope
    set?: RM_WASTAGE_LOGSWhereUniqueInput | RM_WASTAGE_LOGSWhereUniqueInput[]
    disconnect?: RM_WASTAGE_LOGSWhereUniqueInput | RM_WASTAGE_LOGSWhereUniqueInput[]
    delete?: RM_WASTAGE_LOGSWhereUniqueInput | RM_WASTAGE_LOGSWhereUniqueInput[]
    connect?: RM_WASTAGE_LOGSWhereUniqueInput | RM_WASTAGE_LOGSWhereUniqueInput[]
    update?: RM_WASTAGE_LOGSUpdateWithWhereUniqueWithoutTransactionInput | RM_WASTAGE_LOGSUpdateWithWhereUniqueWithoutTransactionInput[]
    updateMany?: RM_WASTAGE_LOGSUpdateManyWithWhereWithoutTransactionInput | RM_WASTAGE_LOGSUpdateManyWithWhereWithoutTransactionInput[]
    deleteMany?: RM_WASTAGE_LOGSScalarWhereInput | RM_WASTAGE_LOGSScalarWhereInput[]
  }

  export type RAW_MATERIALSCreateNestedOneWithoutRMQualityChecksInput = {
    create?: XOR<RAW_MATERIALSCreateWithoutRMQualityChecksInput, RAW_MATERIALSUncheckedCreateWithoutRMQualityChecksInput>
    connectOrCreate?: RAW_MATERIALSCreateOrConnectWithoutRMQualityChecksInput
    connect?: RAW_MATERIALSWhereUniqueInput
  }

  export type RM_TRANSACTIONSCreateNestedOneWithoutRMQualityChecksInput = {
    create?: XOR<RM_TRANSACTIONSCreateWithoutRMQualityChecksInput, RM_TRANSACTIONSUncheckedCreateWithoutRMQualityChecksInput>
    connectOrCreate?: RM_TRANSACTIONSCreateOrConnectWithoutRMQualityChecksInput
    connect?: RM_TRANSACTIONSWhereUniqueInput
  }

  export type EmployeeCreateNestedOneWithoutRM_QCInput = {
    create?: XOR<EmployeeCreateWithoutRM_QCInput, EmployeeUncheckedCreateWithoutRM_QCInput>
    connectOrCreate?: EmployeeCreateOrConnectWithoutRM_QCInput
    connect?: EmployeeWhereUniqueInput
  }

  export type EmployeeCreateNestedOneWithoutRM_QC2Input = {
    create?: XOR<EmployeeCreateWithoutRM_QC2Input, EmployeeUncheckedCreateWithoutRM_QC2Input>
    connectOrCreate?: EmployeeCreateOrConnectWithoutRM_QC2Input
    connect?: EmployeeWhereUniqueInput
  }

  export type RAW_MATERIALSUpdateOneRequiredWithoutRMQualityChecksNestedInput = {
    create?: XOR<RAW_MATERIALSCreateWithoutRMQualityChecksInput, RAW_MATERIALSUncheckedCreateWithoutRMQualityChecksInput>
    connectOrCreate?: RAW_MATERIALSCreateOrConnectWithoutRMQualityChecksInput
    upsert?: RAW_MATERIALSUpsertWithoutRMQualityChecksInput
    connect?: RAW_MATERIALSWhereUniqueInput
    update?: XOR<XOR<RAW_MATERIALSUpdateToOneWithWhereWithoutRMQualityChecksInput, RAW_MATERIALSUpdateWithoutRMQualityChecksInput>, RAW_MATERIALSUncheckedUpdateWithoutRMQualityChecksInput>
  }

  export type RM_TRANSACTIONSUpdateOneRequiredWithoutRMQualityChecksNestedInput = {
    create?: XOR<RM_TRANSACTIONSCreateWithoutRMQualityChecksInput, RM_TRANSACTIONSUncheckedCreateWithoutRMQualityChecksInput>
    connectOrCreate?: RM_TRANSACTIONSCreateOrConnectWithoutRMQualityChecksInput
    upsert?: RM_TRANSACTIONSUpsertWithoutRMQualityChecksInput
    connect?: RM_TRANSACTIONSWhereUniqueInput
    update?: XOR<XOR<RM_TRANSACTIONSUpdateToOneWithWhereWithoutRMQualityChecksInput, RM_TRANSACTIONSUpdateWithoutRMQualityChecksInput>, RM_TRANSACTIONSUncheckedUpdateWithoutRMQualityChecksInput>
  }

  export type EmployeeUpdateOneRequiredWithoutRM_QCNestedInput = {
    create?: XOR<EmployeeCreateWithoutRM_QCInput, EmployeeUncheckedCreateWithoutRM_QCInput>
    connectOrCreate?: EmployeeCreateOrConnectWithoutRM_QCInput
    upsert?: EmployeeUpsertWithoutRM_QCInput
    connect?: EmployeeWhereUniqueInput
    update?: XOR<XOR<EmployeeUpdateToOneWithWhereWithoutRM_QCInput, EmployeeUpdateWithoutRM_QCInput>, EmployeeUncheckedUpdateWithoutRM_QCInput>
  }

  export type EmployeeUpdateOneRequiredWithoutRM_QC2NestedInput = {
    create?: XOR<EmployeeCreateWithoutRM_QC2Input, EmployeeUncheckedCreateWithoutRM_QC2Input>
    connectOrCreate?: EmployeeCreateOrConnectWithoutRM_QC2Input
    upsert?: EmployeeUpsertWithoutRM_QC2Input
    connect?: EmployeeWhereUniqueInput
    update?: XOR<XOR<EmployeeUpdateToOneWithWhereWithoutRM_QC2Input, EmployeeUpdateWithoutRM_QC2Input>, EmployeeUncheckedUpdateWithoutRM_QC2Input>
  }

  export type RAW_MATERIALSCreateNestedOneWithoutRMWastageLogsInput = {
    create?: XOR<RAW_MATERIALSCreateWithoutRMWastageLogsInput, RAW_MATERIALSUncheckedCreateWithoutRMWastageLogsInput>
    connectOrCreate?: RAW_MATERIALSCreateOrConnectWithoutRMWastageLogsInput
    connect?: RAW_MATERIALSWhereUniqueInput
  }

  export type RM_TRANSACTIONSCreateNestedOneWithoutRMWastageLogsInput = {
    create?: XOR<RM_TRANSACTIONSCreateWithoutRMWastageLogsInput, RM_TRANSACTIONSUncheckedCreateWithoutRMWastageLogsInput>
    connectOrCreate?: RM_TRANSACTIONSCreateOrConnectWithoutRMWastageLogsInput
    connect?: RM_TRANSACTIONSWhereUniqueInput
  }

  export type RAW_MATERIALSUpdateOneRequiredWithoutRMWastageLogsNestedInput = {
    create?: XOR<RAW_MATERIALSCreateWithoutRMWastageLogsInput, RAW_MATERIALSUncheckedCreateWithoutRMWastageLogsInput>
    connectOrCreate?: RAW_MATERIALSCreateOrConnectWithoutRMWastageLogsInput
    upsert?: RAW_MATERIALSUpsertWithoutRMWastageLogsInput
    connect?: RAW_MATERIALSWhereUniqueInput
    update?: XOR<XOR<RAW_MATERIALSUpdateToOneWithWhereWithoutRMWastageLogsInput, RAW_MATERIALSUpdateWithoutRMWastageLogsInput>, RAW_MATERIALSUncheckedUpdateWithoutRMWastageLogsInput>
  }

  export type RM_TRANSACTIONSUpdateOneRequiredWithoutRMWastageLogsNestedInput = {
    create?: XOR<RM_TRANSACTIONSCreateWithoutRMWastageLogsInput, RM_TRANSACTIONSUncheckedCreateWithoutRMWastageLogsInput>
    connectOrCreate?: RM_TRANSACTIONSCreateOrConnectWithoutRMWastageLogsInput
    upsert?: RM_TRANSACTIONSUpsertWithoutRMWastageLogsInput
    connect?: RM_TRANSACTIONSWhereUniqueInput
    update?: XOR<XOR<RM_TRANSACTIONSUpdateToOneWithWhereWithoutRMWastageLogsInput, RM_TRANSACTIONSUpdateWithoutRMWastageLogsInput>, RM_TRANSACTIONSUncheckedUpdateWithoutRMWastageLogsInput>
  }

  export type RM_QCCreateNestedManyWithoutCheckedByInput = {
    create?: XOR<RM_QCCreateWithoutCheckedByInput, RM_QCUncheckedCreateWithoutCheckedByInput> | RM_QCCreateWithoutCheckedByInput[] | RM_QCUncheckedCreateWithoutCheckedByInput[]
    connectOrCreate?: RM_QCCreateOrConnectWithoutCheckedByInput | RM_QCCreateOrConnectWithoutCheckedByInput[]
    createMany?: RM_QCCreateManyCheckedByInputEnvelope
    connect?: RM_QCWhereUniqueInput | RM_QCWhereUniqueInput[]
  }

  export type RM_QCCreateNestedManyWithoutDoneByInput = {
    create?: XOR<RM_QCCreateWithoutDoneByInput, RM_QCUncheckedCreateWithoutDoneByInput> | RM_QCCreateWithoutDoneByInput[] | RM_QCUncheckedCreateWithoutDoneByInput[]
    connectOrCreate?: RM_QCCreateOrConnectWithoutDoneByInput | RM_QCCreateOrConnectWithoutDoneByInput[]
    createMany?: RM_QCCreateManyDoneByInputEnvelope
    connect?: RM_QCWhereUniqueInput | RM_QCWhereUniqueInput[]
  }

  export type RM_TRANSACTIONSCreateNestedManyWithoutInitiatedByInput = {
    create?: XOR<RM_TRANSACTIONSCreateWithoutInitiatedByInput, RM_TRANSACTIONSUncheckedCreateWithoutInitiatedByInput> | RM_TRANSACTIONSCreateWithoutInitiatedByInput[] | RM_TRANSACTIONSUncheckedCreateWithoutInitiatedByInput[]
    connectOrCreate?: RM_TRANSACTIONSCreateOrConnectWithoutInitiatedByInput | RM_TRANSACTIONSCreateOrConnectWithoutInitiatedByInput[]
    createMany?: RM_TRANSACTIONSCreateManyInitiatedByInputEnvelope
    connect?: RM_TRANSACTIONSWhereUniqueInput | RM_TRANSACTIONSWhereUniqueInput[]
  }

  export type WIP_TRANSACTIONSCreateNestedManyWithoutInitiatedByInput = {
    create?: XOR<WIP_TRANSACTIONSCreateWithoutInitiatedByInput, WIP_TRANSACTIONSUncheckedCreateWithoutInitiatedByInput> | WIP_TRANSACTIONSCreateWithoutInitiatedByInput[] | WIP_TRANSACTIONSUncheckedCreateWithoutInitiatedByInput[]
    connectOrCreate?: WIP_TRANSACTIONSCreateOrConnectWithoutInitiatedByInput | WIP_TRANSACTIONSCreateOrConnectWithoutInitiatedByInput[]
    createMany?: WIP_TRANSACTIONSCreateManyInitiatedByInputEnvelope
    connect?: WIP_TRANSACTIONSWhereUniqueInput | WIP_TRANSACTIONSWhereUniqueInput[]
  }

  export type FG_TRANSACTIONSCreateNestedManyWithoutInitiatedByInput = {
    create?: XOR<FG_TRANSACTIONSCreateWithoutInitiatedByInput, FG_TRANSACTIONSUncheckedCreateWithoutInitiatedByInput> | FG_TRANSACTIONSCreateWithoutInitiatedByInput[] | FG_TRANSACTIONSUncheckedCreateWithoutInitiatedByInput[]
    connectOrCreate?: FG_TRANSACTIONSCreateOrConnectWithoutInitiatedByInput | FG_TRANSACTIONSCreateOrConnectWithoutInitiatedByInput[]
    createMany?: FG_TRANSACTIONSCreateManyInitiatedByInputEnvelope
    connect?: FG_TRANSACTIONSWhereUniqueInput | FG_TRANSACTIONSWhereUniqueInput[]
  }

  export type AuditLogsCreateNestedManyWithoutChangedByInput = {
    create?: XOR<AuditLogsCreateWithoutChangedByInput, AuditLogsUncheckedCreateWithoutChangedByInput> | AuditLogsCreateWithoutChangedByInput[] | AuditLogsUncheckedCreateWithoutChangedByInput[]
    connectOrCreate?: AuditLogsCreateOrConnectWithoutChangedByInput | AuditLogsCreateOrConnectWithoutChangedByInput[]
    createMany?: AuditLogsCreateManyChangedByInputEnvelope
    connect?: AuditLogsWhereUniqueInput | AuditLogsWhereUniqueInput[]
  }

  export type RM_QCUncheckedCreateNestedManyWithoutCheckedByInput = {
    create?: XOR<RM_QCCreateWithoutCheckedByInput, RM_QCUncheckedCreateWithoutCheckedByInput> | RM_QCCreateWithoutCheckedByInput[] | RM_QCUncheckedCreateWithoutCheckedByInput[]
    connectOrCreate?: RM_QCCreateOrConnectWithoutCheckedByInput | RM_QCCreateOrConnectWithoutCheckedByInput[]
    createMany?: RM_QCCreateManyCheckedByInputEnvelope
    connect?: RM_QCWhereUniqueInput | RM_QCWhereUniqueInput[]
  }

  export type RM_QCUncheckedCreateNestedManyWithoutDoneByInput = {
    create?: XOR<RM_QCCreateWithoutDoneByInput, RM_QCUncheckedCreateWithoutDoneByInput> | RM_QCCreateWithoutDoneByInput[] | RM_QCUncheckedCreateWithoutDoneByInput[]
    connectOrCreate?: RM_QCCreateOrConnectWithoutDoneByInput | RM_QCCreateOrConnectWithoutDoneByInput[]
    createMany?: RM_QCCreateManyDoneByInputEnvelope
    connect?: RM_QCWhereUniqueInput | RM_QCWhereUniqueInput[]
  }

  export type RM_TRANSACTIONSUncheckedCreateNestedManyWithoutInitiatedByInput = {
    create?: XOR<RM_TRANSACTIONSCreateWithoutInitiatedByInput, RM_TRANSACTIONSUncheckedCreateWithoutInitiatedByInput> | RM_TRANSACTIONSCreateWithoutInitiatedByInput[] | RM_TRANSACTIONSUncheckedCreateWithoutInitiatedByInput[]
    connectOrCreate?: RM_TRANSACTIONSCreateOrConnectWithoutInitiatedByInput | RM_TRANSACTIONSCreateOrConnectWithoutInitiatedByInput[]
    createMany?: RM_TRANSACTIONSCreateManyInitiatedByInputEnvelope
    connect?: RM_TRANSACTIONSWhereUniqueInput | RM_TRANSACTIONSWhereUniqueInput[]
  }

  export type WIP_TRANSACTIONSUncheckedCreateNestedManyWithoutInitiatedByInput = {
    create?: XOR<WIP_TRANSACTIONSCreateWithoutInitiatedByInput, WIP_TRANSACTIONSUncheckedCreateWithoutInitiatedByInput> | WIP_TRANSACTIONSCreateWithoutInitiatedByInput[] | WIP_TRANSACTIONSUncheckedCreateWithoutInitiatedByInput[]
    connectOrCreate?: WIP_TRANSACTIONSCreateOrConnectWithoutInitiatedByInput | WIP_TRANSACTIONSCreateOrConnectWithoutInitiatedByInput[]
    createMany?: WIP_TRANSACTIONSCreateManyInitiatedByInputEnvelope
    connect?: WIP_TRANSACTIONSWhereUniqueInput | WIP_TRANSACTIONSWhereUniqueInput[]
  }

  export type FG_TRANSACTIONSUncheckedCreateNestedManyWithoutInitiatedByInput = {
    create?: XOR<FG_TRANSACTIONSCreateWithoutInitiatedByInput, FG_TRANSACTIONSUncheckedCreateWithoutInitiatedByInput> | FG_TRANSACTIONSCreateWithoutInitiatedByInput[] | FG_TRANSACTIONSUncheckedCreateWithoutInitiatedByInput[]
    connectOrCreate?: FG_TRANSACTIONSCreateOrConnectWithoutInitiatedByInput | FG_TRANSACTIONSCreateOrConnectWithoutInitiatedByInput[]
    createMany?: FG_TRANSACTIONSCreateManyInitiatedByInputEnvelope
    connect?: FG_TRANSACTIONSWhereUniqueInput | FG_TRANSACTIONSWhereUniqueInput[]
  }

  export type AuditLogsUncheckedCreateNestedManyWithoutChangedByInput = {
    create?: XOR<AuditLogsCreateWithoutChangedByInput, AuditLogsUncheckedCreateWithoutChangedByInput> | AuditLogsCreateWithoutChangedByInput[] | AuditLogsUncheckedCreateWithoutChangedByInput[]
    connectOrCreate?: AuditLogsCreateOrConnectWithoutChangedByInput | AuditLogsCreateOrConnectWithoutChangedByInput[]
    createMany?: AuditLogsCreateManyChangedByInputEnvelope
    connect?: AuditLogsWhereUniqueInput | AuditLogsWhereUniqueInput[]
  }

  export type EnumRolesFieldUpdateOperationsInput = {
    set?: $Enums.Roles
  }

  export type RM_QCUpdateManyWithoutCheckedByNestedInput = {
    create?: XOR<RM_QCCreateWithoutCheckedByInput, RM_QCUncheckedCreateWithoutCheckedByInput> | RM_QCCreateWithoutCheckedByInput[] | RM_QCUncheckedCreateWithoutCheckedByInput[]
    connectOrCreate?: RM_QCCreateOrConnectWithoutCheckedByInput | RM_QCCreateOrConnectWithoutCheckedByInput[]
    upsert?: RM_QCUpsertWithWhereUniqueWithoutCheckedByInput | RM_QCUpsertWithWhereUniqueWithoutCheckedByInput[]
    createMany?: RM_QCCreateManyCheckedByInputEnvelope
    set?: RM_QCWhereUniqueInput | RM_QCWhereUniqueInput[]
    disconnect?: RM_QCWhereUniqueInput | RM_QCWhereUniqueInput[]
    delete?: RM_QCWhereUniqueInput | RM_QCWhereUniqueInput[]
    connect?: RM_QCWhereUniqueInput | RM_QCWhereUniqueInput[]
    update?: RM_QCUpdateWithWhereUniqueWithoutCheckedByInput | RM_QCUpdateWithWhereUniqueWithoutCheckedByInput[]
    updateMany?: RM_QCUpdateManyWithWhereWithoutCheckedByInput | RM_QCUpdateManyWithWhereWithoutCheckedByInput[]
    deleteMany?: RM_QCScalarWhereInput | RM_QCScalarWhereInput[]
  }

  export type RM_QCUpdateManyWithoutDoneByNestedInput = {
    create?: XOR<RM_QCCreateWithoutDoneByInput, RM_QCUncheckedCreateWithoutDoneByInput> | RM_QCCreateWithoutDoneByInput[] | RM_QCUncheckedCreateWithoutDoneByInput[]
    connectOrCreate?: RM_QCCreateOrConnectWithoutDoneByInput | RM_QCCreateOrConnectWithoutDoneByInput[]
    upsert?: RM_QCUpsertWithWhereUniqueWithoutDoneByInput | RM_QCUpsertWithWhereUniqueWithoutDoneByInput[]
    createMany?: RM_QCCreateManyDoneByInputEnvelope
    set?: RM_QCWhereUniqueInput | RM_QCWhereUniqueInput[]
    disconnect?: RM_QCWhereUniqueInput | RM_QCWhereUniqueInput[]
    delete?: RM_QCWhereUniqueInput | RM_QCWhereUniqueInput[]
    connect?: RM_QCWhereUniqueInput | RM_QCWhereUniqueInput[]
    update?: RM_QCUpdateWithWhereUniqueWithoutDoneByInput | RM_QCUpdateWithWhereUniqueWithoutDoneByInput[]
    updateMany?: RM_QCUpdateManyWithWhereWithoutDoneByInput | RM_QCUpdateManyWithWhereWithoutDoneByInput[]
    deleteMany?: RM_QCScalarWhereInput | RM_QCScalarWhereInput[]
  }

  export type RM_TRANSACTIONSUpdateManyWithoutInitiatedByNestedInput = {
    create?: XOR<RM_TRANSACTIONSCreateWithoutInitiatedByInput, RM_TRANSACTIONSUncheckedCreateWithoutInitiatedByInput> | RM_TRANSACTIONSCreateWithoutInitiatedByInput[] | RM_TRANSACTIONSUncheckedCreateWithoutInitiatedByInput[]
    connectOrCreate?: RM_TRANSACTIONSCreateOrConnectWithoutInitiatedByInput | RM_TRANSACTIONSCreateOrConnectWithoutInitiatedByInput[]
    upsert?: RM_TRANSACTIONSUpsertWithWhereUniqueWithoutInitiatedByInput | RM_TRANSACTIONSUpsertWithWhereUniqueWithoutInitiatedByInput[]
    createMany?: RM_TRANSACTIONSCreateManyInitiatedByInputEnvelope
    set?: RM_TRANSACTIONSWhereUniqueInput | RM_TRANSACTIONSWhereUniqueInput[]
    disconnect?: RM_TRANSACTIONSWhereUniqueInput | RM_TRANSACTIONSWhereUniqueInput[]
    delete?: RM_TRANSACTIONSWhereUniqueInput | RM_TRANSACTIONSWhereUniqueInput[]
    connect?: RM_TRANSACTIONSWhereUniqueInput | RM_TRANSACTIONSWhereUniqueInput[]
    update?: RM_TRANSACTIONSUpdateWithWhereUniqueWithoutInitiatedByInput | RM_TRANSACTIONSUpdateWithWhereUniqueWithoutInitiatedByInput[]
    updateMany?: RM_TRANSACTIONSUpdateManyWithWhereWithoutInitiatedByInput | RM_TRANSACTIONSUpdateManyWithWhereWithoutInitiatedByInput[]
    deleteMany?: RM_TRANSACTIONSScalarWhereInput | RM_TRANSACTIONSScalarWhereInput[]
  }

  export type WIP_TRANSACTIONSUpdateManyWithoutInitiatedByNestedInput = {
    create?: XOR<WIP_TRANSACTIONSCreateWithoutInitiatedByInput, WIP_TRANSACTIONSUncheckedCreateWithoutInitiatedByInput> | WIP_TRANSACTIONSCreateWithoutInitiatedByInput[] | WIP_TRANSACTIONSUncheckedCreateWithoutInitiatedByInput[]
    connectOrCreate?: WIP_TRANSACTIONSCreateOrConnectWithoutInitiatedByInput | WIP_TRANSACTIONSCreateOrConnectWithoutInitiatedByInput[]
    upsert?: WIP_TRANSACTIONSUpsertWithWhereUniqueWithoutInitiatedByInput | WIP_TRANSACTIONSUpsertWithWhereUniqueWithoutInitiatedByInput[]
    createMany?: WIP_TRANSACTIONSCreateManyInitiatedByInputEnvelope
    set?: WIP_TRANSACTIONSWhereUniqueInput | WIP_TRANSACTIONSWhereUniqueInput[]
    disconnect?: WIP_TRANSACTIONSWhereUniqueInput | WIP_TRANSACTIONSWhereUniqueInput[]
    delete?: WIP_TRANSACTIONSWhereUniqueInput | WIP_TRANSACTIONSWhereUniqueInput[]
    connect?: WIP_TRANSACTIONSWhereUniqueInput | WIP_TRANSACTIONSWhereUniqueInput[]
    update?: WIP_TRANSACTIONSUpdateWithWhereUniqueWithoutInitiatedByInput | WIP_TRANSACTIONSUpdateWithWhereUniqueWithoutInitiatedByInput[]
    updateMany?: WIP_TRANSACTIONSUpdateManyWithWhereWithoutInitiatedByInput | WIP_TRANSACTIONSUpdateManyWithWhereWithoutInitiatedByInput[]
    deleteMany?: WIP_TRANSACTIONSScalarWhereInput | WIP_TRANSACTIONSScalarWhereInput[]
  }

  export type FG_TRANSACTIONSUpdateManyWithoutInitiatedByNestedInput = {
    create?: XOR<FG_TRANSACTIONSCreateWithoutInitiatedByInput, FG_TRANSACTIONSUncheckedCreateWithoutInitiatedByInput> | FG_TRANSACTIONSCreateWithoutInitiatedByInput[] | FG_TRANSACTIONSUncheckedCreateWithoutInitiatedByInput[]
    connectOrCreate?: FG_TRANSACTIONSCreateOrConnectWithoutInitiatedByInput | FG_TRANSACTIONSCreateOrConnectWithoutInitiatedByInput[]
    upsert?: FG_TRANSACTIONSUpsertWithWhereUniqueWithoutInitiatedByInput | FG_TRANSACTIONSUpsertWithWhereUniqueWithoutInitiatedByInput[]
    createMany?: FG_TRANSACTIONSCreateManyInitiatedByInputEnvelope
    set?: FG_TRANSACTIONSWhereUniqueInput | FG_TRANSACTIONSWhereUniqueInput[]
    disconnect?: FG_TRANSACTIONSWhereUniqueInput | FG_TRANSACTIONSWhereUniqueInput[]
    delete?: FG_TRANSACTIONSWhereUniqueInput | FG_TRANSACTIONSWhereUniqueInput[]
    connect?: FG_TRANSACTIONSWhereUniqueInput | FG_TRANSACTIONSWhereUniqueInput[]
    update?: FG_TRANSACTIONSUpdateWithWhereUniqueWithoutInitiatedByInput | FG_TRANSACTIONSUpdateWithWhereUniqueWithoutInitiatedByInput[]
    updateMany?: FG_TRANSACTIONSUpdateManyWithWhereWithoutInitiatedByInput | FG_TRANSACTIONSUpdateManyWithWhereWithoutInitiatedByInput[]
    deleteMany?: FG_TRANSACTIONSScalarWhereInput | FG_TRANSACTIONSScalarWhereInput[]
  }

  export type AuditLogsUpdateManyWithoutChangedByNestedInput = {
    create?: XOR<AuditLogsCreateWithoutChangedByInput, AuditLogsUncheckedCreateWithoutChangedByInput> | AuditLogsCreateWithoutChangedByInput[] | AuditLogsUncheckedCreateWithoutChangedByInput[]
    connectOrCreate?: AuditLogsCreateOrConnectWithoutChangedByInput | AuditLogsCreateOrConnectWithoutChangedByInput[]
    upsert?: AuditLogsUpsertWithWhereUniqueWithoutChangedByInput | AuditLogsUpsertWithWhereUniqueWithoutChangedByInput[]
    createMany?: AuditLogsCreateManyChangedByInputEnvelope
    set?: AuditLogsWhereUniqueInput | AuditLogsWhereUniqueInput[]
    disconnect?: AuditLogsWhereUniqueInput | AuditLogsWhereUniqueInput[]
    delete?: AuditLogsWhereUniqueInput | AuditLogsWhereUniqueInput[]
    connect?: AuditLogsWhereUniqueInput | AuditLogsWhereUniqueInput[]
    update?: AuditLogsUpdateWithWhereUniqueWithoutChangedByInput | AuditLogsUpdateWithWhereUniqueWithoutChangedByInput[]
    updateMany?: AuditLogsUpdateManyWithWhereWithoutChangedByInput | AuditLogsUpdateManyWithWhereWithoutChangedByInput[]
    deleteMany?: AuditLogsScalarWhereInput | AuditLogsScalarWhereInput[]
  }

  export type RM_QCUncheckedUpdateManyWithoutCheckedByNestedInput = {
    create?: XOR<RM_QCCreateWithoutCheckedByInput, RM_QCUncheckedCreateWithoutCheckedByInput> | RM_QCCreateWithoutCheckedByInput[] | RM_QCUncheckedCreateWithoutCheckedByInput[]
    connectOrCreate?: RM_QCCreateOrConnectWithoutCheckedByInput | RM_QCCreateOrConnectWithoutCheckedByInput[]
    upsert?: RM_QCUpsertWithWhereUniqueWithoutCheckedByInput | RM_QCUpsertWithWhereUniqueWithoutCheckedByInput[]
    createMany?: RM_QCCreateManyCheckedByInputEnvelope
    set?: RM_QCWhereUniqueInput | RM_QCWhereUniqueInput[]
    disconnect?: RM_QCWhereUniqueInput | RM_QCWhereUniqueInput[]
    delete?: RM_QCWhereUniqueInput | RM_QCWhereUniqueInput[]
    connect?: RM_QCWhereUniqueInput | RM_QCWhereUniqueInput[]
    update?: RM_QCUpdateWithWhereUniqueWithoutCheckedByInput | RM_QCUpdateWithWhereUniqueWithoutCheckedByInput[]
    updateMany?: RM_QCUpdateManyWithWhereWithoutCheckedByInput | RM_QCUpdateManyWithWhereWithoutCheckedByInput[]
    deleteMany?: RM_QCScalarWhereInput | RM_QCScalarWhereInput[]
  }

  export type RM_QCUncheckedUpdateManyWithoutDoneByNestedInput = {
    create?: XOR<RM_QCCreateWithoutDoneByInput, RM_QCUncheckedCreateWithoutDoneByInput> | RM_QCCreateWithoutDoneByInput[] | RM_QCUncheckedCreateWithoutDoneByInput[]
    connectOrCreate?: RM_QCCreateOrConnectWithoutDoneByInput | RM_QCCreateOrConnectWithoutDoneByInput[]
    upsert?: RM_QCUpsertWithWhereUniqueWithoutDoneByInput | RM_QCUpsertWithWhereUniqueWithoutDoneByInput[]
    createMany?: RM_QCCreateManyDoneByInputEnvelope
    set?: RM_QCWhereUniqueInput | RM_QCWhereUniqueInput[]
    disconnect?: RM_QCWhereUniqueInput | RM_QCWhereUniqueInput[]
    delete?: RM_QCWhereUniqueInput | RM_QCWhereUniqueInput[]
    connect?: RM_QCWhereUniqueInput | RM_QCWhereUniqueInput[]
    update?: RM_QCUpdateWithWhereUniqueWithoutDoneByInput | RM_QCUpdateWithWhereUniqueWithoutDoneByInput[]
    updateMany?: RM_QCUpdateManyWithWhereWithoutDoneByInput | RM_QCUpdateManyWithWhereWithoutDoneByInput[]
    deleteMany?: RM_QCScalarWhereInput | RM_QCScalarWhereInput[]
  }

  export type RM_TRANSACTIONSUncheckedUpdateManyWithoutInitiatedByNestedInput = {
    create?: XOR<RM_TRANSACTIONSCreateWithoutInitiatedByInput, RM_TRANSACTIONSUncheckedCreateWithoutInitiatedByInput> | RM_TRANSACTIONSCreateWithoutInitiatedByInput[] | RM_TRANSACTIONSUncheckedCreateWithoutInitiatedByInput[]
    connectOrCreate?: RM_TRANSACTIONSCreateOrConnectWithoutInitiatedByInput | RM_TRANSACTIONSCreateOrConnectWithoutInitiatedByInput[]
    upsert?: RM_TRANSACTIONSUpsertWithWhereUniqueWithoutInitiatedByInput | RM_TRANSACTIONSUpsertWithWhereUniqueWithoutInitiatedByInput[]
    createMany?: RM_TRANSACTIONSCreateManyInitiatedByInputEnvelope
    set?: RM_TRANSACTIONSWhereUniqueInput | RM_TRANSACTIONSWhereUniqueInput[]
    disconnect?: RM_TRANSACTIONSWhereUniqueInput | RM_TRANSACTIONSWhereUniqueInput[]
    delete?: RM_TRANSACTIONSWhereUniqueInput | RM_TRANSACTIONSWhereUniqueInput[]
    connect?: RM_TRANSACTIONSWhereUniqueInput | RM_TRANSACTIONSWhereUniqueInput[]
    update?: RM_TRANSACTIONSUpdateWithWhereUniqueWithoutInitiatedByInput | RM_TRANSACTIONSUpdateWithWhereUniqueWithoutInitiatedByInput[]
    updateMany?: RM_TRANSACTIONSUpdateManyWithWhereWithoutInitiatedByInput | RM_TRANSACTIONSUpdateManyWithWhereWithoutInitiatedByInput[]
    deleteMany?: RM_TRANSACTIONSScalarWhereInput | RM_TRANSACTIONSScalarWhereInput[]
  }

  export type WIP_TRANSACTIONSUncheckedUpdateManyWithoutInitiatedByNestedInput = {
    create?: XOR<WIP_TRANSACTIONSCreateWithoutInitiatedByInput, WIP_TRANSACTIONSUncheckedCreateWithoutInitiatedByInput> | WIP_TRANSACTIONSCreateWithoutInitiatedByInput[] | WIP_TRANSACTIONSUncheckedCreateWithoutInitiatedByInput[]
    connectOrCreate?: WIP_TRANSACTIONSCreateOrConnectWithoutInitiatedByInput | WIP_TRANSACTIONSCreateOrConnectWithoutInitiatedByInput[]
    upsert?: WIP_TRANSACTIONSUpsertWithWhereUniqueWithoutInitiatedByInput | WIP_TRANSACTIONSUpsertWithWhereUniqueWithoutInitiatedByInput[]
    createMany?: WIP_TRANSACTIONSCreateManyInitiatedByInputEnvelope
    set?: WIP_TRANSACTIONSWhereUniqueInput | WIP_TRANSACTIONSWhereUniqueInput[]
    disconnect?: WIP_TRANSACTIONSWhereUniqueInput | WIP_TRANSACTIONSWhereUniqueInput[]
    delete?: WIP_TRANSACTIONSWhereUniqueInput | WIP_TRANSACTIONSWhereUniqueInput[]
    connect?: WIP_TRANSACTIONSWhereUniqueInput | WIP_TRANSACTIONSWhereUniqueInput[]
    update?: WIP_TRANSACTIONSUpdateWithWhereUniqueWithoutInitiatedByInput | WIP_TRANSACTIONSUpdateWithWhereUniqueWithoutInitiatedByInput[]
    updateMany?: WIP_TRANSACTIONSUpdateManyWithWhereWithoutInitiatedByInput | WIP_TRANSACTIONSUpdateManyWithWhereWithoutInitiatedByInput[]
    deleteMany?: WIP_TRANSACTIONSScalarWhereInput | WIP_TRANSACTIONSScalarWhereInput[]
  }

  export type FG_TRANSACTIONSUncheckedUpdateManyWithoutInitiatedByNestedInput = {
    create?: XOR<FG_TRANSACTIONSCreateWithoutInitiatedByInput, FG_TRANSACTIONSUncheckedCreateWithoutInitiatedByInput> | FG_TRANSACTIONSCreateWithoutInitiatedByInput[] | FG_TRANSACTIONSUncheckedCreateWithoutInitiatedByInput[]
    connectOrCreate?: FG_TRANSACTIONSCreateOrConnectWithoutInitiatedByInput | FG_TRANSACTIONSCreateOrConnectWithoutInitiatedByInput[]
    upsert?: FG_TRANSACTIONSUpsertWithWhereUniqueWithoutInitiatedByInput | FG_TRANSACTIONSUpsertWithWhereUniqueWithoutInitiatedByInput[]
    createMany?: FG_TRANSACTIONSCreateManyInitiatedByInputEnvelope
    set?: FG_TRANSACTIONSWhereUniqueInput | FG_TRANSACTIONSWhereUniqueInput[]
    disconnect?: FG_TRANSACTIONSWhereUniqueInput | FG_TRANSACTIONSWhereUniqueInput[]
    delete?: FG_TRANSACTIONSWhereUniqueInput | FG_TRANSACTIONSWhereUniqueInput[]
    connect?: FG_TRANSACTIONSWhereUniqueInput | FG_TRANSACTIONSWhereUniqueInput[]
    update?: FG_TRANSACTIONSUpdateWithWhereUniqueWithoutInitiatedByInput | FG_TRANSACTIONSUpdateWithWhereUniqueWithoutInitiatedByInput[]
    updateMany?: FG_TRANSACTIONSUpdateManyWithWhereWithoutInitiatedByInput | FG_TRANSACTIONSUpdateManyWithWhereWithoutInitiatedByInput[]
    deleteMany?: FG_TRANSACTIONSScalarWhereInput | FG_TRANSACTIONSScalarWhereInput[]
  }

  export type AuditLogsUncheckedUpdateManyWithoutChangedByNestedInput = {
    create?: XOR<AuditLogsCreateWithoutChangedByInput, AuditLogsUncheckedCreateWithoutChangedByInput> | AuditLogsCreateWithoutChangedByInput[] | AuditLogsUncheckedCreateWithoutChangedByInput[]
    connectOrCreate?: AuditLogsCreateOrConnectWithoutChangedByInput | AuditLogsCreateOrConnectWithoutChangedByInput[]
    upsert?: AuditLogsUpsertWithWhereUniqueWithoutChangedByInput | AuditLogsUpsertWithWhereUniqueWithoutChangedByInput[]
    createMany?: AuditLogsCreateManyChangedByInputEnvelope
    set?: AuditLogsWhereUniqueInput | AuditLogsWhereUniqueInput[]
    disconnect?: AuditLogsWhereUniqueInput | AuditLogsWhereUniqueInput[]
    delete?: AuditLogsWhereUniqueInput | AuditLogsWhereUniqueInput[]
    connect?: AuditLogsWhereUniqueInput | AuditLogsWhereUniqueInput[]
    update?: AuditLogsUpdateWithWhereUniqueWithoutChangedByInput | AuditLogsUpdateWithWhereUniqueWithoutChangedByInput[]
    updateMany?: AuditLogsUpdateManyWithWhereWithoutChangedByInput | AuditLogsUpdateManyWithWhereWithoutChangedByInput[]
    deleteMany?: AuditLogsScalarWhereInput | AuditLogsScalarWhereInput[]
  }

  export type WIP_TRANSACTIONSCreateNestedManyWithoutWipInput = {
    create?: XOR<WIP_TRANSACTIONSCreateWithoutWipInput, WIP_TRANSACTIONSUncheckedCreateWithoutWipInput> | WIP_TRANSACTIONSCreateWithoutWipInput[] | WIP_TRANSACTIONSUncheckedCreateWithoutWipInput[]
    connectOrCreate?: WIP_TRANSACTIONSCreateOrConnectWithoutWipInput | WIP_TRANSACTIONSCreateOrConnectWithoutWipInput[]
    createMany?: WIP_TRANSACTIONSCreateManyWipInputEnvelope
    connect?: WIP_TRANSACTIONSWhereUniqueInput | WIP_TRANSACTIONSWhereUniqueInput[]
  }

  export type WIP_QCCreateNestedManyWithoutWipInput = {
    create?: XOR<WIP_QCCreateWithoutWipInput, WIP_QCUncheckedCreateWithoutWipInput> | WIP_QCCreateWithoutWipInput[] | WIP_QCUncheckedCreateWithoutWipInput[]
    connectOrCreate?: WIP_QCCreateOrConnectWithoutWipInput | WIP_QCCreateOrConnectWithoutWipInput[]
    createMany?: WIP_QCCreateManyWipInputEnvelope
    connect?: WIP_QCWhereUniqueInput | WIP_QCWhereUniqueInput[]
  }

  export type WIP_WASTAGE_LOGSCreateNestedManyWithoutWipInput = {
    create?: XOR<WIP_WASTAGE_LOGSCreateWithoutWipInput, WIP_WASTAGE_LOGSUncheckedCreateWithoutWipInput> | WIP_WASTAGE_LOGSCreateWithoutWipInput[] | WIP_WASTAGE_LOGSUncheckedCreateWithoutWipInput[]
    connectOrCreate?: WIP_WASTAGE_LOGSCreateOrConnectWithoutWipInput | WIP_WASTAGE_LOGSCreateOrConnectWithoutWipInput[]
    createMany?: WIP_WASTAGE_LOGSCreateManyWipInputEnvelope
    connect?: WIP_WASTAGE_LOGSWhereUniqueInput | WIP_WASTAGE_LOGSWhereUniqueInput[]
  }

  export type WIP_PRODUCTSCreateNestedManyWithoutWipInput = {
    create?: XOR<WIP_PRODUCTSCreateWithoutWipInput, WIP_PRODUCTSUncheckedCreateWithoutWipInput> | WIP_PRODUCTSCreateWithoutWipInput[] | WIP_PRODUCTSUncheckedCreateWithoutWipInput[]
    connectOrCreate?: WIP_PRODUCTSCreateOrConnectWithoutWipInput | WIP_PRODUCTSCreateOrConnectWithoutWipInput[]
    createMany?: WIP_PRODUCTSCreateManyWipInputEnvelope
    connect?: WIP_PRODUCTSWhereUniqueInput | WIP_PRODUCTSWhereUniqueInput[]
  }

  export type WIPRawMaterialCreateNestedManyWithoutWipInput = {
    create?: XOR<WIPRawMaterialCreateWithoutWipInput, WIPRawMaterialUncheckedCreateWithoutWipInput> | WIPRawMaterialCreateWithoutWipInput[] | WIPRawMaterialUncheckedCreateWithoutWipInput[]
    connectOrCreate?: WIPRawMaterialCreateOrConnectWithoutWipInput | WIPRawMaterialCreateOrConnectWithoutWipInput[]
    createMany?: WIPRawMaterialCreateManyWipInputEnvelope
    connect?: WIPRawMaterialWhereUniqueInput | WIPRawMaterialWhereUniqueInput[]
  }

  export type WIP_TRANSACTIONSUncheckedCreateNestedManyWithoutWipInput = {
    create?: XOR<WIP_TRANSACTIONSCreateWithoutWipInput, WIP_TRANSACTIONSUncheckedCreateWithoutWipInput> | WIP_TRANSACTIONSCreateWithoutWipInput[] | WIP_TRANSACTIONSUncheckedCreateWithoutWipInput[]
    connectOrCreate?: WIP_TRANSACTIONSCreateOrConnectWithoutWipInput | WIP_TRANSACTIONSCreateOrConnectWithoutWipInput[]
    createMany?: WIP_TRANSACTIONSCreateManyWipInputEnvelope
    connect?: WIP_TRANSACTIONSWhereUniqueInput | WIP_TRANSACTIONSWhereUniqueInput[]
  }

  export type WIP_QCUncheckedCreateNestedManyWithoutWipInput = {
    create?: XOR<WIP_QCCreateWithoutWipInput, WIP_QCUncheckedCreateWithoutWipInput> | WIP_QCCreateWithoutWipInput[] | WIP_QCUncheckedCreateWithoutWipInput[]
    connectOrCreate?: WIP_QCCreateOrConnectWithoutWipInput | WIP_QCCreateOrConnectWithoutWipInput[]
    createMany?: WIP_QCCreateManyWipInputEnvelope
    connect?: WIP_QCWhereUniqueInput | WIP_QCWhereUniqueInput[]
  }

  export type WIP_WASTAGE_LOGSUncheckedCreateNestedManyWithoutWipInput = {
    create?: XOR<WIP_WASTAGE_LOGSCreateWithoutWipInput, WIP_WASTAGE_LOGSUncheckedCreateWithoutWipInput> | WIP_WASTAGE_LOGSCreateWithoutWipInput[] | WIP_WASTAGE_LOGSUncheckedCreateWithoutWipInput[]
    connectOrCreate?: WIP_WASTAGE_LOGSCreateOrConnectWithoutWipInput | WIP_WASTAGE_LOGSCreateOrConnectWithoutWipInput[]
    createMany?: WIP_WASTAGE_LOGSCreateManyWipInputEnvelope
    connect?: WIP_WASTAGE_LOGSWhereUniqueInput | WIP_WASTAGE_LOGSWhereUniqueInput[]
  }

  export type WIP_PRODUCTSUncheckedCreateNestedManyWithoutWipInput = {
    create?: XOR<WIP_PRODUCTSCreateWithoutWipInput, WIP_PRODUCTSUncheckedCreateWithoutWipInput> | WIP_PRODUCTSCreateWithoutWipInput[] | WIP_PRODUCTSUncheckedCreateWithoutWipInput[]
    connectOrCreate?: WIP_PRODUCTSCreateOrConnectWithoutWipInput | WIP_PRODUCTSCreateOrConnectWithoutWipInput[]
    createMany?: WIP_PRODUCTSCreateManyWipInputEnvelope
    connect?: WIP_PRODUCTSWhereUniqueInput | WIP_PRODUCTSWhereUniqueInput[]
  }

  export type WIPRawMaterialUncheckedCreateNestedManyWithoutWipInput = {
    create?: XOR<WIPRawMaterialCreateWithoutWipInput, WIPRawMaterialUncheckedCreateWithoutWipInput> | WIPRawMaterialCreateWithoutWipInput[] | WIPRawMaterialUncheckedCreateWithoutWipInput[]
    connectOrCreate?: WIPRawMaterialCreateOrConnectWithoutWipInput | WIPRawMaterialCreateOrConnectWithoutWipInput[]
    createMany?: WIPRawMaterialCreateManyWipInputEnvelope
    connect?: WIPRawMaterialWhereUniqueInput | WIPRawMaterialWhereUniqueInput[]
  }

  export type EnumStatusFieldUpdateOperationsInput = {
    set?: $Enums.Status
  }

  export type WIP_TRANSACTIONSUpdateManyWithoutWipNestedInput = {
    create?: XOR<WIP_TRANSACTIONSCreateWithoutWipInput, WIP_TRANSACTIONSUncheckedCreateWithoutWipInput> | WIP_TRANSACTIONSCreateWithoutWipInput[] | WIP_TRANSACTIONSUncheckedCreateWithoutWipInput[]
    connectOrCreate?: WIP_TRANSACTIONSCreateOrConnectWithoutWipInput | WIP_TRANSACTIONSCreateOrConnectWithoutWipInput[]
    upsert?: WIP_TRANSACTIONSUpsertWithWhereUniqueWithoutWipInput | WIP_TRANSACTIONSUpsertWithWhereUniqueWithoutWipInput[]
    createMany?: WIP_TRANSACTIONSCreateManyWipInputEnvelope
    set?: WIP_TRANSACTIONSWhereUniqueInput | WIP_TRANSACTIONSWhereUniqueInput[]
    disconnect?: WIP_TRANSACTIONSWhereUniqueInput | WIP_TRANSACTIONSWhereUniqueInput[]
    delete?: WIP_TRANSACTIONSWhereUniqueInput | WIP_TRANSACTIONSWhereUniqueInput[]
    connect?: WIP_TRANSACTIONSWhereUniqueInput | WIP_TRANSACTIONSWhereUniqueInput[]
    update?: WIP_TRANSACTIONSUpdateWithWhereUniqueWithoutWipInput | WIP_TRANSACTIONSUpdateWithWhereUniqueWithoutWipInput[]
    updateMany?: WIP_TRANSACTIONSUpdateManyWithWhereWithoutWipInput | WIP_TRANSACTIONSUpdateManyWithWhereWithoutWipInput[]
    deleteMany?: WIP_TRANSACTIONSScalarWhereInput | WIP_TRANSACTIONSScalarWhereInput[]
  }

  export type WIP_QCUpdateManyWithoutWipNestedInput = {
    create?: XOR<WIP_QCCreateWithoutWipInput, WIP_QCUncheckedCreateWithoutWipInput> | WIP_QCCreateWithoutWipInput[] | WIP_QCUncheckedCreateWithoutWipInput[]
    connectOrCreate?: WIP_QCCreateOrConnectWithoutWipInput | WIP_QCCreateOrConnectWithoutWipInput[]
    upsert?: WIP_QCUpsertWithWhereUniqueWithoutWipInput | WIP_QCUpsertWithWhereUniqueWithoutWipInput[]
    createMany?: WIP_QCCreateManyWipInputEnvelope
    set?: WIP_QCWhereUniqueInput | WIP_QCWhereUniqueInput[]
    disconnect?: WIP_QCWhereUniqueInput | WIP_QCWhereUniqueInput[]
    delete?: WIP_QCWhereUniqueInput | WIP_QCWhereUniqueInput[]
    connect?: WIP_QCWhereUniqueInput | WIP_QCWhereUniqueInput[]
    update?: WIP_QCUpdateWithWhereUniqueWithoutWipInput | WIP_QCUpdateWithWhereUniqueWithoutWipInput[]
    updateMany?: WIP_QCUpdateManyWithWhereWithoutWipInput | WIP_QCUpdateManyWithWhereWithoutWipInput[]
    deleteMany?: WIP_QCScalarWhereInput | WIP_QCScalarWhereInput[]
  }

  export type WIP_WASTAGE_LOGSUpdateManyWithoutWipNestedInput = {
    create?: XOR<WIP_WASTAGE_LOGSCreateWithoutWipInput, WIP_WASTAGE_LOGSUncheckedCreateWithoutWipInput> | WIP_WASTAGE_LOGSCreateWithoutWipInput[] | WIP_WASTAGE_LOGSUncheckedCreateWithoutWipInput[]
    connectOrCreate?: WIP_WASTAGE_LOGSCreateOrConnectWithoutWipInput | WIP_WASTAGE_LOGSCreateOrConnectWithoutWipInput[]
    upsert?: WIP_WASTAGE_LOGSUpsertWithWhereUniqueWithoutWipInput | WIP_WASTAGE_LOGSUpsertWithWhereUniqueWithoutWipInput[]
    createMany?: WIP_WASTAGE_LOGSCreateManyWipInputEnvelope
    set?: WIP_WASTAGE_LOGSWhereUniqueInput | WIP_WASTAGE_LOGSWhereUniqueInput[]
    disconnect?: WIP_WASTAGE_LOGSWhereUniqueInput | WIP_WASTAGE_LOGSWhereUniqueInput[]
    delete?: WIP_WASTAGE_LOGSWhereUniqueInput | WIP_WASTAGE_LOGSWhereUniqueInput[]
    connect?: WIP_WASTAGE_LOGSWhereUniqueInput | WIP_WASTAGE_LOGSWhereUniqueInput[]
    update?: WIP_WASTAGE_LOGSUpdateWithWhereUniqueWithoutWipInput | WIP_WASTAGE_LOGSUpdateWithWhereUniqueWithoutWipInput[]
    updateMany?: WIP_WASTAGE_LOGSUpdateManyWithWhereWithoutWipInput | WIP_WASTAGE_LOGSUpdateManyWithWhereWithoutWipInput[]
    deleteMany?: WIP_WASTAGE_LOGSScalarWhereInput | WIP_WASTAGE_LOGSScalarWhereInput[]
  }

  export type WIP_PRODUCTSUpdateManyWithoutWipNestedInput = {
    create?: XOR<WIP_PRODUCTSCreateWithoutWipInput, WIP_PRODUCTSUncheckedCreateWithoutWipInput> | WIP_PRODUCTSCreateWithoutWipInput[] | WIP_PRODUCTSUncheckedCreateWithoutWipInput[]
    connectOrCreate?: WIP_PRODUCTSCreateOrConnectWithoutWipInput | WIP_PRODUCTSCreateOrConnectWithoutWipInput[]
    upsert?: WIP_PRODUCTSUpsertWithWhereUniqueWithoutWipInput | WIP_PRODUCTSUpsertWithWhereUniqueWithoutWipInput[]
    createMany?: WIP_PRODUCTSCreateManyWipInputEnvelope
    set?: WIP_PRODUCTSWhereUniqueInput | WIP_PRODUCTSWhereUniqueInput[]
    disconnect?: WIP_PRODUCTSWhereUniqueInput | WIP_PRODUCTSWhereUniqueInput[]
    delete?: WIP_PRODUCTSWhereUniqueInput | WIP_PRODUCTSWhereUniqueInput[]
    connect?: WIP_PRODUCTSWhereUniqueInput | WIP_PRODUCTSWhereUniqueInput[]
    update?: WIP_PRODUCTSUpdateWithWhereUniqueWithoutWipInput | WIP_PRODUCTSUpdateWithWhereUniqueWithoutWipInput[]
    updateMany?: WIP_PRODUCTSUpdateManyWithWhereWithoutWipInput | WIP_PRODUCTSUpdateManyWithWhereWithoutWipInput[]
    deleteMany?: WIP_PRODUCTSScalarWhereInput | WIP_PRODUCTSScalarWhereInput[]
  }

  export type WIPRawMaterialUpdateManyWithoutWipNestedInput = {
    create?: XOR<WIPRawMaterialCreateWithoutWipInput, WIPRawMaterialUncheckedCreateWithoutWipInput> | WIPRawMaterialCreateWithoutWipInput[] | WIPRawMaterialUncheckedCreateWithoutWipInput[]
    connectOrCreate?: WIPRawMaterialCreateOrConnectWithoutWipInput | WIPRawMaterialCreateOrConnectWithoutWipInput[]
    upsert?: WIPRawMaterialUpsertWithWhereUniqueWithoutWipInput | WIPRawMaterialUpsertWithWhereUniqueWithoutWipInput[]
    createMany?: WIPRawMaterialCreateManyWipInputEnvelope
    set?: WIPRawMaterialWhereUniqueInput | WIPRawMaterialWhereUniqueInput[]
    disconnect?: WIPRawMaterialWhereUniqueInput | WIPRawMaterialWhereUniqueInput[]
    delete?: WIPRawMaterialWhereUniqueInput | WIPRawMaterialWhereUniqueInput[]
    connect?: WIPRawMaterialWhereUniqueInput | WIPRawMaterialWhereUniqueInput[]
    update?: WIPRawMaterialUpdateWithWhereUniqueWithoutWipInput | WIPRawMaterialUpdateWithWhereUniqueWithoutWipInput[]
    updateMany?: WIPRawMaterialUpdateManyWithWhereWithoutWipInput | WIPRawMaterialUpdateManyWithWhereWithoutWipInput[]
    deleteMany?: WIPRawMaterialScalarWhereInput | WIPRawMaterialScalarWhereInput[]
  }

  export type WIP_TRANSACTIONSUncheckedUpdateManyWithoutWipNestedInput = {
    create?: XOR<WIP_TRANSACTIONSCreateWithoutWipInput, WIP_TRANSACTIONSUncheckedCreateWithoutWipInput> | WIP_TRANSACTIONSCreateWithoutWipInput[] | WIP_TRANSACTIONSUncheckedCreateWithoutWipInput[]
    connectOrCreate?: WIP_TRANSACTIONSCreateOrConnectWithoutWipInput | WIP_TRANSACTIONSCreateOrConnectWithoutWipInput[]
    upsert?: WIP_TRANSACTIONSUpsertWithWhereUniqueWithoutWipInput | WIP_TRANSACTIONSUpsertWithWhereUniqueWithoutWipInput[]
    createMany?: WIP_TRANSACTIONSCreateManyWipInputEnvelope
    set?: WIP_TRANSACTIONSWhereUniqueInput | WIP_TRANSACTIONSWhereUniqueInput[]
    disconnect?: WIP_TRANSACTIONSWhereUniqueInput | WIP_TRANSACTIONSWhereUniqueInput[]
    delete?: WIP_TRANSACTIONSWhereUniqueInput | WIP_TRANSACTIONSWhereUniqueInput[]
    connect?: WIP_TRANSACTIONSWhereUniqueInput | WIP_TRANSACTIONSWhereUniqueInput[]
    update?: WIP_TRANSACTIONSUpdateWithWhereUniqueWithoutWipInput | WIP_TRANSACTIONSUpdateWithWhereUniqueWithoutWipInput[]
    updateMany?: WIP_TRANSACTIONSUpdateManyWithWhereWithoutWipInput | WIP_TRANSACTIONSUpdateManyWithWhereWithoutWipInput[]
    deleteMany?: WIP_TRANSACTIONSScalarWhereInput | WIP_TRANSACTIONSScalarWhereInput[]
  }

  export type WIP_QCUncheckedUpdateManyWithoutWipNestedInput = {
    create?: XOR<WIP_QCCreateWithoutWipInput, WIP_QCUncheckedCreateWithoutWipInput> | WIP_QCCreateWithoutWipInput[] | WIP_QCUncheckedCreateWithoutWipInput[]
    connectOrCreate?: WIP_QCCreateOrConnectWithoutWipInput | WIP_QCCreateOrConnectWithoutWipInput[]
    upsert?: WIP_QCUpsertWithWhereUniqueWithoutWipInput | WIP_QCUpsertWithWhereUniqueWithoutWipInput[]
    createMany?: WIP_QCCreateManyWipInputEnvelope
    set?: WIP_QCWhereUniqueInput | WIP_QCWhereUniqueInput[]
    disconnect?: WIP_QCWhereUniqueInput | WIP_QCWhereUniqueInput[]
    delete?: WIP_QCWhereUniqueInput | WIP_QCWhereUniqueInput[]
    connect?: WIP_QCWhereUniqueInput | WIP_QCWhereUniqueInput[]
    update?: WIP_QCUpdateWithWhereUniqueWithoutWipInput | WIP_QCUpdateWithWhereUniqueWithoutWipInput[]
    updateMany?: WIP_QCUpdateManyWithWhereWithoutWipInput | WIP_QCUpdateManyWithWhereWithoutWipInput[]
    deleteMany?: WIP_QCScalarWhereInput | WIP_QCScalarWhereInput[]
  }

  export type WIP_WASTAGE_LOGSUncheckedUpdateManyWithoutWipNestedInput = {
    create?: XOR<WIP_WASTAGE_LOGSCreateWithoutWipInput, WIP_WASTAGE_LOGSUncheckedCreateWithoutWipInput> | WIP_WASTAGE_LOGSCreateWithoutWipInput[] | WIP_WASTAGE_LOGSUncheckedCreateWithoutWipInput[]
    connectOrCreate?: WIP_WASTAGE_LOGSCreateOrConnectWithoutWipInput | WIP_WASTAGE_LOGSCreateOrConnectWithoutWipInput[]
    upsert?: WIP_WASTAGE_LOGSUpsertWithWhereUniqueWithoutWipInput | WIP_WASTAGE_LOGSUpsertWithWhereUniqueWithoutWipInput[]
    createMany?: WIP_WASTAGE_LOGSCreateManyWipInputEnvelope
    set?: WIP_WASTAGE_LOGSWhereUniqueInput | WIP_WASTAGE_LOGSWhereUniqueInput[]
    disconnect?: WIP_WASTAGE_LOGSWhereUniqueInput | WIP_WASTAGE_LOGSWhereUniqueInput[]
    delete?: WIP_WASTAGE_LOGSWhereUniqueInput | WIP_WASTAGE_LOGSWhereUniqueInput[]
    connect?: WIP_WASTAGE_LOGSWhereUniqueInput | WIP_WASTAGE_LOGSWhereUniqueInput[]
    update?: WIP_WASTAGE_LOGSUpdateWithWhereUniqueWithoutWipInput | WIP_WASTAGE_LOGSUpdateWithWhereUniqueWithoutWipInput[]
    updateMany?: WIP_WASTAGE_LOGSUpdateManyWithWhereWithoutWipInput | WIP_WASTAGE_LOGSUpdateManyWithWhereWithoutWipInput[]
    deleteMany?: WIP_WASTAGE_LOGSScalarWhereInput | WIP_WASTAGE_LOGSScalarWhereInput[]
  }

  export type WIP_PRODUCTSUncheckedUpdateManyWithoutWipNestedInput = {
    create?: XOR<WIP_PRODUCTSCreateWithoutWipInput, WIP_PRODUCTSUncheckedCreateWithoutWipInput> | WIP_PRODUCTSCreateWithoutWipInput[] | WIP_PRODUCTSUncheckedCreateWithoutWipInput[]
    connectOrCreate?: WIP_PRODUCTSCreateOrConnectWithoutWipInput | WIP_PRODUCTSCreateOrConnectWithoutWipInput[]
    upsert?: WIP_PRODUCTSUpsertWithWhereUniqueWithoutWipInput | WIP_PRODUCTSUpsertWithWhereUniqueWithoutWipInput[]
    createMany?: WIP_PRODUCTSCreateManyWipInputEnvelope
    set?: WIP_PRODUCTSWhereUniqueInput | WIP_PRODUCTSWhereUniqueInput[]
    disconnect?: WIP_PRODUCTSWhereUniqueInput | WIP_PRODUCTSWhereUniqueInput[]
    delete?: WIP_PRODUCTSWhereUniqueInput | WIP_PRODUCTSWhereUniqueInput[]
    connect?: WIP_PRODUCTSWhereUniqueInput | WIP_PRODUCTSWhereUniqueInput[]
    update?: WIP_PRODUCTSUpdateWithWhereUniqueWithoutWipInput | WIP_PRODUCTSUpdateWithWhereUniqueWithoutWipInput[]
    updateMany?: WIP_PRODUCTSUpdateManyWithWhereWithoutWipInput | WIP_PRODUCTSUpdateManyWithWhereWithoutWipInput[]
    deleteMany?: WIP_PRODUCTSScalarWhereInput | WIP_PRODUCTSScalarWhereInput[]
  }

  export type WIPRawMaterialUncheckedUpdateManyWithoutWipNestedInput = {
    create?: XOR<WIPRawMaterialCreateWithoutWipInput, WIPRawMaterialUncheckedCreateWithoutWipInput> | WIPRawMaterialCreateWithoutWipInput[] | WIPRawMaterialUncheckedCreateWithoutWipInput[]
    connectOrCreate?: WIPRawMaterialCreateOrConnectWithoutWipInput | WIPRawMaterialCreateOrConnectWithoutWipInput[]
    upsert?: WIPRawMaterialUpsertWithWhereUniqueWithoutWipInput | WIPRawMaterialUpsertWithWhereUniqueWithoutWipInput[]
    createMany?: WIPRawMaterialCreateManyWipInputEnvelope
    set?: WIPRawMaterialWhereUniqueInput | WIPRawMaterialWhereUniqueInput[]
    disconnect?: WIPRawMaterialWhereUniqueInput | WIPRawMaterialWhereUniqueInput[]
    delete?: WIPRawMaterialWhereUniqueInput | WIPRawMaterialWhereUniqueInput[]
    connect?: WIPRawMaterialWhereUniqueInput | WIPRawMaterialWhereUniqueInput[]
    update?: WIPRawMaterialUpdateWithWhereUniqueWithoutWipInput | WIPRawMaterialUpdateWithWhereUniqueWithoutWipInput[]
    updateMany?: WIPRawMaterialUpdateManyWithWhereWithoutWipInput | WIPRawMaterialUpdateManyWithWhereWithoutWipInput[]
    deleteMany?: WIPRawMaterialScalarWhereInput | WIPRawMaterialScalarWhereInput[]
  }

  export type WIPCreateNestedOneWithoutWipProductsInput = {
    create?: XOR<WIPCreateWithoutWipProductsInput, WIPUncheckedCreateWithoutWipProductsInput>
    connectOrCreate?: WIPCreateOrConnectWithoutWipProductsInput
    connect?: WIPWhereUniqueInput
  }

  export type SHOPIFY_PRODUCTSCreateNestedOneWithoutWIPProductsInput = {
    create?: XOR<SHOPIFY_PRODUCTSCreateWithoutWIPProductsInput, SHOPIFY_PRODUCTSUncheckedCreateWithoutWIPProductsInput>
    connectOrCreate?: SHOPIFY_PRODUCTSCreateOrConnectWithoutWIPProductsInput
    connect?: SHOPIFY_PRODUCTSWhereUniqueInput
  }

  export type WIPUpdateOneRequiredWithoutWipProductsNestedInput = {
    create?: XOR<WIPCreateWithoutWipProductsInput, WIPUncheckedCreateWithoutWipProductsInput>
    connectOrCreate?: WIPCreateOrConnectWithoutWipProductsInput
    upsert?: WIPUpsertWithoutWipProductsInput
    connect?: WIPWhereUniqueInput
    update?: XOR<XOR<WIPUpdateToOneWithWhereWithoutWipProductsInput, WIPUpdateWithoutWipProductsInput>, WIPUncheckedUpdateWithoutWipProductsInput>
  }

  export type SHOPIFY_PRODUCTSUpdateOneRequiredWithoutWIPProductsNestedInput = {
    create?: XOR<SHOPIFY_PRODUCTSCreateWithoutWIPProductsInput, SHOPIFY_PRODUCTSUncheckedCreateWithoutWIPProductsInput>
    connectOrCreate?: SHOPIFY_PRODUCTSCreateOrConnectWithoutWIPProductsInput
    upsert?: SHOPIFY_PRODUCTSUpsertWithoutWIPProductsInput
    connect?: SHOPIFY_PRODUCTSWhereUniqueInput
    update?: XOR<XOR<SHOPIFY_PRODUCTSUpdateToOneWithWhereWithoutWIPProductsInput, SHOPIFY_PRODUCTSUpdateWithoutWIPProductsInput>, SHOPIFY_PRODUCTSUncheckedUpdateWithoutWIPProductsInput>
  }

  export type WIPCreateNestedOneWithoutWIPMaterialsInput = {
    create?: XOR<WIPCreateWithoutWIPMaterialsInput, WIPUncheckedCreateWithoutWIPMaterialsInput>
    connectOrCreate?: WIPCreateOrConnectWithoutWIPMaterialsInput
    connect?: WIPWhereUniqueInput
  }

  export type RAW_MATERIALSCreateNestedOneWithoutWIPMaterialsInput = {
    create?: XOR<RAW_MATERIALSCreateWithoutWIPMaterialsInput, RAW_MATERIALSUncheckedCreateWithoutWIPMaterialsInput>
    connectOrCreate?: RAW_MATERIALSCreateOrConnectWithoutWIPMaterialsInput
    connect?: RAW_MATERIALSWhereUniqueInput
  }

  export type WIPUpdateOneRequiredWithoutWIPMaterialsNestedInput = {
    create?: XOR<WIPCreateWithoutWIPMaterialsInput, WIPUncheckedCreateWithoutWIPMaterialsInput>
    connectOrCreate?: WIPCreateOrConnectWithoutWIPMaterialsInput
    upsert?: WIPUpsertWithoutWIPMaterialsInput
    connect?: WIPWhereUniqueInput
    update?: XOR<XOR<WIPUpdateToOneWithWhereWithoutWIPMaterialsInput, WIPUpdateWithoutWIPMaterialsInput>, WIPUncheckedUpdateWithoutWIPMaterialsInput>
  }

  export type RAW_MATERIALSUpdateOneRequiredWithoutWIPMaterialsNestedInput = {
    create?: XOR<RAW_MATERIALSCreateWithoutWIPMaterialsInput, RAW_MATERIALSUncheckedCreateWithoutWIPMaterialsInput>
    connectOrCreate?: RAW_MATERIALSCreateOrConnectWithoutWIPMaterialsInput
    upsert?: RAW_MATERIALSUpsertWithoutWIPMaterialsInput
    connect?: RAW_MATERIALSWhereUniqueInput
    update?: XOR<XOR<RAW_MATERIALSUpdateToOneWithWhereWithoutWIPMaterialsInput, RAW_MATERIALSUpdateWithoutWIPMaterialsInput>, RAW_MATERIALSUncheckedUpdateWithoutWIPMaterialsInput>
  }

  export type FG_TRANSACTIONSCreateNestedManyWithoutFgInput = {
    create?: XOR<FG_TRANSACTIONSCreateWithoutFgInput, FG_TRANSACTIONSUncheckedCreateWithoutFgInput> | FG_TRANSACTIONSCreateWithoutFgInput[] | FG_TRANSACTIONSUncheckedCreateWithoutFgInput[]
    connectOrCreate?: FG_TRANSACTIONSCreateOrConnectWithoutFgInput | FG_TRANSACTIONSCreateOrConnectWithoutFgInput[]
    createMany?: FG_TRANSACTIONSCreateManyFgInputEnvelope
    connect?: FG_TRANSACTIONSWhereUniqueInput | FG_TRANSACTIONSWhereUniqueInput[]
  }

  export type FG_QCCreateNestedManyWithoutFgInput = {
    create?: XOR<FG_QCCreateWithoutFgInput, FG_QCUncheckedCreateWithoutFgInput> | FG_QCCreateWithoutFgInput[] | FG_QCUncheckedCreateWithoutFgInput[]
    connectOrCreate?: FG_QCCreateOrConnectWithoutFgInput | FG_QCCreateOrConnectWithoutFgInput[]
    createMany?: FG_QCCreateManyFgInputEnvelope
    connect?: FG_QCWhereUniqueInput | FG_QCWhereUniqueInput[]
  }

  export type FG_WASTAGE_LOGSCreateNestedManyWithoutFgInput = {
    create?: XOR<FG_WASTAGE_LOGSCreateWithoutFgInput, FG_WASTAGE_LOGSUncheckedCreateWithoutFgInput> | FG_WASTAGE_LOGSCreateWithoutFgInput[] | FG_WASTAGE_LOGSUncheckedCreateWithoutFgInput[]
    connectOrCreate?: FG_WASTAGE_LOGSCreateOrConnectWithoutFgInput | FG_WASTAGE_LOGSCreateOrConnectWithoutFgInput[]
    createMany?: FG_WASTAGE_LOGSCreateManyFgInputEnvelope
    connect?: FG_WASTAGE_LOGSWhereUniqueInput | FG_WASTAGE_LOGSWhereUniqueInput[]
  }

  export type FG_PRODUCTSCreateNestedManyWithoutFgInput = {
    create?: XOR<FG_PRODUCTSCreateWithoutFgInput, FG_PRODUCTSUncheckedCreateWithoutFgInput> | FG_PRODUCTSCreateWithoutFgInput[] | FG_PRODUCTSUncheckedCreateWithoutFgInput[]
    connectOrCreate?: FG_PRODUCTSCreateOrConnectWithoutFgInput | FG_PRODUCTSCreateOrConnectWithoutFgInput[]
    createMany?: FG_PRODUCTSCreateManyFgInputEnvelope
    connect?: FG_PRODUCTSWhereUniqueInput | FG_PRODUCTSWhereUniqueInput[]
  }

  export type FG_TRANSACTIONSUncheckedCreateNestedManyWithoutFgInput = {
    create?: XOR<FG_TRANSACTIONSCreateWithoutFgInput, FG_TRANSACTIONSUncheckedCreateWithoutFgInput> | FG_TRANSACTIONSCreateWithoutFgInput[] | FG_TRANSACTIONSUncheckedCreateWithoutFgInput[]
    connectOrCreate?: FG_TRANSACTIONSCreateOrConnectWithoutFgInput | FG_TRANSACTIONSCreateOrConnectWithoutFgInput[]
    createMany?: FG_TRANSACTIONSCreateManyFgInputEnvelope
    connect?: FG_TRANSACTIONSWhereUniqueInput | FG_TRANSACTIONSWhereUniqueInput[]
  }

  export type FG_QCUncheckedCreateNestedManyWithoutFgInput = {
    create?: XOR<FG_QCCreateWithoutFgInput, FG_QCUncheckedCreateWithoutFgInput> | FG_QCCreateWithoutFgInput[] | FG_QCUncheckedCreateWithoutFgInput[]
    connectOrCreate?: FG_QCCreateOrConnectWithoutFgInput | FG_QCCreateOrConnectWithoutFgInput[]
    createMany?: FG_QCCreateManyFgInputEnvelope
    connect?: FG_QCWhereUniqueInput | FG_QCWhereUniqueInput[]
  }

  export type FG_WASTAGE_LOGSUncheckedCreateNestedManyWithoutFgInput = {
    create?: XOR<FG_WASTAGE_LOGSCreateWithoutFgInput, FG_WASTAGE_LOGSUncheckedCreateWithoutFgInput> | FG_WASTAGE_LOGSCreateWithoutFgInput[] | FG_WASTAGE_LOGSUncheckedCreateWithoutFgInput[]
    connectOrCreate?: FG_WASTAGE_LOGSCreateOrConnectWithoutFgInput | FG_WASTAGE_LOGSCreateOrConnectWithoutFgInput[]
    createMany?: FG_WASTAGE_LOGSCreateManyFgInputEnvelope
    connect?: FG_WASTAGE_LOGSWhereUniqueInput | FG_WASTAGE_LOGSWhereUniqueInput[]
  }

  export type FG_PRODUCTSUncheckedCreateNestedManyWithoutFgInput = {
    create?: XOR<FG_PRODUCTSCreateWithoutFgInput, FG_PRODUCTSUncheckedCreateWithoutFgInput> | FG_PRODUCTSCreateWithoutFgInput[] | FG_PRODUCTSUncheckedCreateWithoutFgInput[]
    connectOrCreate?: FG_PRODUCTSCreateOrConnectWithoutFgInput | FG_PRODUCTSCreateOrConnectWithoutFgInput[]
    createMany?: FG_PRODUCTSCreateManyFgInputEnvelope
    connect?: FG_PRODUCTSWhereUniqueInput | FG_PRODUCTSWhereUniqueInput[]
  }

  export type FG_TRANSACTIONSUpdateManyWithoutFgNestedInput = {
    create?: XOR<FG_TRANSACTIONSCreateWithoutFgInput, FG_TRANSACTIONSUncheckedCreateWithoutFgInput> | FG_TRANSACTIONSCreateWithoutFgInput[] | FG_TRANSACTIONSUncheckedCreateWithoutFgInput[]
    connectOrCreate?: FG_TRANSACTIONSCreateOrConnectWithoutFgInput | FG_TRANSACTIONSCreateOrConnectWithoutFgInput[]
    upsert?: FG_TRANSACTIONSUpsertWithWhereUniqueWithoutFgInput | FG_TRANSACTIONSUpsertWithWhereUniqueWithoutFgInput[]
    createMany?: FG_TRANSACTIONSCreateManyFgInputEnvelope
    set?: FG_TRANSACTIONSWhereUniqueInput | FG_TRANSACTIONSWhereUniqueInput[]
    disconnect?: FG_TRANSACTIONSWhereUniqueInput | FG_TRANSACTIONSWhereUniqueInput[]
    delete?: FG_TRANSACTIONSWhereUniqueInput | FG_TRANSACTIONSWhereUniqueInput[]
    connect?: FG_TRANSACTIONSWhereUniqueInput | FG_TRANSACTIONSWhereUniqueInput[]
    update?: FG_TRANSACTIONSUpdateWithWhereUniqueWithoutFgInput | FG_TRANSACTIONSUpdateWithWhereUniqueWithoutFgInput[]
    updateMany?: FG_TRANSACTIONSUpdateManyWithWhereWithoutFgInput | FG_TRANSACTIONSUpdateManyWithWhereWithoutFgInput[]
    deleteMany?: FG_TRANSACTIONSScalarWhereInput | FG_TRANSACTIONSScalarWhereInput[]
  }

  export type FG_QCUpdateManyWithoutFgNestedInput = {
    create?: XOR<FG_QCCreateWithoutFgInput, FG_QCUncheckedCreateWithoutFgInput> | FG_QCCreateWithoutFgInput[] | FG_QCUncheckedCreateWithoutFgInput[]
    connectOrCreate?: FG_QCCreateOrConnectWithoutFgInput | FG_QCCreateOrConnectWithoutFgInput[]
    upsert?: FG_QCUpsertWithWhereUniqueWithoutFgInput | FG_QCUpsertWithWhereUniqueWithoutFgInput[]
    createMany?: FG_QCCreateManyFgInputEnvelope
    set?: FG_QCWhereUniqueInput | FG_QCWhereUniqueInput[]
    disconnect?: FG_QCWhereUniqueInput | FG_QCWhereUniqueInput[]
    delete?: FG_QCWhereUniqueInput | FG_QCWhereUniqueInput[]
    connect?: FG_QCWhereUniqueInput | FG_QCWhereUniqueInput[]
    update?: FG_QCUpdateWithWhereUniqueWithoutFgInput | FG_QCUpdateWithWhereUniqueWithoutFgInput[]
    updateMany?: FG_QCUpdateManyWithWhereWithoutFgInput | FG_QCUpdateManyWithWhereWithoutFgInput[]
    deleteMany?: FG_QCScalarWhereInput | FG_QCScalarWhereInput[]
  }

  export type FG_WASTAGE_LOGSUpdateManyWithoutFgNestedInput = {
    create?: XOR<FG_WASTAGE_LOGSCreateWithoutFgInput, FG_WASTAGE_LOGSUncheckedCreateWithoutFgInput> | FG_WASTAGE_LOGSCreateWithoutFgInput[] | FG_WASTAGE_LOGSUncheckedCreateWithoutFgInput[]
    connectOrCreate?: FG_WASTAGE_LOGSCreateOrConnectWithoutFgInput | FG_WASTAGE_LOGSCreateOrConnectWithoutFgInput[]
    upsert?: FG_WASTAGE_LOGSUpsertWithWhereUniqueWithoutFgInput | FG_WASTAGE_LOGSUpsertWithWhereUniqueWithoutFgInput[]
    createMany?: FG_WASTAGE_LOGSCreateManyFgInputEnvelope
    set?: FG_WASTAGE_LOGSWhereUniqueInput | FG_WASTAGE_LOGSWhereUniqueInput[]
    disconnect?: FG_WASTAGE_LOGSWhereUniqueInput | FG_WASTAGE_LOGSWhereUniqueInput[]
    delete?: FG_WASTAGE_LOGSWhereUniqueInput | FG_WASTAGE_LOGSWhereUniqueInput[]
    connect?: FG_WASTAGE_LOGSWhereUniqueInput | FG_WASTAGE_LOGSWhereUniqueInput[]
    update?: FG_WASTAGE_LOGSUpdateWithWhereUniqueWithoutFgInput | FG_WASTAGE_LOGSUpdateWithWhereUniqueWithoutFgInput[]
    updateMany?: FG_WASTAGE_LOGSUpdateManyWithWhereWithoutFgInput | FG_WASTAGE_LOGSUpdateManyWithWhereWithoutFgInput[]
    deleteMany?: FG_WASTAGE_LOGSScalarWhereInput | FG_WASTAGE_LOGSScalarWhereInput[]
  }

  export type FG_PRODUCTSUpdateManyWithoutFgNestedInput = {
    create?: XOR<FG_PRODUCTSCreateWithoutFgInput, FG_PRODUCTSUncheckedCreateWithoutFgInput> | FG_PRODUCTSCreateWithoutFgInput[] | FG_PRODUCTSUncheckedCreateWithoutFgInput[]
    connectOrCreate?: FG_PRODUCTSCreateOrConnectWithoutFgInput | FG_PRODUCTSCreateOrConnectWithoutFgInput[]
    upsert?: FG_PRODUCTSUpsertWithWhereUniqueWithoutFgInput | FG_PRODUCTSUpsertWithWhereUniqueWithoutFgInput[]
    createMany?: FG_PRODUCTSCreateManyFgInputEnvelope
    set?: FG_PRODUCTSWhereUniqueInput | FG_PRODUCTSWhereUniqueInput[]
    disconnect?: FG_PRODUCTSWhereUniqueInput | FG_PRODUCTSWhereUniqueInput[]
    delete?: FG_PRODUCTSWhereUniqueInput | FG_PRODUCTSWhereUniqueInput[]
    connect?: FG_PRODUCTSWhereUniqueInput | FG_PRODUCTSWhereUniqueInput[]
    update?: FG_PRODUCTSUpdateWithWhereUniqueWithoutFgInput | FG_PRODUCTSUpdateWithWhereUniqueWithoutFgInput[]
    updateMany?: FG_PRODUCTSUpdateManyWithWhereWithoutFgInput | FG_PRODUCTSUpdateManyWithWhereWithoutFgInput[]
    deleteMany?: FG_PRODUCTSScalarWhereInput | FG_PRODUCTSScalarWhereInput[]
  }

  export type FG_TRANSACTIONSUncheckedUpdateManyWithoutFgNestedInput = {
    create?: XOR<FG_TRANSACTIONSCreateWithoutFgInput, FG_TRANSACTIONSUncheckedCreateWithoutFgInput> | FG_TRANSACTIONSCreateWithoutFgInput[] | FG_TRANSACTIONSUncheckedCreateWithoutFgInput[]
    connectOrCreate?: FG_TRANSACTIONSCreateOrConnectWithoutFgInput | FG_TRANSACTIONSCreateOrConnectWithoutFgInput[]
    upsert?: FG_TRANSACTIONSUpsertWithWhereUniqueWithoutFgInput | FG_TRANSACTIONSUpsertWithWhereUniqueWithoutFgInput[]
    createMany?: FG_TRANSACTIONSCreateManyFgInputEnvelope
    set?: FG_TRANSACTIONSWhereUniqueInput | FG_TRANSACTIONSWhereUniqueInput[]
    disconnect?: FG_TRANSACTIONSWhereUniqueInput | FG_TRANSACTIONSWhereUniqueInput[]
    delete?: FG_TRANSACTIONSWhereUniqueInput | FG_TRANSACTIONSWhereUniqueInput[]
    connect?: FG_TRANSACTIONSWhereUniqueInput | FG_TRANSACTIONSWhereUniqueInput[]
    update?: FG_TRANSACTIONSUpdateWithWhereUniqueWithoutFgInput | FG_TRANSACTIONSUpdateWithWhereUniqueWithoutFgInput[]
    updateMany?: FG_TRANSACTIONSUpdateManyWithWhereWithoutFgInput | FG_TRANSACTIONSUpdateManyWithWhereWithoutFgInput[]
    deleteMany?: FG_TRANSACTIONSScalarWhereInput | FG_TRANSACTIONSScalarWhereInput[]
  }

  export type FG_QCUncheckedUpdateManyWithoutFgNestedInput = {
    create?: XOR<FG_QCCreateWithoutFgInput, FG_QCUncheckedCreateWithoutFgInput> | FG_QCCreateWithoutFgInput[] | FG_QCUncheckedCreateWithoutFgInput[]
    connectOrCreate?: FG_QCCreateOrConnectWithoutFgInput | FG_QCCreateOrConnectWithoutFgInput[]
    upsert?: FG_QCUpsertWithWhereUniqueWithoutFgInput | FG_QCUpsertWithWhereUniqueWithoutFgInput[]
    createMany?: FG_QCCreateManyFgInputEnvelope
    set?: FG_QCWhereUniqueInput | FG_QCWhereUniqueInput[]
    disconnect?: FG_QCWhereUniqueInput | FG_QCWhereUniqueInput[]
    delete?: FG_QCWhereUniqueInput | FG_QCWhereUniqueInput[]
    connect?: FG_QCWhereUniqueInput | FG_QCWhereUniqueInput[]
    update?: FG_QCUpdateWithWhereUniqueWithoutFgInput | FG_QCUpdateWithWhereUniqueWithoutFgInput[]
    updateMany?: FG_QCUpdateManyWithWhereWithoutFgInput | FG_QCUpdateManyWithWhereWithoutFgInput[]
    deleteMany?: FG_QCScalarWhereInput | FG_QCScalarWhereInput[]
  }

  export type FG_WASTAGE_LOGSUncheckedUpdateManyWithoutFgNestedInput = {
    create?: XOR<FG_WASTAGE_LOGSCreateWithoutFgInput, FG_WASTAGE_LOGSUncheckedCreateWithoutFgInput> | FG_WASTAGE_LOGSCreateWithoutFgInput[] | FG_WASTAGE_LOGSUncheckedCreateWithoutFgInput[]
    connectOrCreate?: FG_WASTAGE_LOGSCreateOrConnectWithoutFgInput | FG_WASTAGE_LOGSCreateOrConnectWithoutFgInput[]
    upsert?: FG_WASTAGE_LOGSUpsertWithWhereUniqueWithoutFgInput | FG_WASTAGE_LOGSUpsertWithWhereUniqueWithoutFgInput[]
    createMany?: FG_WASTAGE_LOGSCreateManyFgInputEnvelope
    set?: FG_WASTAGE_LOGSWhereUniqueInput | FG_WASTAGE_LOGSWhereUniqueInput[]
    disconnect?: FG_WASTAGE_LOGSWhereUniqueInput | FG_WASTAGE_LOGSWhereUniqueInput[]
    delete?: FG_WASTAGE_LOGSWhereUniqueInput | FG_WASTAGE_LOGSWhereUniqueInput[]
    connect?: FG_WASTAGE_LOGSWhereUniqueInput | FG_WASTAGE_LOGSWhereUniqueInput[]
    update?: FG_WASTAGE_LOGSUpdateWithWhereUniqueWithoutFgInput | FG_WASTAGE_LOGSUpdateWithWhereUniqueWithoutFgInput[]
    updateMany?: FG_WASTAGE_LOGSUpdateManyWithWhereWithoutFgInput | FG_WASTAGE_LOGSUpdateManyWithWhereWithoutFgInput[]
    deleteMany?: FG_WASTAGE_LOGSScalarWhereInput | FG_WASTAGE_LOGSScalarWhereInput[]
  }

  export type FG_PRODUCTSUncheckedUpdateManyWithoutFgNestedInput = {
    create?: XOR<FG_PRODUCTSCreateWithoutFgInput, FG_PRODUCTSUncheckedCreateWithoutFgInput> | FG_PRODUCTSCreateWithoutFgInput[] | FG_PRODUCTSUncheckedCreateWithoutFgInput[]
    connectOrCreate?: FG_PRODUCTSCreateOrConnectWithoutFgInput | FG_PRODUCTSCreateOrConnectWithoutFgInput[]
    upsert?: FG_PRODUCTSUpsertWithWhereUniqueWithoutFgInput | FG_PRODUCTSUpsertWithWhereUniqueWithoutFgInput[]
    createMany?: FG_PRODUCTSCreateManyFgInputEnvelope
    set?: FG_PRODUCTSWhereUniqueInput | FG_PRODUCTSWhereUniqueInput[]
    disconnect?: FG_PRODUCTSWhereUniqueInput | FG_PRODUCTSWhereUniqueInput[]
    delete?: FG_PRODUCTSWhereUniqueInput | FG_PRODUCTSWhereUniqueInput[]
    connect?: FG_PRODUCTSWhereUniqueInput | FG_PRODUCTSWhereUniqueInput[]
    update?: FG_PRODUCTSUpdateWithWhereUniqueWithoutFgInput | FG_PRODUCTSUpdateWithWhereUniqueWithoutFgInput[]
    updateMany?: FG_PRODUCTSUpdateManyWithWhereWithoutFgInput | FG_PRODUCTSUpdateManyWithWhereWithoutFgInput[]
    deleteMany?: FG_PRODUCTSScalarWhereInput | FG_PRODUCTSScalarWhereInput[]
  }

  export type FGCreateNestedOneWithoutFgProductsInput = {
    create?: XOR<FGCreateWithoutFgProductsInput, FGUncheckedCreateWithoutFgProductsInput>
    connectOrCreate?: FGCreateOrConnectWithoutFgProductsInput
    connect?: FGWhereUniqueInput
  }

  export type FGUpdateOneRequiredWithoutFgProductsNestedInput = {
    create?: XOR<FGCreateWithoutFgProductsInput, FGUncheckedCreateWithoutFgProductsInput>
    connectOrCreate?: FGCreateOrConnectWithoutFgProductsInput
    upsert?: FGUpsertWithoutFgProductsInput
    connect?: FGWhereUniqueInput
    update?: XOR<XOR<FGUpdateToOneWithWhereWithoutFgProductsInput, FGUpdateWithoutFgProductsInput>, FGUncheckedUpdateWithoutFgProductsInput>
  }

  export type WIPCreateNestedOneWithoutWIPTransactionsInput = {
    create?: XOR<WIPCreateWithoutWIPTransactionsInput, WIPUncheckedCreateWithoutWIPTransactionsInput>
    connectOrCreate?: WIPCreateOrConnectWithoutWIPTransactionsInput
    connect?: WIPWhereUniqueInput
  }

  export type EmployeeCreateNestedOneWithoutWIPTransactionsInput = {
    create?: XOR<EmployeeCreateWithoutWIPTransactionsInput, EmployeeUncheckedCreateWithoutWIPTransactionsInput>
    connectOrCreate?: EmployeeCreateOrConnectWithoutWIPTransactionsInput
    connect?: EmployeeWhereUniqueInput
  }

  export type WIP_QCCreateNestedManyWithoutWIPTransactionsInput = {
    create?: XOR<WIP_QCCreateWithoutWIPTransactionsInput, WIP_QCUncheckedCreateWithoutWIPTransactionsInput> | WIP_QCCreateWithoutWIPTransactionsInput[] | WIP_QCUncheckedCreateWithoutWIPTransactionsInput[]
    connectOrCreate?: WIP_QCCreateOrConnectWithoutWIPTransactionsInput | WIP_QCCreateOrConnectWithoutWIPTransactionsInput[]
    createMany?: WIP_QCCreateManyWIPTransactionsInputEnvelope
    connect?: WIP_QCWhereUniqueInput | WIP_QCWhereUniqueInput[]
  }

  export type WIP_WASTAGE_LOGSCreateNestedManyWithoutWIPTransactionsInput = {
    create?: XOR<WIP_WASTAGE_LOGSCreateWithoutWIPTransactionsInput, WIP_WASTAGE_LOGSUncheckedCreateWithoutWIPTransactionsInput> | WIP_WASTAGE_LOGSCreateWithoutWIPTransactionsInput[] | WIP_WASTAGE_LOGSUncheckedCreateWithoutWIPTransactionsInput[]
    connectOrCreate?: WIP_WASTAGE_LOGSCreateOrConnectWithoutWIPTransactionsInput | WIP_WASTAGE_LOGSCreateOrConnectWithoutWIPTransactionsInput[]
    createMany?: WIP_WASTAGE_LOGSCreateManyWIPTransactionsInputEnvelope
    connect?: WIP_WASTAGE_LOGSWhereUniqueInput | WIP_WASTAGE_LOGSWhereUniqueInput[]
  }

  export type WIP_QCUncheckedCreateNestedManyWithoutWIPTransactionsInput = {
    create?: XOR<WIP_QCCreateWithoutWIPTransactionsInput, WIP_QCUncheckedCreateWithoutWIPTransactionsInput> | WIP_QCCreateWithoutWIPTransactionsInput[] | WIP_QCUncheckedCreateWithoutWIPTransactionsInput[]
    connectOrCreate?: WIP_QCCreateOrConnectWithoutWIPTransactionsInput | WIP_QCCreateOrConnectWithoutWIPTransactionsInput[]
    createMany?: WIP_QCCreateManyWIPTransactionsInputEnvelope
    connect?: WIP_QCWhereUniqueInput | WIP_QCWhereUniqueInput[]
  }

  export type WIP_WASTAGE_LOGSUncheckedCreateNestedManyWithoutWIPTransactionsInput = {
    create?: XOR<WIP_WASTAGE_LOGSCreateWithoutWIPTransactionsInput, WIP_WASTAGE_LOGSUncheckedCreateWithoutWIPTransactionsInput> | WIP_WASTAGE_LOGSCreateWithoutWIPTransactionsInput[] | WIP_WASTAGE_LOGSUncheckedCreateWithoutWIPTransactionsInput[]
    connectOrCreate?: WIP_WASTAGE_LOGSCreateOrConnectWithoutWIPTransactionsInput | WIP_WASTAGE_LOGSCreateOrConnectWithoutWIPTransactionsInput[]
    createMany?: WIP_WASTAGE_LOGSCreateManyWIPTransactionsInputEnvelope
    connect?: WIP_WASTAGE_LOGSWhereUniqueInput | WIP_WASTAGE_LOGSWhereUniqueInput[]
  }

  export type WIPUpdateOneRequiredWithoutWIPTransactionsNestedInput = {
    create?: XOR<WIPCreateWithoutWIPTransactionsInput, WIPUncheckedCreateWithoutWIPTransactionsInput>
    connectOrCreate?: WIPCreateOrConnectWithoutWIPTransactionsInput
    upsert?: WIPUpsertWithoutWIPTransactionsInput
    connect?: WIPWhereUniqueInput
    update?: XOR<XOR<WIPUpdateToOneWithWhereWithoutWIPTransactionsInput, WIPUpdateWithoutWIPTransactionsInput>, WIPUncheckedUpdateWithoutWIPTransactionsInput>
  }

  export type EmployeeUpdateOneRequiredWithoutWIPTransactionsNestedInput = {
    create?: XOR<EmployeeCreateWithoutWIPTransactionsInput, EmployeeUncheckedCreateWithoutWIPTransactionsInput>
    connectOrCreate?: EmployeeCreateOrConnectWithoutWIPTransactionsInput
    upsert?: EmployeeUpsertWithoutWIPTransactionsInput
    connect?: EmployeeWhereUniqueInput
    update?: XOR<XOR<EmployeeUpdateToOneWithWhereWithoutWIPTransactionsInput, EmployeeUpdateWithoutWIPTransactionsInput>, EmployeeUncheckedUpdateWithoutWIPTransactionsInput>
  }

  export type WIP_QCUpdateManyWithoutWIPTransactionsNestedInput = {
    create?: XOR<WIP_QCCreateWithoutWIPTransactionsInput, WIP_QCUncheckedCreateWithoutWIPTransactionsInput> | WIP_QCCreateWithoutWIPTransactionsInput[] | WIP_QCUncheckedCreateWithoutWIPTransactionsInput[]
    connectOrCreate?: WIP_QCCreateOrConnectWithoutWIPTransactionsInput | WIP_QCCreateOrConnectWithoutWIPTransactionsInput[]
    upsert?: WIP_QCUpsertWithWhereUniqueWithoutWIPTransactionsInput | WIP_QCUpsertWithWhereUniqueWithoutWIPTransactionsInput[]
    createMany?: WIP_QCCreateManyWIPTransactionsInputEnvelope
    set?: WIP_QCWhereUniqueInput | WIP_QCWhereUniqueInput[]
    disconnect?: WIP_QCWhereUniqueInput | WIP_QCWhereUniqueInput[]
    delete?: WIP_QCWhereUniqueInput | WIP_QCWhereUniqueInput[]
    connect?: WIP_QCWhereUniqueInput | WIP_QCWhereUniqueInput[]
    update?: WIP_QCUpdateWithWhereUniqueWithoutWIPTransactionsInput | WIP_QCUpdateWithWhereUniqueWithoutWIPTransactionsInput[]
    updateMany?: WIP_QCUpdateManyWithWhereWithoutWIPTransactionsInput | WIP_QCUpdateManyWithWhereWithoutWIPTransactionsInput[]
    deleteMany?: WIP_QCScalarWhereInput | WIP_QCScalarWhereInput[]
  }

  export type WIP_WASTAGE_LOGSUpdateManyWithoutWIPTransactionsNestedInput = {
    create?: XOR<WIP_WASTAGE_LOGSCreateWithoutWIPTransactionsInput, WIP_WASTAGE_LOGSUncheckedCreateWithoutWIPTransactionsInput> | WIP_WASTAGE_LOGSCreateWithoutWIPTransactionsInput[] | WIP_WASTAGE_LOGSUncheckedCreateWithoutWIPTransactionsInput[]
    connectOrCreate?: WIP_WASTAGE_LOGSCreateOrConnectWithoutWIPTransactionsInput | WIP_WASTAGE_LOGSCreateOrConnectWithoutWIPTransactionsInput[]
    upsert?: WIP_WASTAGE_LOGSUpsertWithWhereUniqueWithoutWIPTransactionsInput | WIP_WASTAGE_LOGSUpsertWithWhereUniqueWithoutWIPTransactionsInput[]
    createMany?: WIP_WASTAGE_LOGSCreateManyWIPTransactionsInputEnvelope
    set?: WIP_WASTAGE_LOGSWhereUniqueInput | WIP_WASTAGE_LOGSWhereUniqueInput[]
    disconnect?: WIP_WASTAGE_LOGSWhereUniqueInput | WIP_WASTAGE_LOGSWhereUniqueInput[]
    delete?: WIP_WASTAGE_LOGSWhereUniqueInput | WIP_WASTAGE_LOGSWhereUniqueInput[]
    connect?: WIP_WASTAGE_LOGSWhereUniqueInput | WIP_WASTAGE_LOGSWhereUniqueInput[]
    update?: WIP_WASTAGE_LOGSUpdateWithWhereUniqueWithoutWIPTransactionsInput | WIP_WASTAGE_LOGSUpdateWithWhereUniqueWithoutWIPTransactionsInput[]
    updateMany?: WIP_WASTAGE_LOGSUpdateManyWithWhereWithoutWIPTransactionsInput | WIP_WASTAGE_LOGSUpdateManyWithWhereWithoutWIPTransactionsInput[]
    deleteMany?: WIP_WASTAGE_LOGSScalarWhereInput | WIP_WASTAGE_LOGSScalarWhereInput[]
  }

  export type WIP_QCUncheckedUpdateManyWithoutWIPTransactionsNestedInput = {
    create?: XOR<WIP_QCCreateWithoutWIPTransactionsInput, WIP_QCUncheckedCreateWithoutWIPTransactionsInput> | WIP_QCCreateWithoutWIPTransactionsInput[] | WIP_QCUncheckedCreateWithoutWIPTransactionsInput[]
    connectOrCreate?: WIP_QCCreateOrConnectWithoutWIPTransactionsInput | WIP_QCCreateOrConnectWithoutWIPTransactionsInput[]
    upsert?: WIP_QCUpsertWithWhereUniqueWithoutWIPTransactionsInput | WIP_QCUpsertWithWhereUniqueWithoutWIPTransactionsInput[]
    createMany?: WIP_QCCreateManyWIPTransactionsInputEnvelope
    set?: WIP_QCWhereUniqueInput | WIP_QCWhereUniqueInput[]
    disconnect?: WIP_QCWhereUniqueInput | WIP_QCWhereUniqueInput[]
    delete?: WIP_QCWhereUniqueInput | WIP_QCWhereUniqueInput[]
    connect?: WIP_QCWhereUniqueInput | WIP_QCWhereUniqueInput[]
    update?: WIP_QCUpdateWithWhereUniqueWithoutWIPTransactionsInput | WIP_QCUpdateWithWhereUniqueWithoutWIPTransactionsInput[]
    updateMany?: WIP_QCUpdateManyWithWhereWithoutWIPTransactionsInput | WIP_QCUpdateManyWithWhereWithoutWIPTransactionsInput[]
    deleteMany?: WIP_QCScalarWhereInput | WIP_QCScalarWhereInput[]
  }

  export type WIP_WASTAGE_LOGSUncheckedUpdateManyWithoutWIPTransactionsNestedInput = {
    create?: XOR<WIP_WASTAGE_LOGSCreateWithoutWIPTransactionsInput, WIP_WASTAGE_LOGSUncheckedCreateWithoutWIPTransactionsInput> | WIP_WASTAGE_LOGSCreateWithoutWIPTransactionsInput[] | WIP_WASTAGE_LOGSUncheckedCreateWithoutWIPTransactionsInput[]
    connectOrCreate?: WIP_WASTAGE_LOGSCreateOrConnectWithoutWIPTransactionsInput | WIP_WASTAGE_LOGSCreateOrConnectWithoutWIPTransactionsInput[]
    upsert?: WIP_WASTAGE_LOGSUpsertWithWhereUniqueWithoutWIPTransactionsInput | WIP_WASTAGE_LOGSUpsertWithWhereUniqueWithoutWIPTransactionsInput[]
    createMany?: WIP_WASTAGE_LOGSCreateManyWIPTransactionsInputEnvelope
    set?: WIP_WASTAGE_LOGSWhereUniqueInput | WIP_WASTAGE_LOGSWhereUniqueInput[]
    disconnect?: WIP_WASTAGE_LOGSWhereUniqueInput | WIP_WASTAGE_LOGSWhereUniqueInput[]
    delete?: WIP_WASTAGE_LOGSWhereUniqueInput | WIP_WASTAGE_LOGSWhereUniqueInput[]
    connect?: WIP_WASTAGE_LOGSWhereUniqueInput | WIP_WASTAGE_LOGSWhereUniqueInput[]
    update?: WIP_WASTAGE_LOGSUpdateWithWhereUniqueWithoutWIPTransactionsInput | WIP_WASTAGE_LOGSUpdateWithWhereUniqueWithoutWIPTransactionsInput[]
    updateMany?: WIP_WASTAGE_LOGSUpdateManyWithWhereWithoutWIPTransactionsInput | WIP_WASTAGE_LOGSUpdateManyWithWhereWithoutWIPTransactionsInput[]
    deleteMany?: WIP_WASTAGE_LOGSScalarWhereInput | WIP_WASTAGE_LOGSScalarWhereInput[]
  }

  export type FGCreateNestedOneWithoutFGTransactionsInput = {
    create?: XOR<FGCreateWithoutFGTransactionsInput, FGUncheckedCreateWithoutFGTransactionsInput>
    connectOrCreate?: FGCreateOrConnectWithoutFGTransactionsInput
    connect?: FGWhereUniqueInput
  }

  export type EmployeeCreateNestedOneWithoutFGTransactionsInput = {
    create?: XOR<EmployeeCreateWithoutFGTransactionsInput, EmployeeUncheckedCreateWithoutFGTransactionsInput>
    connectOrCreate?: EmployeeCreateOrConnectWithoutFGTransactionsInput
    connect?: EmployeeWhereUniqueInput
  }

  export type FG_QCCreateNestedManyWithoutFGTransactionsInput = {
    create?: XOR<FG_QCCreateWithoutFGTransactionsInput, FG_QCUncheckedCreateWithoutFGTransactionsInput> | FG_QCCreateWithoutFGTransactionsInput[] | FG_QCUncheckedCreateWithoutFGTransactionsInput[]
    connectOrCreate?: FG_QCCreateOrConnectWithoutFGTransactionsInput | FG_QCCreateOrConnectWithoutFGTransactionsInput[]
    createMany?: FG_QCCreateManyFGTransactionsInputEnvelope
    connect?: FG_QCWhereUniqueInput | FG_QCWhereUniqueInput[]
  }

  export type FG_WASTAGE_LOGSCreateNestedManyWithoutFGTransactionsInput = {
    create?: XOR<FG_WASTAGE_LOGSCreateWithoutFGTransactionsInput, FG_WASTAGE_LOGSUncheckedCreateWithoutFGTransactionsInput> | FG_WASTAGE_LOGSCreateWithoutFGTransactionsInput[] | FG_WASTAGE_LOGSUncheckedCreateWithoutFGTransactionsInput[]
    connectOrCreate?: FG_WASTAGE_LOGSCreateOrConnectWithoutFGTransactionsInput | FG_WASTAGE_LOGSCreateOrConnectWithoutFGTransactionsInput[]
    createMany?: FG_WASTAGE_LOGSCreateManyFGTransactionsInputEnvelope
    connect?: FG_WASTAGE_LOGSWhereUniqueInput | FG_WASTAGE_LOGSWhereUniqueInput[]
  }

  export type FG_QCUncheckedCreateNestedManyWithoutFGTransactionsInput = {
    create?: XOR<FG_QCCreateWithoutFGTransactionsInput, FG_QCUncheckedCreateWithoutFGTransactionsInput> | FG_QCCreateWithoutFGTransactionsInput[] | FG_QCUncheckedCreateWithoutFGTransactionsInput[]
    connectOrCreate?: FG_QCCreateOrConnectWithoutFGTransactionsInput | FG_QCCreateOrConnectWithoutFGTransactionsInput[]
    createMany?: FG_QCCreateManyFGTransactionsInputEnvelope
    connect?: FG_QCWhereUniqueInput | FG_QCWhereUniqueInput[]
  }

  export type FG_WASTAGE_LOGSUncheckedCreateNestedManyWithoutFGTransactionsInput = {
    create?: XOR<FG_WASTAGE_LOGSCreateWithoutFGTransactionsInput, FG_WASTAGE_LOGSUncheckedCreateWithoutFGTransactionsInput> | FG_WASTAGE_LOGSCreateWithoutFGTransactionsInput[] | FG_WASTAGE_LOGSUncheckedCreateWithoutFGTransactionsInput[]
    connectOrCreate?: FG_WASTAGE_LOGSCreateOrConnectWithoutFGTransactionsInput | FG_WASTAGE_LOGSCreateOrConnectWithoutFGTransactionsInput[]
    createMany?: FG_WASTAGE_LOGSCreateManyFGTransactionsInputEnvelope
    connect?: FG_WASTAGE_LOGSWhereUniqueInput | FG_WASTAGE_LOGSWhereUniqueInput[]
  }

  export type FGUpdateOneRequiredWithoutFGTransactionsNestedInput = {
    create?: XOR<FGCreateWithoutFGTransactionsInput, FGUncheckedCreateWithoutFGTransactionsInput>
    connectOrCreate?: FGCreateOrConnectWithoutFGTransactionsInput
    upsert?: FGUpsertWithoutFGTransactionsInput
    connect?: FGWhereUniqueInput
    update?: XOR<XOR<FGUpdateToOneWithWhereWithoutFGTransactionsInput, FGUpdateWithoutFGTransactionsInput>, FGUncheckedUpdateWithoutFGTransactionsInput>
  }

  export type EmployeeUpdateOneRequiredWithoutFGTransactionsNestedInput = {
    create?: XOR<EmployeeCreateWithoutFGTransactionsInput, EmployeeUncheckedCreateWithoutFGTransactionsInput>
    connectOrCreate?: EmployeeCreateOrConnectWithoutFGTransactionsInput
    upsert?: EmployeeUpsertWithoutFGTransactionsInput
    connect?: EmployeeWhereUniqueInput
    update?: XOR<XOR<EmployeeUpdateToOneWithWhereWithoutFGTransactionsInput, EmployeeUpdateWithoutFGTransactionsInput>, EmployeeUncheckedUpdateWithoutFGTransactionsInput>
  }

  export type FG_QCUpdateManyWithoutFGTransactionsNestedInput = {
    create?: XOR<FG_QCCreateWithoutFGTransactionsInput, FG_QCUncheckedCreateWithoutFGTransactionsInput> | FG_QCCreateWithoutFGTransactionsInput[] | FG_QCUncheckedCreateWithoutFGTransactionsInput[]
    connectOrCreate?: FG_QCCreateOrConnectWithoutFGTransactionsInput | FG_QCCreateOrConnectWithoutFGTransactionsInput[]
    upsert?: FG_QCUpsertWithWhereUniqueWithoutFGTransactionsInput | FG_QCUpsertWithWhereUniqueWithoutFGTransactionsInput[]
    createMany?: FG_QCCreateManyFGTransactionsInputEnvelope
    set?: FG_QCWhereUniqueInput | FG_QCWhereUniqueInput[]
    disconnect?: FG_QCWhereUniqueInput | FG_QCWhereUniqueInput[]
    delete?: FG_QCWhereUniqueInput | FG_QCWhereUniqueInput[]
    connect?: FG_QCWhereUniqueInput | FG_QCWhereUniqueInput[]
    update?: FG_QCUpdateWithWhereUniqueWithoutFGTransactionsInput | FG_QCUpdateWithWhereUniqueWithoutFGTransactionsInput[]
    updateMany?: FG_QCUpdateManyWithWhereWithoutFGTransactionsInput | FG_QCUpdateManyWithWhereWithoutFGTransactionsInput[]
    deleteMany?: FG_QCScalarWhereInput | FG_QCScalarWhereInput[]
  }

  export type FG_WASTAGE_LOGSUpdateManyWithoutFGTransactionsNestedInput = {
    create?: XOR<FG_WASTAGE_LOGSCreateWithoutFGTransactionsInput, FG_WASTAGE_LOGSUncheckedCreateWithoutFGTransactionsInput> | FG_WASTAGE_LOGSCreateWithoutFGTransactionsInput[] | FG_WASTAGE_LOGSUncheckedCreateWithoutFGTransactionsInput[]
    connectOrCreate?: FG_WASTAGE_LOGSCreateOrConnectWithoutFGTransactionsInput | FG_WASTAGE_LOGSCreateOrConnectWithoutFGTransactionsInput[]
    upsert?: FG_WASTAGE_LOGSUpsertWithWhereUniqueWithoutFGTransactionsInput | FG_WASTAGE_LOGSUpsertWithWhereUniqueWithoutFGTransactionsInput[]
    createMany?: FG_WASTAGE_LOGSCreateManyFGTransactionsInputEnvelope
    set?: FG_WASTAGE_LOGSWhereUniqueInput | FG_WASTAGE_LOGSWhereUniqueInput[]
    disconnect?: FG_WASTAGE_LOGSWhereUniqueInput | FG_WASTAGE_LOGSWhereUniqueInput[]
    delete?: FG_WASTAGE_LOGSWhereUniqueInput | FG_WASTAGE_LOGSWhereUniqueInput[]
    connect?: FG_WASTAGE_LOGSWhereUniqueInput | FG_WASTAGE_LOGSWhereUniqueInput[]
    update?: FG_WASTAGE_LOGSUpdateWithWhereUniqueWithoutFGTransactionsInput | FG_WASTAGE_LOGSUpdateWithWhereUniqueWithoutFGTransactionsInput[]
    updateMany?: FG_WASTAGE_LOGSUpdateManyWithWhereWithoutFGTransactionsInput | FG_WASTAGE_LOGSUpdateManyWithWhereWithoutFGTransactionsInput[]
    deleteMany?: FG_WASTAGE_LOGSScalarWhereInput | FG_WASTAGE_LOGSScalarWhereInput[]
  }

  export type FG_QCUncheckedUpdateManyWithoutFGTransactionsNestedInput = {
    create?: XOR<FG_QCCreateWithoutFGTransactionsInput, FG_QCUncheckedCreateWithoutFGTransactionsInput> | FG_QCCreateWithoutFGTransactionsInput[] | FG_QCUncheckedCreateWithoutFGTransactionsInput[]
    connectOrCreate?: FG_QCCreateOrConnectWithoutFGTransactionsInput | FG_QCCreateOrConnectWithoutFGTransactionsInput[]
    upsert?: FG_QCUpsertWithWhereUniqueWithoutFGTransactionsInput | FG_QCUpsertWithWhereUniqueWithoutFGTransactionsInput[]
    createMany?: FG_QCCreateManyFGTransactionsInputEnvelope
    set?: FG_QCWhereUniqueInput | FG_QCWhereUniqueInput[]
    disconnect?: FG_QCWhereUniqueInput | FG_QCWhereUniqueInput[]
    delete?: FG_QCWhereUniqueInput | FG_QCWhereUniqueInput[]
    connect?: FG_QCWhereUniqueInput | FG_QCWhereUniqueInput[]
    update?: FG_QCUpdateWithWhereUniqueWithoutFGTransactionsInput | FG_QCUpdateWithWhereUniqueWithoutFGTransactionsInput[]
    updateMany?: FG_QCUpdateManyWithWhereWithoutFGTransactionsInput | FG_QCUpdateManyWithWhereWithoutFGTransactionsInput[]
    deleteMany?: FG_QCScalarWhereInput | FG_QCScalarWhereInput[]
  }

  export type FG_WASTAGE_LOGSUncheckedUpdateManyWithoutFGTransactionsNestedInput = {
    create?: XOR<FG_WASTAGE_LOGSCreateWithoutFGTransactionsInput, FG_WASTAGE_LOGSUncheckedCreateWithoutFGTransactionsInput> | FG_WASTAGE_LOGSCreateWithoutFGTransactionsInput[] | FG_WASTAGE_LOGSUncheckedCreateWithoutFGTransactionsInput[]
    connectOrCreate?: FG_WASTAGE_LOGSCreateOrConnectWithoutFGTransactionsInput | FG_WASTAGE_LOGSCreateOrConnectWithoutFGTransactionsInput[]
    upsert?: FG_WASTAGE_LOGSUpsertWithWhereUniqueWithoutFGTransactionsInput | FG_WASTAGE_LOGSUpsertWithWhereUniqueWithoutFGTransactionsInput[]
    createMany?: FG_WASTAGE_LOGSCreateManyFGTransactionsInputEnvelope
    set?: FG_WASTAGE_LOGSWhereUniqueInput | FG_WASTAGE_LOGSWhereUniqueInput[]
    disconnect?: FG_WASTAGE_LOGSWhereUniqueInput | FG_WASTAGE_LOGSWhereUniqueInput[]
    delete?: FG_WASTAGE_LOGSWhereUniqueInput | FG_WASTAGE_LOGSWhereUniqueInput[]
    connect?: FG_WASTAGE_LOGSWhereUniqueInput | FG_WASTAGE_LOGSWhereUniqueInput[]
    update?: FG_WASTAGE_LOGSUpdateWithWhereUniqueWithoutFGTransactionsInput | FG_WASTAGE_LOGSUpdateWithWhereUniqueWithoutFGTransactionsInput[]
    updateMany?: FG_WASTAGE_LOGSUpdateManyWithWhereWithoutFGTransactionsInput | FG_WASTAGE_LOGSUpdateManyWithWhereWithoutFGTransactionsInput[]
    deleteMany?: FG_WASTAGE_LOGSScalarWhereInput | FG_WASTAGE_LOGSScalarWhereInput[]
  }

  export type WIPCreateNestedOneWithoutWIPQCsInput = {
    create?: XOR<WIPCreateWithoutWIPQCsInput, WIPUncheckedCreateWithoutWIPQCsInput>
    connectOrCreate?: WIPCreateOrConnectWithoutWIPQCsInput
    connect?: WIPWhereUniqueInput
  }

  export type WIP_TRANSACTIONSCreateNestedOneWithoutWipQCInput = {
    create?: XOR<WIP_TRANSACTIONSCreateWithoutWipQCInput, WIP_TRANSACTIONSUncheckedCreateWithoutWipQCInput>
    connectOrCreate?: WIP_TRANSACTIONSCreateOrConnectWithoutWipQCInput
    connect?: WIP_TRANSACTIONSWhereUniqueInput
  }

  export type WIPUpdateOneRequiredWithoutWIPQCsNestedInput = {
    create?: XOR<WIPCreateWithoutWIPQCsInput, WIPUncheckedCreateWithoutWIPQCsInput>
    connectOrCreate?: WIPCreateOrConnectWithoutWIPQCsInput
    upsert?: WIPUpsertWithoutWIPQCsInput
    connect?: WIPWhereUniqueInput
    update?: XOR<XOR<WIPUpdateToOneWithWhereWithoutWIPQCsInput, WIPUpdateWithoutWIPQCsInput>, WIPUncheckedUpdateWithoutWIPQCsInput>
  }

  export type WIP_TRANSACTIONSUpdateOneRequiredWithoutWipQCNestedInput = {
    create?: XOR<WIP_TRANSACTIONSCreateWithoutWipQCInput, WIP_TRANSACTIONSUncheckedCreateWithoutWipQCInput>
    connectOrCreate?: WIP_TRANSACTIONSCreateOrConnectWithoutWipQCInput
    upsert?: WIP_TRANSACTIONSUpsertWithoutWipQCInput
    connect?: WIP_TRANSACTIONSWhereUniqueInput
    update?: XOR<XOR<WIP_TRANSACTIONSUpdateToOneWithWhereWithoutWipQCInput, WIP_TRANSACTIONSUpdateWithoutWipQCInput>, WIP_TRANSACTIONSUncheckedUpdateWithoutWipQCInput>
  }

  export type FGCreateNestedOneWithoutFGQCsInput = {
    create?: XOR<FGCreateWithoutFGQCsInput, FGUncheckedCreateWithoutFGQCsInput>
    connectOrCreate?: FGCreateOrConnectWithoutFGQCsInput
    connect?: FGWhereUniqueInput
  }

  export type FG_TRANSACTIONSCreateNestedOneWithoutFgQCInput = {
    create?: XOR<FG_TRANSACTIONSCreateWithoutFgQCInput, FG_TRANSACTIONSUncheckedCreateWithoutFgQCInput>
    connectOrCreate?: FG_TRANSACTIONSCreateOrConnectWithoutFgQCInput
    connect?: FG_TRANSACTIONSWhereUniqueInput
  }

  export type FGUpdateOneRequiredWithoutFGQCsNestedInput = {
    create?: XOR<FGCreateWithoutFGQCsInput, FGUncheckedCreateWithoutFGQCsInput>
    connectOrCreate?: FGCreateOrConnectWithoutFGQCsInput
    upsert?: FGUpsertWithoutFGQCsInput
    connect?: FGWhereUniqueInput
    update?: XOR<XOR<FGUpdateToOneWithWhereWithoutFGQCsInput, FGUpdateWithoutFGQCsInput>, FGUncheckedUpdateWithoutFGQCsInput>
  }

  export type FG_TRANSACTIONSUpdateOneRequiredWithoutFgQCNestedInput = {
    create?: XOR<FG_TRANSACTIONSCreateWithoutFgQCInput, FG_TRANSACTIONSUncheckedCreateWithoutFgQCInput>
    connectOrCreate?: FG_TRANSACTIONSCreateOrConnectWithoutFgQCInput
    upsert?: FG_TRANSACTIONSUpsertWithoutFgQCInput
    connect?: FG_TRANSACTIONSWhereUniqueInput
    update?: XOR<XOR<FG_TRANSACTIONSUpdateToOneWithWhereWithoutFgQCInput, FG_TRANSACTIONSUpdateWithoutFgQCInput>, FG_TRANSACTIONSUncheckedUpdateWithoutFgQCInput>
  }

  export type WIPCreateNestedOneWithoutWIPWastageLogsInput = {
    create?: XOR<WIPCreateWithoutWIPWastageLogsInput, WIPUncheckedCreateWithoutWIPWastageLogsInput>
    connectOrCreate?: WIPCreateOrConnectWithoutWIPWastageLogsInput
    connect?: WIPWhereUniqueInput
  }

  export type WIP_TRANSACTIONSCreateNestedOneWithoutWipWasteLogsInput = {
    create?: XOR<WIP_TRANSACTIONSCreateWithoutWipWasteLogsInput, WIP_TRANSACTIONSUncheckedCreateWithoutWipWasteLogsInput>
    connectOrCreate?: WIP_TRANSACTIONSCreateOrConnectWithoutWipWasteLogsInput
    connect?: WIP_TRANSACTIONSWhereUniqueInput
  }

  export type WIPUpdateOneRequiredWithoutWIPWastageLogsNestedInput = {
    create?: XOR<WIPCreateWithoutWIPWastageLogsInput, WIPUncheckedCreateWithoutWIPWastageLogsInput>
    connectOrCreate?: WIPCreateOrConnectWithoutWIPWastageLogsInput
    upsert?: WIPUpsertWithoutWIPWastageLogsInput
    connect?: WIPWhereUniqueInput
    update?: XOR<XOR<WIPUpdateToOneWithWhereWithoutWIPWastageLogsInput, WIPUpdateWithoutWIPWastageLogsInput>, WIPUncheckedUpdateWithoutWIPWastageLogsInput>
  }

  export type WIP_TRANSACTIONSUpdateOneRequiredWithoutWipWasteLogsNestedInput = {
    create?: XOR<WIP_TRANSACTIONSCreateWithoutWipWasteLogsInput, WIP_TRANSACTIONSUncheckedCreateWithoutWipWasteLogsInput>
    connectOrCreate?: WIP_TRANSACTIONSCreateOrConnectWithoutWipWasteLogsInput
    upsert?: WIP_TRANSACTIONSUpsertWithoutWipWasteLogsInput
    connect?: WIP_TRANSACTIONSWhereUniqueInput
    update?: XOR<XOR<WIP_TRANSACTIONSUpdateToOneWithWhereWithoutWipWasteLogsInput, WIP_TRANSACTIONSUpdateWithoutWipWasteLogsInput>, WIP_TRANSACTIONSUncheckedUpdateWithoutWipWasteLogsInput>
  }

  export type FGCreateNestedOneWithoutFGWastageLogsInput = {
    create?: XOR<FGCreateWithoutFGWastageLogsInput, FGUncheckedCreateWithoutFGWastageLogsInput>
    connectOrCreate?: FGCreateOrConnectWithoutFGWastageLogsInput
    connect?: FGWhereUniqueInput
  }

  export type FG_TRANSACTIONSCreateNestedOneWithoutFgWasteLogsInput = {
    create?: XOR<FG_TRANSACTIONSCreateWithoutFgWasteLogsInput, FG_TRANSACTIONSUncheckedCreateWithoutFgWasteLogsInput>
    connectOrCreate?: FG_TRANSACTIONSCreateOrConnectWithoutFgWasteLogsInput
    connect?: FG_TRANSACTIONSWhereUniqueInput
  }

  export type FGUpdateOneRequiredWithoutFGWastageLogsNestedInput = {
    create?: XOR<FGCreateWithoutFGWastageLogsInput, FGUncheckedCreateWithoutFGWastageLogsInput>
    connectOrCreate?: FGCreateOrConnectWithoutFGWastageLogsInput
    upsert?: FGUpsertWithoutFGWastageLogsInput
    connect?: FGWhereUniqueInput
    update?: XOR<XOR<FGUpdateToOneWithWhereWithoutFGWastageLogsInput, FGUpdateWithoutFGWastageLogsInput>, FGUncheckedUpdateWithoutFGWastageLogsInput>
  }

  export type FG_TRANSACTIONSUpdateOneRequiredWithoutFgWasteLogsNestedInput = {
    create?: XOR<FG_TRANSACTIONSCreateWithoutFgWasteLogsInput, FG_TRANSACTIONSUncheckedCreateWithoutFgWasteLogsInput>
    connectOrCreate?: FG_TRANSACTIONSCreateOrConnectWithoutFgWasteLogsInput
    upsert?: FG_TRANSACTIONSUpsertWithoutFgWasteLogsInput
    connect?: FG_TRANSACTIONSWhereUniqueInput
    update?: XOR<XOR<FG_TRANSACTIONSUpdateToOneWithWhereWithoutFgWasteLogsInput, FG_TRANSACTIONSUpdateWithoutFgWasteLogsInput>, FG_TRANSACTIONSUncheckedUpdateWithoutFgWasteLogsInput>
  }

  export type EmployeeCreateNestedOneWithoutAuditLogsInput = {
    create?: XOR<EmployeeCreateWithoutAuditLogsInput, EmployeeUncheckedCreateWithoutAuditLogsInput>
    connectOrCreate?: EmployeeCreateOrConnectWithoutAuditLogsInput
    connect?: EmployeeWhereUniqueInput
  }

  export type EnumActionsFieldUpdateOperationsInput = {
    set?: $Enums.Actions
  }

  export type EmployeeUpdateOneRequiredWithoutAuditLogsNestedInput = {
    create?: XOR<EmployeeCreateWithoutAuditLogsInput, EmployeeUncheckedCreateWithoutAuditLogsInput>
    connectOrCreate?: EmployeeCreateOrConnectWithoutAuditLogsInput
    upsert?: EmployeeUpsertWithoutAuditLogsInput
    connect?: EmployeeWhereUniqueInput
    update?: XOR<XOR<EmployeeUpdateToOneWithWhereWithoutAuditLogsInput, EmployeeUpdateWithoutAuditLogsInput>, EmployeeUncheckedUpdateWithoutAuditLogsInput>
  }

  export type NestedBigIntFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[]
    notIn?: bigint[] | number[]
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntFilter<$PrismaModel> | bigint | number
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedDecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[]
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[]
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedEnumQualityStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.QualityStatus | EnumQualityStatusFieldRefInput<$PrismaModel>
    in?: $Enums.QualityStatus[]
    notIn?: $Enums.QualityStatus[]
    not?: NestedEnumQualityStatusFilter<$PrismaModel> | $Enums.QualityStatus
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedBigIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[]
    notIn?: bigint[] | number[]
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntWithAggregatesFilter<$PrismaModel> | bigint | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedBigIntFilter<$PrismaModel>
    _min?: NestedBigIntFilter<$PrismaModel>
    _max?: NestedBigIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedDecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[]
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[]
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedEnumQualityStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.QualityStatus | EnumQualityStatusFieldRefInput<$PrismaModel>
    in?: $Enums.QualityStatus[]
    notIn?: $Enums.QualityStatus[]
    not?: NestedEnumQualityStatusWithAggregatesFilter<$PrismaModel> | $Enums.QualityStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumQualityStatusFilter<$PrismaModel>
    _max?: NestedEnumQualityStatusFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedEnumTransactionTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.TransactionType | EnumTransactionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TransactionType[]
    notIn?: $Enums.TransactionType[]
    not?: NestedEnumTransactionTypeFilter<$PrismaModel> | $Enums.TransactionType
  }

  export type NestedEnumTransactionTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TransactionType | EnumTransactionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TransactionType[]
    notIn?: $Enums.TransactionType[]
    not?: NestedEnumTransactionTypeWithAggregatesFilter<$PrismaModel> | $Enums.TransactionType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTransactionTypeFilter<$PrismaModel>
    _max?: NestedEnumTransactionTypeFilter<$PrismaModel>
  }

  export type NestedEnumRolesFilter<$PrismaModel = never> = {
    equals?: $Enums.Roles | EnumRolesFieldRefInput<$PrismaModel>
    in?: $Enums.Roles[]
    notIn?: $Enums.Roles[]
    not?: NestedEnumRolesFilter<$PrismaModel> | $Enums.Roles
  }

  export type NestedEnumRolesWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Roles | EnumRolesFieldRefInput<$PrismaModel>
    in?: $Enums.Roles[]
    notIn?: $Enums.Roles[]
    not?: NestedEnumRolesWithAggregatesFilter<$PrismaModel> | $Enums.Roles
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRolesFilter<$PrismaModel>
    _max?: NestedEnumRolesFilter<$PrismaModel>
  }

  export type NestedEnumStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.Status | EnumStatusFieldRefInput<$PrismaModel>
    in?: $Enums.Status[]
    notIn?: $Enums.Status[]
    not?: NestedEnumStatusFilter<$PrismaModel> | $Enums.Status
  }

  export type NestedEnumStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Status | EnumStatusFieldRefInput<$PrismaModel>
    in?: $Enums.Status[]
    notIn?: $Enums.Status[]
    not?: NestedEnumStatusWithAggregatesFilter<$PrismaModel> | $Enums.Status
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumStatusFilter<$PrismaModel>
    _max?: NestedEnumStatusFilter<$PrismaModel>
  }

  export type NestedEnumActionsFilter<$PrismaModel = never> = {
    equals?: $Enums.Actions | EnumActionsFieldRefInput<$PrismaModel>
    in?: $Enums.Actions[]
    notIn?: $Enums.Actions[]
    not?: NestedEnumActionsFilter<$PrismaModel> | $Enums.Actions
  }

  export type NestedEnumActionsWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Actions | EnumActionsFieldRefInput<$PrismaModel>
    in?: $Enums.Actions[]
    notIn?: $Enums.Actions[]
    not?: NestedEnumActionsWithAggregatesFilter<$PrismaModel> | $Enums.Actions
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumActionsFilter<$PrismaModel>
    _max?: NestedEnumActionsFilter<$PrismaModel>
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue
    lte?: InputJsonValue
    gt?: InputJsonValue
    gte?: InputJsonValue
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type VARIANT_RAW_MATERIALS_TRACKERCreateWithoutRawMaterialInput = {
    avgQuantity: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    variant: SHOPIFY_VARIANTSCreateNestedOneWithoutVariantMaterialsInput
  }

  export type VARIANT_RAW_MATERIALS_TRACKERUncheckedCreateWithoutRawMaterialInput = {
    variantId: bigint | number
    avgQuantity: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type VARIANT_RAW_MATERIALS_TRACKERCreateOrConnectWithoutRawMaterialInput = {
    where: VARIANT_RAW_MATERIALS_TRACKERWhereUniqueInput
    create: XOR<VARIANT_RAW_MATERIALS_TRACKERCreateWithoutRawMaterialInput, VARIANT_RAW_MATERIALS_TRACKERUncheckedCreateWithoutRawMaterialInput>
  }

  export type VARIANT_RAW_MATERIALS_TRACKERCreateManyRawMaterialInputEnvelope = {
    data: VARIANT_RAW_MATERIALS_TRACKERCreateManyRawMaterialInput | VARIANT_RAW_MATERIALS_TRACKERCreateManyRawMaterialInput[]
    skipDuplicates?: boolean
  }

  export type RM_TRANSACTIONSCreateWithoutRawMaterialInput = {
    quantity: number
    transactionType: $Enums.TransactionType
    reason: string
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    initiatedBy: EmployeeCreateNestedOneWithoutRMTransactionsInput
    RMQualityChecks?: RM_QCCreateNestedManyWithoutTransactionInput
    RMWastageLogs?: RM_WASTAGE_LOGSCreateNestedManyWithoutTransactionInput
  }

  export type RM_TRANSACTIONSUncheckedCreateWithoutRawMaterialInput = {
    id?: number
    quantity: number
    transactionType: $Enums.TransactionType
    reason: string
    status: string
    initiatedById: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    RMQualityChecks?: RM_QCUncheckedCreateNestedManyWithoutTransactionInput
    RMWastageLogs?: RM_WASTAGE_LOGSUncheckedCreateNestedManyWithoutTransactionInput
  }

  export type RM_TRANSACTIONSCreateOrConnectWithoutRawMaterialInput = {
    where: RM_TRANSACTIONSWhereUniqueInput
    create: XOR<RM_TRANSACTIONSCreateWithoutRawMaterialInput, RM_TRANSACTIONSUncheckedCreateWithoutRawMaterialInput>
  }

  export type RM_TRANSACTIONSCreateManyRawMaterialInputEnvelope = {
    data: RM_TRANSACTIONSCreateManyRawMaterialInput | RM_TRANSACTIONSCreateManyRawMaterialInput[]
    skipDuplicates?: boolean
  }

  export type RM_QCCreateWithoutRawMaterialInput = {
    quality_status: $Enums.QualityStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    transaction: RM_TRANSACTIONSCreateNestedOneWithoutRMQualityChecksInput
    checkedBy: EmployeeCreateNestedOneWithoutRM_QCInput
    doneBy: EmployeeCreateNestedOneWithoutRM_QC2Input
  }

  export type RM_QCUncheckedCreateWithoutRawMaterialInput = {
    id?: number
    transactionId: number
    quality_status: $Enums.QualityStatus
    checkedById: number
    doneById: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type RM_QCCreateOrConnectWithoutRawMaterialInput = {
    where: RM_QCWhereUniqueInput
    create: XOR<RM_QCCreateWithoutRawMaterialInput, RM_QCUncheckedCreateWithoutRawMaterialInput>
  }

  export type RM_QCCreateManyRawMaterialInputEnvelope = {
    data: RM_QCCreateManyRawMaterialInput | RM_QCCreateManyRawMaterialInput[]
    skipDuplicates?: boolean
  }

  export type RM_WASTAGE_LOGSCreateWithoutRawMaterialInput = {
    quantity: number
    reason: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    transaction: RM_TRANSACTIONSCreateNestedOneWithoutRMWastageLogsInput
  }

  export type RM_WASTAGE_LOGSUncheckedCreateWithoutRawMaterialInput = {
    id?: number
    transactionId: number
    quantity: number
    reason: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type RM_WASTAGE_LOGSCreateOrConnectWithoutRawMaterialInput = {
    where: RM_WASTAGE_LOGSWhereUniqueInput
    create: XOR<RM_WASTAGE_LOGSCreateWithoutRawMaterialInput, RM_WASTAGE_LOGSUncheckedCreateWithoutRawMaterialInput>
  }

  export type RM_WASTAGE_LOGSCreateManyRawMaterialInputEnvelope = {
    data: RM_WASTAGE_LOGSCreateManyRawMaterialInput | RM_WASTAGE_LOGSCreateManyRawMaterialInput[]
    skipDuplicates?: boolean
  }

  export type WIPRawMaterialCreateWithoutRawMaterialInput = {
    quantity: number
    wip: WIPCreateNestedOneWithoutWIPMaterialsInput
  }

  export type WIPRawMaterialUncheckedCreateWithoutRawMaterialInput = {
    id?: number
    wipId: number
    quantity: number
  }

  export type WIPRawMaterialCreateOrConnectWithoutRawMaterialInput = {
    where: WIPRawMaterialWhereUniqueInput
    create: XOR<WIPRawMaterialCreateWithoutRawMaterialInput, WIPRawMaterialUncheckedCreateWithoutRawMaterialInput>
  }

  export type WIPRawMaterialCreateManyRawMaterialInputEnvelope = {
    data: WIPRawMaterialCreateManyRawMaterialInput | WIPRawMaterialCreateManyRawMaterialInput[]
    skipDuplicates?: boolean
  }

  export type VARIANT_RAW_MATERIALS_TRACKERUpsertWithWhereUniqueWithoutRawMaterialInput = {
    where: VARIANT_RAW_MATERIALS_TRACKERWhereUniqueInput
    update: XOR<VARIANT_RAW_MATERIALS_TRACKERUpdateWithoutRawMaterialInput, VARIANT_RAW_MATERIALS_TRACKERUncheckedUpdateWithoutRawMaterialInput>
    create: XOR<VARIANT_RAW_MATERIALS_TRACKERCreateWithoutRawMaterialInput, VARIANT_RAW_MATERIALS_TRACKERUncheckedCreateWithoutRawMaterialInput>
  }

  export type VARIANT_RAW_MATERIALS_TRACKERUpdateWithWhereUniqueWithoutRawMaterialInput = {
    where: VARIANT_RAW_MATERIALS_TRACKERWhereUniqueInput
    data: XOR<VARIANT_RAW_MATERIALS_TRACKERUpdateWithoutRawMaterialInput, VARIANT_RAW_MATERIALS_TRACKERUncheckedUpdateWithoutRawMaterialInput>
  }

  export type VARIANT_RAW_MATERIALS_TRACKERUpdateManyWithWhereWithoutRawMaterialInput = {
    where: VARIANT_RAW_MATERIALS_TRACKERScalarWhereInput
    data: XOR<VARIANT_RAW_MATERIALS_TRACKERUpdateManyMutationInput, VARIANT_RAW_MATERIALS_TRACKERUncheckedUpdateManyWithoutRawMaterialInput>
  }

  export type VARIANT_RAW_MATERIALS_TRACKERScalarWhereInput = {
    AND?: VARIANT_RAW_MATERIALS_TRACKERScalarWhereInput | VARIANT_RAW_MATERIALS_TRACKERScalarWhereInput[]
    OR?: VARIANT_RAW_MATERIALS_TRACKERScalarWhereInput[]
    NOT?: VARIANT_RAW_MATERIALS_TRACKERScalarWhereInput | VARIANT_RAW_MATERIALS_TRACKERScalarWhereInput[]
    variantId?: BigIntFilter<"VARIANT_RAW_MATERIALS_TRACKER"> | bigint | number
    rawMaterialId?: BigIntFilter<"VARIANT_RAW_MATERIALS_TRACKER"> | bigint | number
    avgQuantity?: DecimalFilter<"VARIANT_RAW_MATERIALS_TRACKER"> | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFilter<"VARIANT_RAW_MATERIALS_TRACKER"> | Date | string
    updatedAt?: DateTimeFilter<"VARIANT_RAW_MATERIALS_TRACKER"> | Date | string
    deletedAt?: DateTimeNullableFilter<"VARIANT_RAW_MATERIALS_TRACKER"> | Date | string | null
  }

  export type RM_TRANSACTIONSUpsertWithWhereUniqueWithoutRawMaterialInput = {
    where: RM_TRANSACTIONSWhereUniqueInput
    update: XOR<RM_TRANSACTIONSUpdateWithoutRawMaterialInput, RM_TRANSACTIONSUncheckedUpdateWithoutRawMaterialInput>
    create: XOR<RM_TRANSACTIONSCreateWithoutRawMaterialInput, RM_TRANSACTIONSUncheckedCreateWithoutRawMaterialInput>
  }

  export type RM_TRANSACTIONSUpdateWithWhereUniqueWithoutRawMaterialInput = {
    where: RM_TRANSACTIONSWhereUniqueInput
    data: XOR<RM_TRANSACTIONSUpdateWithoutRawMaterialInput, RM_TRANSACTIONSUncheckedUpdateWithoutRawMaterialInput>
  }

  export type RM_TRANSACTIONSUpdateManyWithWhereWithoutRawMaterialInput = {
    where: RM_TRANSACTIONSScalarWhereInput
    data: XOR<RM_TRANSACTIONSUpdateManyMutationInput, RM_TRANSACTIONSUncheckedUpdateManyWithoutRawMaterialInput>
  }

  export type RM_TRANSACTIONSScalarWhereInput = {
    AND?: RM_TRANSACTIONSScalarWhereInput | RM_TRANSACTIONSScalarWhereInput[]
    OR?: RM_TRANSACTIONSScalarWhereInput[]
    NOT?: RM_TRANSACTIONSScalarWhereInput | RM_TRANSACTIONSScalarWhereInput[]
    id?: IntFilter<"RM_TRANSACTIONS"> | number
    rawMaterialId?: BigIntFilter<"RM_TRANSACTIONS"> | bigint | number
    quantity?: IntFilter<"RM_TRANSACTIONS"> | number
    transactionType?: EnumTransactionTypeFilter<"RM_TRANSACTIONS"> | $Enums.TransactionType
    reason?: StringFilter<"RM_TRANSACTIONS"> | string
    status?: StringFilter<"RM_TRANSACTIONS"> | string
    initiatedById?: IntFilter<"RM_TRANSACTIONS"> | number
    createdAt?: DateTimeFilter<"RM_TRANSACTIONS"> | Date | string
    updatedAt?: DateTimeFilter<"RM_TRANSACTIONS"> | Date | string
    deletedAt?: DateTimeNullableFilter<"RM_TRANSACTIONS"> | Date | string | null
  }

  export type RM_QCUpsertWithWhereUniqueWithoutRawMaterialInput = {
    where: RM_QCWhereUniqueInput
    update: XOR<RM_QCUpdateWithoutRawMaterialInput, RM_QCUncheckedUpdateWithoutRawMaterialInput>
    create: XOR<RM_QCCreateWithoutRawMaterialInput, RM_QCUncheckedCreateWithoutRawMaterialInput>
  }

  export type RM_QCUpdateWithWhereUniqueWithoutRawMaterialInput = {
    where: RM_QCWhereUniqueInput
    data: XOR<RM_QCUpdateWithoutRawMaterialInput, RM_QCUncheckedUpdateWithoutRawMaterialInput>
  }

  export type RM_QCUpdateManyWithWhereWithoutRawMaterialInput = {
    where: RM_QCScalarWhereInput
    data: XOR<RM_QCUpdateManyMutationInput, RM_QCUncheckedUpdateManyWithoutRawMaterialInput>
  }

  export type RM_QCScalarWhereInput = {
    AND?: RM_QCScalarWhereInput | RM_QCScalarWhereInput[]
    OR?: RM_QCScalarWhereInput[]
    NOT?: RM_QCScalarWhereInput | RM_QCScalarWhereInput[]
    id?: IntFilter<"RM_QC"> | number
    transactionId?: IntFilter<"RM_QC"> | number
    rawMaterialId?: BigIntFilter<"RM_QC"> | bigint | number
    quality_status?: EnumQualityStatusFilter<"RM_QC"> | $Enums.QualityStatus
    checkedById?: IntFilter<"RM_QC"> | number
    doneById?: IntFilter<"RM_QC"> | number
    createdAt?: DateTimeFilter<"RM_QC"> | Date | string
    updatedAt?: DateTimeFilter<"RM_QC"> | Date | string
    deletedAt?: DateTimeNullableFilter<"RM_QC"> | Date | string | null
  }

  export type RM_WASTAGE_LOGSUpsertWithWhereUniqueWithoutRawMaterialInput = {
    where: RM_WASTAGE_LOGSWhereUniqueInput
    update: XOR<RM_WASTAGE_LOGSUpdateWithoutRawMaterialInput, RM_WASTAGE_LOGSUncheckedUpdateWithoutRawMaterialInput>
    create: XOR<RM_WASTAGE_LOGSCreateWithoutRawMaterialInput, RM_WASTAGE_LOGSUncheckedCreateWithoutRawMaterialInput>
  }

  export type RM_WASTAGE_LOGSUpdateWithWhereUniqueWithoutRawMaterialInput = {
    where: RM_WASTAGE_LOGSWhereUniqueInput
    data: XOR<RM_WASTAGE_LOGSUpdateWithoutRawMaterialInput, RM_WASTAGE_LOGSUncheckedUpdateWithoutRawMaterialInput>
  }

  export type RM_WASTAGE_LOGSUpdateManyWithWhereWithoutRawMaterialInput = {
    where: RM_WASTAGE_LOGSScalarWhereInput
    data: XOR<RM_WASTAGE_LOGSUpdateManyMutationInput, RM_WASTAGE_LOGSUncheckedUpdateManyWithoutRawMaterialInput>
  }

  export type RM_WASTAGE_LOGSScalarWhereInput = {
    AND?: RM_WASTAGE_LOGSScalarWhereInput | RM_WASTAGE_LOGSScalarWhereInput[]
    OR?: RM_WASTAGE_LOGSScalarWhereInput[]
    NOT?: RM_WASTAGE_LOGSScalarWhereInput | RM_WASTAGE_LOGSScalarWhereInput[]
    id?: IntFilter<"RM_WASTAGE_LOGS"> | number
    transactionId?: IntFilter<"RM_WASTAGE_LOGS"> | number
    rawMaterialId?: BigIntFilter<"RM_WASTAGE_LOGS"> | bigint | number
    quantity?: IntFilter<"RM_WASTAGE_LOGS"> | number
    reason?: StringFilter<"RM_WASTAGE_LOGS"> | string
    createdAt?: DateTimeFilter<"RM_WASTAGE_LOGS"> | Date | string
    updatedAt?: DateTimeFilter<"RM_WASTAGE_LOGS"> | Date | string
    deletedAt?: DateTimeNullableFilter<"RM_WASTAGE_LOGS"> | Date | string | null
  }

  export type WIPRawMaterialUpsertWithWhereUniqueWithoutRawMaterialInput = {
    where: WIPRawMaterialWhereUniqueInput
    update: XOR<WIPRawMaterialUpdateWithoutRawMaterialInput, WIPRawMaterialUncheckedUpdateWithoutRawMaterialInput>
    create: XOR<WIPRawMaterialCreateWithoutRawMaterialInput, WIPRawMaterialUncheckedCreateWithoutRawMaterialInput>
  }

  export type WIPRawMaterialUpdateWithWhereUniqueWithoutRawMaterialInput = {
    where: WIPRawMaterialWhereUniqueInput
    data: XOR<WIPRawMaterialUpdateWithoutRawMaterialInput, WIPRawMaterialUncheckedUpdateWithoutRawMaterialInput>
  }

  export type WIPRawMaterialUpdateManyWithWhereWithoutRawMaterialInput = {
    where: WIPRawMaterialScalarWhereInput
    data: XOR<WIPRawMaterialUpdateManyMutationInput, WIPRawMaterialUncheckedUpdateManyWithoutRawMaterialInput>
  }

  export type WIPRawMaterialScalarWhereInput = {
    AND?: WIPRawMaterialScalarWhereInput | WIPRawMaterialScalarWhereInput[]
    OR?: WIPRawMaterialScalarWhereInput[]
    NOT?: WIPRawMaterialScalarWhereInput | WIPRawMaterialScalarWhereInput[]
    id?: IntFilter<"WIPRawMaterial"> | number
    wipId?: IntFilter<"WIPRawMaterial"> | number
    rawMaterialId?: BigIntFilter<"WIPRawMaterial"> | bigint | number
    quantity?: IntFilter<"WIPRawMaterial"> | number
  }

  export type SHOPIFY_PRODUCTSCreateWithoutShopifyVariantsInput = {
    id: bigint | number
    name: string
    price: Decimal | DecimalJsLike | number | string
    status?: string | null
    img?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    category: CATEGORIESCreateNestedOneWithoutShopifyProductsInput
    WIPProducts?: WIP_PRODUCTSCreateNestedManyWithoutProductInput
  }

  export type SHOPIFY_PRODUCTSUncheckedCreateWithoutShopifyVariantsInput = {
    id: bigint | number
    name: string
    categoryId: number
    price: Decimal | DecimalJsLike | number | string
    status?: string | null
    img?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    WIPProducts?: WIP_PRODUCTSUncheckedCreateNestedManyWithoutProductInput
  }

  export type SHOPIFY_PRODUCTSCreateOrConnectWithoutShopifyVariantsInput = {
    where: SHOPIFY_PRODUCTSWhereUniqueInput
    create: XOR<SHOPIFY_PRODUCTSCreateWithoutShopifyVariantsInput, SHOPIFY_PRODUCTSUncheckedCreateWithoutShopifyVariantsInput>
  }

  export type VARIANT_RAW_MATERIALS_TRACKERCreateWithoutVariantInput = {
    avgQuantity: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    rawMaterial: RAW_MATERIALSCreateNestedOneWithoutVariantMaterialsInput
  }

  export type VARIANT_RAW_MATERIALS_TRACKERUncheckedCreateWithoutVariantInput = {
    rawMaterialId: bigint | number
    avgQuantity: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type VARIANT_RAW_MATERIALS_TRACKERCreateOrConnectWithoutVariantInput = {
    where: VARIANT_RAW_MATERIALS_TRACKERWhereUniqueInput
    create: XOR<VARIANT_RAW_MATERIALS_TRACKERCreateWithoutVariantInput, VARIANT_RAW_MATERIALS_TRACKERUncheckedCreateWithoutVariantInput>
  }

  export type VARIANT_RAW_MATERIALS_TRACKERCreateManyVariantInputEnvelope = {
    data: VARIANT_RAW_MATERIALS_TRACKERCreateManyVariantInput | VARIANT_RAW_MATERIALS_TRACKERCreateManyVariantInput[]
    skipDuplicates?: boolean
  }

  export type SHOPIFY_PRODUCTSUpsertWithoutShopifyVariantsInput = {
    update: XOR<SHOPIFY_PRODUCTSUpdateWithoutShopifyVariantsInput, SHOPIFY_PRODUCTSUncheckedUpdateWithoutShopifyVariantsInput>
    create: XOR<SHOPIFY_PRODUCTSCreateWithoutShopifyVariantsInput, SHOPIFY_PRODUCTSUncheckedCreateWithoutShopifyVariantsInput>
    where?: SHOPIFY_PRODUCTSWhereInput
  }

  export type SHOPIFY_PRODUCTSUpdateToOneWithWhereWithoutShopifyVariantsInput = {
    where?: SHOPIFY_PRODUCTSWhereInput
    data: XOR<SHOPIFY_PRODUCTSUpdateWithoutShopifyVariantsInput, SHOPIFY_PRODUCTSUncheckedUpdateWithoutShopifyVariantsInput>
  }

  export type SHOPIFY_PRODUCTSUpdateWithoutShopifyVariantsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
    img?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: CATEGORIESUpdateOneRequiredWithoutShopifyProductsNestedInput
    WIPProducts?: WIP_PRODUCTSUpdateManyWithoutProductNestedInput
  }

  export type SHOPIFY_PRODUCTSUncheckedUpdateWithoutShopifyVariantsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    categoryId?: IntFieldUpdateOperationsInput | number
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
    img?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    WIPProducts?: WIP_PRODUCTSUncheckedUpdateManyWithoutProductNestedInput
  }

  export type VARIANT_RAW_MATERIALS_TRACKERUpsertWithWhereUniqueWithoutVariantInput = {
    where: VARIANT_RAW_MATERIALS_TRACKERWhereUniqueInput
    update: XOR<VARIANT_RAW_MATERIALS_TRACKERUpdateWithoutVariantInput, VARIANT_RAW_MATERIALS_TRACKERUncheckedUpdateWithoutVariantInput>
    create: XOR<VARIANT_RAW_MATERIALS_TRACKERCreateWithoutVariantInput, VARIANT_RAW_MATERIALS_TRACKERUncheckedCreateWithoutVariantInput>
  }

  export type VARIANT_RAW_MATERIALS_TRACKERUpdateWithWhereUniqueWithoutVariantInput = {
    where: VARIANT_RAW_MATERIALS_TRACKERWhereUniqueInput
    data: XOR<VARIANT_RAW_MATERIALS_TRACKERUpdateWithoutVariantInput, VARIANT_RAW_MATERIALS_TRACKERUncheckedUpdateWithoutVariantInput>
  }

  export type VARIANT_RAW_MATERIALS_TRACKERUpdateManyWithWhereWithoutVariantInput = {
    where: VARIANT_RAW_MATERIALS_TRACKERScalarWhereInput
    data: XOR<VARIANT_RAW_MATERIALS_TRACKERUpdateManyMutationInput, VARIANT_RAW_MATERIALS_TRACKERUncheckedUpdateManyWithoutVariantInput>
  }

  export type SHOPIFY_VARIANTSCreateWithoutVariantMaterialsInput = {
    id: bigint | number
    name: string
    AvailableQty: number
    img?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    variantName?: string | null
    variantOption?: string | null
    product: SHOPIFY_PRODUCTSCreateNestedOneWithoutShopifyVariantsInput
  }

  export type SHOPIFY_VARIANTSUncheckedCreateWithoutVariantMaterialsInput = {
    id: bigint | number
    productId: bigint | number
    name: string
    AvailableQty: number
    img?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    variantName?: string | null
    variantOption?: string | null
  }

  export type SHOPIFY_VARIANTSCreateOrConnectWithoutVariantMaterialsInput = {
    where: SHOPIFY_VARIANTSWhereUniqueInput
    create: XOR<SHOPIFY_VARIANTSCreateWithoutVariantMaterialsInput, SHOPIFY_VARIANTSUncheckedCreateWithoutVariantMaterialsInput>
  }

  export type RAW_MATERIALSCreateWithoutVariantMaterialsInput = {
    id: bigint | number
    name: string
    SKU: string
    quantity: number
    price: Decimal | DecimalJsLike | number | string
    image?: string | null
    description?: string | null
    expiry_date: Date | string
    quality_status: $Enums.QualityStatus
    storage_location: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    RMTransactions?: RM_TRANSACTIONSCreateNestedManyWithoutRawMaterialInput
    RMQualityChecks?: RM_QCCreateNestedManyWithoutRawMaterialInput
    RMWastageLogs?: RM_WASTAGE_LOGSCreateNestedManyWithoutRawMaterialInput
    WIPMaterials?: WIPRawMaterialCreateNestedManyWithoutRawMaterialInput
  }

  export type RAW_MATERIALSUncheckedCreateWithoutVariantMaterialsInput = {
    id: bigint | number
    name: string
    SKU: string
    quantity: number
    price: Decimal | DecimalJsLike | number | string
    image?: string | null
    description?: string | null
    expiry_date: Date | string
    quality_status: $Enums.QualityStatus
    storage_location: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    RMTransactions?: RM_TRANSACTIONSUncheckedCreateNestedManyWithoutRawMaterialInput
    RMQualityChecks?: RM_QCUncheckedCreateNestedManyWithoutRawMaterialInput
    RMWastageLogs?: RM_WASTAGE_LOGSUncheckedCreateNestedManyWithoutRawMaterialInput
    WIPMaterials?: WIPRawMaterialUncheckedCreateNestedManyWithoutRawMaterialInput
  }

  export type RAW_MATERIALSCreateOrConnectWithoutVariantMaterialsInput = {
    where: RAW_MATERIALSWhereUniqueInput
    create: XOR<RAW_MATERIALSCreateWithoutVariantMaterialsInput, RAW_MATERIALSUncheckedCreateWithoutVariantMaterialsInput>
  }

  export type SHOPIFY_VARIANTSUpsertWithoutVariantMaterialsInput = {
    update: XOR<SHOPIFY_VARIANTSUpdateWithoutVariantMaterialsInput, SHOPIFY_VARIANTSUncheckedUpdateWithoutVariantMaterialsInput>
    create: XOR<SHOPIFY_VARIANTSCreateWithoutVariantMaterialsInput, SHOPIFY_VARIANTSUncheckedCreateWithoutVariantMaterialsInput>
    where?: SHOPIFY_VARIANTSWhereInput
  }

  export type SHOPIFY_VARIANTSUpdateToOneWithWhereWithoutVariantMaterialsInput = {
    where?: SHOPIFY_VARIANTSWhereInput
    data: XOR<SHOPIFY_VARIANTSUpdateWithoutVariantMaterialsInput, SHOPIFY_VARIANTSUncheckedUpdateWithoutVariantMaterialsInput>
  }

  export type SHOPIFY_VARIANTSUpdateWithoutVariantMaterialsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    AvailableQty?: IntFieldUpdateOperationsInput | number
    img?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    variantName?: NullableStringFieldUpdateOperationsInput | string | null
    variantOption?: NullableStringFieldUpdateOperationsInput | string | null
    product?: SHOPIFY_PRODUCTSUpdateOneRequiredWithoutShopifyVariantsNestedInput
  }

  export type SHOPIFY_VARIANTSUncheckedUpdateWithoutVariantMaterialsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    productId?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    AvailableQty?: IntFieldUpdateOperationsInput | number
    img?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    variantName?: NullableStringFieldUpdateOperationsInput | string | null
    variantOption?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type RAW_MATERIALSUpsertWithoutVariantMaterialsInput = {
    update: XOR<RAW_MATERIALSUpdateWithoutVariantMaterialsInput, RAW_MATERIALSUncheckedUpdateWithoutVariantMaterialsInput>
    create: XOR<RAW_MATERIALSCreateWithoutVariantMaterialsInput, RAW_MATERIALSUncheckedCreateWithoutVariantMaterialsInput>
    where?: RAW_MATERIALSWhereInput
  }

  export type RAW_MATERIALSUpdateToOneWithWhereWithoutVariantMaterialsInput = {
    where?: RAW_MATERIALSWhereInput
    data: XOR<RAW_MATERIALSUpdateWithoutVariantMaterialsInput, RAW_MATERIALSUncheckedUpdateWithoutVariantMaterialsInput>
  }

  export type RAW_MATERIALSUpdateWithoutVariantMaterialsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    SKU?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    expiry_date?: DateTimeFieldUpdateOperationsInput | Date | string
    quality_status?: EnumQualityStatusFieldUpdateOperationsInput | $Enums.QualityStatus
    storage_location?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    RMTransactions?: RM_TRANSACTIONSUpdateManyWithoutRawMaterialNestedInput
    RMQualityChecks?: RM_QCUpdateManyWithoutRawMaterialNestedInput
    RMWastageLogs?: RM_WASTAGE_LOGSUpdateManyWithoutRawMaterialNestedInput
    WIPMaterials?: WIPRawMaterialUpdateManyWithoutRawMaterialNestedInput
  }

  export type RAW_MATERIALSUncheckedUpdateWithoutVariantMaterialsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    SKU?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    expiry_date?: DateTimeFieldUpdateOperationsInput | Date | string
    quality_status?: EnumQualityStatusFieldUpdateOperationsInput | $Enums.QualityStatus
    storage_location?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    RMTransactions?: RM_TRANSACTIONSUncheckedUpdateManyWithoutRawMaterialNestedInput
    RMQualityChecks?: RM_QCUncheckedUpdateManyWithoutRawMaterialNestedInput
    RMWastageLogs?: RM_WASTAGE_LOGSUncheckedUpdateManyWithoutRawMaterialNestedInput
    WIPMaterials?: WIPRawMaterialUncheckedUpdateManyWithoutRawMaterialNestedInput
  }

  export type SHOPIFY_PRODUCTSCreateWithoutCategoryInput = {
    id: bigint | number
    name: string
    price: Decimal | DecimalJsLike | number | string
    status?: string | null
    img?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    ShopifyVariants?: SHOPIFY_VARIANTSCreateNestedManyWithoutProductInput
    WIPProducts?: WIP_PRODUCTSCreateNestedManyWithoutProductInput
  }

  export type SHOPIFY_PRODUCTSUncheckedCreateWithoutCategoryInput = {
    id: bigint | number
    name: string
    price: Decimal | DecimalJsLike | number | string
    status?: string | null
    img?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    ShopifyVariants?: SHOPIFY_VARIANTSUncheckedCreateNestedManyWithoutProductInput
    WIPProducts?: WIP_PRODUCTSUncheckedCreateNestedManyWithoutProductInput
  }

  export type SHOPIFY_PRODUCTSCreateOrConnectWithoutCategoryInput = {
    where: SHOPIFY_PRODUCTSWhereUniqueInput
    create: XOR<SHOPIFY_PRODUCTSCreateWithoutCategoryInput, SHOPIFY_PRODUCTSUncheckedCreateWithoutCategoryInput>
  }

  export type SHOPIFY_PRODUCTSCreateManyCategoryInputEnvelope = {
    data: SHOPIFY_PRODUCTSCreateManyCategoryInput | SHOPIFY_PRODUCTSCreateManyCategoryInput[]
    skipDuplicates?: boolean
  }

  export type SHOPIFY_PRODUCTSUpsertWithWhereUniqueWithoutCategoryInput = {
    where: SHOPIFY_PRODUCTSWhereUniqueInput
    update: XOR<SHOPIFY_PRODUCTSUpdateWithoutCategoryInput, SHOPIFY_PRODUCTSUncheckedUpdateWithoutCategoryInput>
    create: XOR<SHOPIFY_PRODUCTSCreateWithoutCategoryInput, SHOPIFY_PRODUCTSUncheckedCreateWithoutCategoryInput>
  }

  export type SHOPIFY_PRODUCTSUpdateWithWhereUniqueWithoutCategoryInput = {
    where: SHOPIFY_PRODUCTSWhereUniqueInput
    data: XOR<SHOPIFY_PRODUCTSUpdateWithoutCategoryInput, SHOPIFY_PRODUCTSUncheckedUpdateWithoutCategoryInput>
  }

  export type SHOPIFY_PRODUCTSUpdateManyWithWhereWithoutCategoryInput = {
    where: SHOPIFY_PRODUCTSScalarWhereInput
    data: XOR<SHOPIFY_PRODUCTSUpdateManyMutationInput, SHOPIFY_PRODUCTSUncheckedUpdateManyWithoutCategoryInput>
  }

  export type SHOPIFY_PRODUCTSScalarWhereInput = {
    AND?: SHOPIFY_PRODUCTSScalarWhereInput | SHOPIFY_PRODUCTSScalarWhereInput[]
    OR?: SHOPIFY_PRODUCTSScalarWhereInput[]
    NOT?: SHOPIFY_PRODUCTSScalarWhereInput | SHOPIFY_PRODUCTSScalarWhereInput[]
    id?: BigIntFilter<"SHOPIFY_PRODUCTS"> | bigint | number
    name?: StringFilter<"SHOPIFY_PRODUCTS"> | string
    categoryId?: IntFilter<"SHOPIFY_PRODUCTS"> | number
    price?: DecimalFilter<"SHOPIFY_PRODUCTS"> | Decimal | DecimalJsLike | number | string
    status?: StringNullableFilter<"SHOPIFY_PRODUCTS"> | string | null
    img?: StringNullableFilter<"SHOPIFY_PRODUCTS"> | string | null
    createdAt?: DateTimeFilter<"SHOPIFY_PRODUCTS"> | Date | string
    updatedAt?: DateTimeFilter<"SHOPIFY_PRODUCTS"> | Date | string
  }

  export type CATEGORIESCreateWithoutShopifyProductsInput = {
    id: number
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CATEGORIESUncheckedCreateWithoutShopifyProductsInput = {
    id: number
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CATEGORIESCreateOrConnectWithoutShopifyProductsInput = {
    where: CATEGORIESWhereUniqueInput
    create: XOR<CATEGORIESCreateWithoutShopifyProductsInput, CATEGORIESUncheckedCreateWithoutShopifyProductsInput>
  }

  export type SHOPIFY_VARIANTSCreateWithoutProductInput = {
    id: bigint | number
    name: string
    AvailableQty: number
    img?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    variantName?: string | null
    variantOption?: string | null
    VariantMaterials?: VARIANT_RAW_MATERIALS_TRACKERCreateNestedManyWithoutVariantInput
  }

  export type SHOPIFY_VARIANTSUncheckedCreateWithoutProductInput = {
    id: bigint | number
    name: string
    AvailableQty: number
    img?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    variantName?: string | null
    variantOption?: string | null
    VariantMaterials?: VARIANT_RAW_MATERIALS_TRACKERUncheckedCreateNestedManyWithoutVariantInput
  }

  export type SHOPIFY_VARIANTSCreateOrConnectWithoutProductInput = {
    where: SHOPIFY_VARIANTSWhereUniqueInput
    create: XOR<SHOPIFY_VARIANTSCreateWithoutProductInput, SHOPIFY_VARIANTSUncheckedCreateWithoutProductInput>
  }

  export type SHOPIFY_VARIANTSCreateManyProductInputEnvelope = {
    data: SHOPIFY_VARIANTSCreateManyProductInput | SHOPIFY_VARIANTSCreateManyProductInput[]
    skipDuplicates?: boolean
  }

  export type WIP_PRODUCTSCreateWithoutProductInput = {
    quantity: number
    wip: WIPCreateNestedOneWithoutWipProductsInput
  }

  export type WIP_PRODUCTSUncheckedCreateWithoutProductInput = {
    id?: number
    wipId: number
    quantity: number
  }

  export type WIP_PRODUCTSCreateOrConnectWithoutProductInput = {
    where: WIP_PRODUCTSWhereUniqueInput
    create: XOR<WIP_PRODUCTSCreateWithoutProductInput, WIP_PRODUCTSUncheckedCreateWithoutProductInput>
  }

  export type WIP_PRODUCTSCreateManyProductInputEnvelope = {
    data: WIP_PRODUCTSCreateManyProductInput | WIP_PRODUCTSCreateManyProductInput[]
    skipDuplicates?: boolean
  }

  export type CATEGORIESUpsertWithoutShopifyProductsInput = {
    update: XOR<CATEGORIESUpdateWithoutShopifyProductsInput, CATEGORIESUncheckedUpdateWithoutShopifyProductsInput>
    create: XOR<CATEGORIESCreateWithoutShopifyProductsInput, CATEGORIESUncheckedCreateWithoutShopifyProductsInput>
    where?: CATEGORIESWhereInput
  }

  export type CATEGORIESUpdateToOneWithWhereWithoutShopifyProductsInput = {
    where?: CATEGORIESWhereInput
    data: XOR<CATEGORIESUpdateWithoutShopifyProductsInput, CATEGORIESUncheckedUpdateWithoutShopifyProductsInput>
  }

  export type CATEGORIESUpdateWithoutShopifyProductsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CATEGORIESUncheckedUpdateWithoutShopifyProductsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SHOPIFY_VARIANTSUpsertWithWhereUniqueWithoutProductInput = {
    where: SHOPIFY_VARIANTSWhereUniqueInput
    update: XOR<SHOPIFY_VARIANTSUpdateWithoutProductInput, SHOPIFY_VARIANTSUncheckedUpdateWithoutProductInput>
    create: XOR<SHOPIFY_VARIANTSCreateWithoutProductInput, SHOPIFY_VARIANTSUncheckedCreateWithoutProductInput>
  }

  export type SHOPIFY_VARIANTSUpdateWithWhereUniqueWithoutProductInput = {
    where: SHOPIFY_VARIANTSWhereUniqueInput
    data: XOR<SHOPIFY_VARIANTSUpdateWithoutProductInput, SHOPIFY_VARIANTSUncheckedUpdateWithoutProductInput>
  }

  export type SHOPIFY_VARIANTSUpdateManyWithWhereWithoutProductInput = {
    where: SHOPIFY_VARIANTSScalarWhereInput
    data: XOR<SHOPIFY_VARIANTSUpdateManyMutationInput, SHOPIFY_VARIANTSUncheckedUpdateManyWithoutProductInput>
  }

  export type SHOPIFY_VARIANTSScalarWhereInput = {
    AND?: SHOPIFY_VARIANTSScalarWhereInput | SHOPIFY_VARIANTSScalarWhereInput[]
    OR?: SHOPIFY_VARIANTSScalarWhereInput[]
    NOT?: SHOPIFY_VARIANTSScalarWhereInput | SHOPIFY_VARIANTSScalarWhereInput[]
    id?: BigIntFilter<"SHOPIFY_VARIANTS"> | bigint | number
    productId?: BigIntFilter<"SHOPIFY_VARIANTS"> | bigint | number
    name?: StringFilter<"SHOPIFY_VARIANTS"> | string
    AvailableQty?: IntFilter<"SHOPIFY_VARIANTS"> | number
    img?: StringNullableFilter<"SHOPIFY_VARIANTS"> | string | null
    createdAt?: DateTimeFilter<"SHOPIFY_VARIANTS"> | Date | string
    updatedAt?: DateTimeFilter<"SHOPIFY_VARIANTS"> | Date | string
    deletedAt?: DateTimeNullableFilter<"SHOPIFY_VARIANTS"> | Date | string | null
    variantName?: StringNullableFilter<"SHOPIFY_VARIANTS"> | string | null
    variantOption?: StringNullableFilter<"SHOPIFY_VARIANTS"> | string | null
  }

  export type WIP_PRODUCTSUpsertWithWhereUniqueWithoutProductInput = {
    where: WIP_PRODUCTSWhereUniqueInput
    update: XOR<WIP_PRODUCTSUpdateWithoutProductInput, WIP_PRODUCTSUncheckedUpdateWithoutProductInput>
    create: XOR<WIP_PRODUCTSCreateWithoutProductInput, WIP_PRODUCTSUncheckedCreateWithoutProductInput>
  }

  export type WIP_PRODUCTSUpdateWithWhereUniqueWithoutProductInput = {
    where: WIP_PRODUCTSWhereUniqueInput
    data: XOR<WIP_PRODUCTSUpdateWithoutProductInput, WIP_PRODUCTSUncheckedUpdateWithoutProductInput>
  }

  export type WIP_PRODUCTSUpdateManyWithWhereWithoutProductInput = {
    where: WIP_PRODUCTSScalarWhereInput
    data: XOR<WIP_PRODUCTSUpdateManyMutationInput, WIP_PRODUCTSUncheckedUpdateManyWithoutProductInput>
  }

  export type WIP_PRODUCTSScalarWhereInput = {
    AND?: WIP_PRODUCTSScalarWhereInput | WIP_PRODUCTSScalarWhereInput[]
    OR?: WIP_PRODUCTSScalarWhereInput[]
    NOT?: WIP_PRODUCTSScalarWhereInput | WIP_PRODUCTSScalarWhereInput[]
    id?: IntFilter<"WIP_PRODUCTS"> | number
    wipId?: IntFilter<"WIP_PRODUCTS"> | number
    productId?: BigIntFilter<"WIP_PRODUCTS"> | bigint | number
    quantity?: IntFilter<"WIP_PRODUCTS"> | number
  }

  export type RAW_MATERIALSCreateWithoutRMTransactionsInput = {
    id: bigint | number
    name: string
    SKU: string
    quantity: number
    price: Decimal | DecimalJsLike | number | string
    image?: string | null
    description?: string | null
    expiry_date: Date | string
    quality_status: $Enums.QualityStatus
    storage_location: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    VariantMaterials?: VARIANT_RAW_MATERIALS_TRACKERCreateNestedManyWithoutRawMaterialInput
    RMQualityChecks?: RM_QCCreateNestedManyWithoutRawMaterialInput
    RMWastageLogs?: RM_WASTAGE_LOGSCreateNestedManyWithoutRawMaterialInput
    WIPMaterials?: WIPRawMaterialCreateNestedManyWithoutRawMaterialInput
  }

  export type RAW_MATERIALSUncheckedCreateWithoutRMTransactionsInput = {
    id: bigint | number
    name: string
    SKU: string
    quantity: number
    price: Decimal | DecimalJsLike | number | string
    image?: string | null
    description?: string | null
    expiry_date: Date | string
    quality_status: $Enums.QualityStatus
    storage_location: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    VariantMaterials?: VARIANT_RAW_MATERIALS_TRACKERUncheckedCreateNestedManyWithoutRawMaterialInput
    RMQualityChecks?: RM_QCUncheckedCreateNestedManyWithoutRawMaterialInput
    RMWastageLogs?: RM_WASTAGE_LOGSUncheckedCreateNestedManyWithoutRawMaterialInput
    WIPMaterials?: WIPRawMaterialUncheckedCreateNestedManyWithoutRawMaterialInput
  }

  export type RAW_MATERIALSCreateOrConnectWithoutRMTransactionsInput = {
    where: RAW_MATERIALSWhereUniqueInput
    create: XOR<RAW_MATERIALSCreateWithoutRMTransactionsInput, RAW_MATERIALSUncheckedCreateWithoutRMTransactionsInput>
  }

  export type EmployeeCreateWithoutRMTransactionsInput = {
    name: string
    role: $Enums.Roles
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    RM_QC?: RM_QCCreateNestedManyWithoutCheckedByInput
    RM_QC2?: RM_QCCreateNestedManyWithoutDoneByInput
    WIPTransactions?: WIP_TRANSACTIONSCreateNestedManyWithoutInitiatedByInput
    FGTransactions?: FG_TRANSACTIONSCreateNestedManyWithoutInitiatedByInput
    AuditLogs?: AuditLogsCreateNestedManyWithoutChangedByInput
  }

  export type EmployeeUncheckedCreateWithoutRMTransactionsInput = {
    id?: number
    name: string
    role: $Enums.Roles
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    RM_QC?: RM_QCUncheckedCreateNestedManyWithoutCheckedByInput
    RM_QC2?: RM_QCUncheckedCreateNestedManyWithoutDoneByInput
    WIPTransactions?: WIP_TRANSACTIONSUncheckedCreateNestedManyWithoutInitiatedByInput
    FGTransactions?: FG_TRANSACTIONSUncheckedCreateNestedManyWithoutInitiatedByInput
    AuditLogs?: AuditLogsUncheckedCreateNestedManyWithoutChangedByInput
  }

  export type EmployeeCreateOrConnectWithoutRMTransactionsInput = {
    where: EmployeeWhereUniqueInput
    create: XOR<EmployeeCreateWithoutRMTransactionsInput, EmployeeUncheckedCreateWithoutRMTransactionsInput>
  }

  export type RM_QCCreateWithoutTransactionInput = {
    quality_status: $Enums.QualityStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    rawMaterial: RAW_MATERIALSCreateNestedOneWithoutRMQualityChecksInput
    checkedBy: EmployeeCreateNestedOneWithoutRM_QCInput
    doneBy: EmployeeCreateNestedOneWithoutRM_QC2Input
  }

  export type RM_QCUncheckedCreateWithoutTransactionInput = {
    id?: number
    rawMaterialId: bigint | number
    quality_status: $Enums.QualityStatus
    checkedById: number
    doneById: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type RM_QCCreateOrConnectWithoutTransactionInput = {
    where: RM_QCWhereUniqueInput
    create: XOR<RM_QCCreateWithoutTransactionInput, RM_QCUncheckedCreateWithoutTransactionInput>
  }

  export type RM_QCCreateManyTransactionInputEnvelope = {
    data: RM_QCCreateManyTransactionInput | RM_QCCreateManyTransactionInput[]
    skipDuplicates?: boolean
  }

  export type RM_WASTAGE_LOGSCreateWithoutTransactionInput = {
    quantity: number
    reason: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    rawMaterial: RAW_MATERIALSCreateNestedOneWithoutRMWastageLogsInput
  }

  export type RM_WASTAGE_LOGSUncheckedCreateWithoutTransactionInput = {
    id?: number
    rawMaterialId: bigint | number
    quantity: number
    reason: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type RM_WASTAGE_LOGSCreateOrConnectWithoutTransactionInput = {
    where: RM_WASTAGE_LOGSWhereUniqueInput
    create: XOR<RM_WASTAGE_LOGSCreateWithoutTransactionInput, RM_WASTAGE_LOGSUncheckedCreateWithoutTransactionInput>
  }

  export type RM_WASTAGE_LOGSCreateManyTransactionInputEnvelope = {
    data: RM_WASTAGE_LOGSCreateManyTransactionInput | RM_WASTAGE_LOGSCreateManyTransactionInput[]
    skipDuplicates?: boolean
  }

  export type RAW_MATERIALSUpsertWithoutRMTransactionsInput = {
    update: XOR<RAW_MATERIALSUpdateWithoutRMTransactionsInput, RAW_MATERIALSUncheckedUpdateWithoutRMTransactionsInput>
    create: XOR<RAW_MATERIALSCreateWithoutRMTransactionsInput, RAW_MATERIALSUncheckedCreateWithoutRMTransactionsInput>
    where?: RAW_MATERIALSWhereInput
  }

  export type RAW_MATERIALSUpdateToOneWithWhereWithoutRMTransactionsInput = {
    where?: RAW_MATERIALSWhereInput
    data: XOR<RAW_MATERIALSUpdateWithoutRMTransactionsInput, RAW_MATERIALSUncheckedUpdateWithoutRMTransactionsInput>
  }

  export type RAW_MATERIALSUpdateWithoutRMTransactionsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    SKU?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    expiry_date?: DateTimeFieldUpdateOperationsInput | Date | string
    quality_status?: EnumQualityStatusFieldUpdateOperationsInput | $Enums.QualityStatus
    storage_location?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    VariantMaterials?: VARIANT_RAW_MATERIALS_TRACKERUpdateManyWithoutRawMaterialNestedInput
    RMQualityChecks?: RM_QCUpdateManyWithoutRawMaterialNestedInput
    RMWastageLogs?: RM_WASTAGE_LOGSUpdateManyWithoutRawMaterialNestedInput
    WIPMaterials?: WIPRawMaterialUpdateManyWithoutRawMaterialNestedInput
  }

  export type RAW_MATERIALSUncheckedUpdateWithoutRMTransactionsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    SKU?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    expiry_date?: DateTimeFieldUpdateOperationsInput | Date | string
    quality_status?: EnumQualityStatusFieldUpdateOperationsInput | $Enums.QualityStatus
    storage_location?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    VariantMaterials?: VARIANT_RAW_MATERIALS_TRACKERUncheckedUpdateManyWithoutRawMaterialNestedInput
    RMQualityChecks?: RM_QCUncheckedUpdateManyWithoutRawMaterialNestedInput
    RMWastageLogs?: RM_WASTAGE_LOGSUncheckedUpdateManyWithoutRawMaterialNestedInput
    WIPMaterials?: WIPRawMaterialUncheckedUpdateManyWithoutRawMaterialNestedInput
  }

  export type EmployeeUpsertWithoutRMTransactionsInput = {
    update: XOR<EmployeeUpdateWithoutRMTransactionsInput, EmployeeUncheckedUpdateWithoutRMTransactionsInput>
    create: XOR<EmployeeCreateWithoutRMTransactionsInput, EmployeeUncheckedCreateWithoutRMTransactionsInput>
    where?: EmployeeWhereInput
  }

  export type EmployeeUpdateToOneWithWhereWithoutRMTransactionsInput = {
    where?: EmployeeWhereInput
    data: XOR<EmployeeUpdateWithoutRMTransactionsInput, EmployeeUncheckedUpdateWithoutRMTransactionsInput>
  }

  export type EmployeeUpdateWithoutRMTransactionsInput = {
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumRolesFieldUpdateOperationsInput | $Enums.Roles
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    RM_QC?: RM_QCUpdateManyWithoutCheckedByNestedInput
    RM_QC2?: RM_QCUpdateManyWithoutDoneByNestedInput
    WIPTransactions?: WIP_TRANSACTIONSUpdateManyWithoutInitiatedByNestedInput
    FGTransactions?: FG_TRANSACTIONSUpdateManyWithoutInitiatedByNestedInput
    AuditLogs?: AuditLogsUpdateManyWithoutChangedByNestedInput
  }

  export type EmployeeUncheckedUpdateWithoutRMTransactionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumRolesFieldUpdateOperationsInput | $Enums.Roles
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    RM_QC?: RM_QCUncheckedUpdateManyWithoutCheckedByNestedInput
    RM_QC2?: RM_QCUncheckedUpdateManyWithoutDoneByNestedInput
    WIPTransactions?: WIP_TRANSACTIONSUncheckedUpdateManyWithoutInitiatedByNestedInput
    FGTransactions?: FG_TRANSACTIONSUncheckedUpdateManyWithoutInitiatedByNestedInput
    AuditLogs?: AuditLogsUncheckedUpdateManyWithoutChangedByNestedInput
  }

  export type RM_QCUpsertWithWhereUniqueWithoutTransactionInput = {
    where: RM_QCWhereUniqueInput
    update: XOR<RM_QCUpdateWithoutTransactionInput, RM_QCUncheckedUpdateWithoutTransactionInput>
    create: XOR<RM_QCCreateWithoutTransactionInput, RM_QCUncheckedCreateWithoutTransactionInput>
  }

  export type RM_QCUpdateWithWhereUniqueWithoutTransactionInput = {
    where: RM_QCWhereUniqueInput
    data: XOR<RM_QCUpdateWithoutTransactionInput, RM_QCUncheckedUpdateWithoutTransactionInput>
  }

  export type RM_QCUpdateManyWithWhereWithoutTransactionInput = {
    where: RM_QCScalarWhereInput
    data: XOR<RM_QCUpdateManyMutationInput, RM_QCUncheckedUpdateManyWithoutTransactionInput>
  }

  export type RM_WASTAGE_LOGSUpsertWithWhereUniqueWithoutTransactionInput = {
    where: RM_WASTAGE_LOGSWhereUniqueInput
    update: XOR<RM_WASTAGE_LOGSUpdateWithoutTransactionInput, RM_WASTAGE_LOGSUncheckedUpdateWithoutTransactionInput>
    create: XOR<RM_WASTAGE_LOGSCreateWithoutTransactionInput, RM_WASTAGE_LOGSUncheckedCreateWithoutTransactionInput>
  }

  export type RM_WASTAGE_LOGSUpdateWithWhereUniqueWithoutTransactionInput = {
    where: RM_WASTAGE_LOGSWhereUniqueInput
    data: XOR<RM_WASTAGE_LOGSUpdateWithoutTransactionInput, RM_WASTAGE_LOGSUncheckedUpdateWithoutTransactionInput>
  }

  export type RM_WASTAGE_LOGSUpdateManyWithWhereWithoutTransactionInput = {
    where: RM_WASTAGE_LOGSScalarWhereInput
    data: XOR<RM_WASTAGE_LOGSUpdateManyMutationInput, RM_WASTAGE_LOGSUncheckedUpdateManyWithoutTransactionInput>
  }

  export type RAW_MATERIALSCreateWithoutRMQualityChecksInput = {
    id: bigint | number
    name: string
    SKU: string
    quantity: number
    price: Decimal | DecimalJsLike | number | string
    image?: string | null
    description?: string | null
    expiry_date: Date | string
    quality_status: $Enums.QualityStatus
    storage_location: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    VariantMaterials?: VARIANT_RAW_MATERIALS_TRACKERCreateNestedManyWithoutRawMaterialInput
    RMTransactions?: RM_TRANSACTIONSCreateNestedManyWithoutRawMaterialInput
    RMWastageLogs?: RM_WASTAGE_LOGSCreateNestedManyWithoutRawMaterialInput
    WIPMaterials?: WIPRawMaterialCreateNestedManyWithoutRawMaterialInput
  }

  export type RAW_MATERIALSUncheckedCreateWithoutRMQualityChecksInput = {
    id: bigint | number
    name: string
    SKU: string
    quantity: number
    price: Decimal | DecimalJsLike | number | string
    image?: string | null
    description?: string | null
    expiry_date: Date | string
    quality_status: $Enums.QualityStatus
    storage_location: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    VariantMaterials?: VARIANT_RAW_MATERIALS_TRACKERUncheckedCreateNestedManyWithoutRawMaterialInput
    RMTransactions?: RM_TRANSACTIONSUncheckedCreateNestedManyWithoutRawMaterialInput
    RMWastageLogs?: RM_WASTAGE_LOGSUncheckedCreateNestedManyWithoutRawMaterialInput
    WIPMaterials?: WIPRawMaterialUncheckedCreateNestedManyWithoutRawMaterialInput
  }

  export type RAW_MATERIALSCreateOrConnectWithoutRMQualityChecksInput = {
    where: RAW_MATERIALSWhereUniqueInput
    create: XOR<RAW_MATERIALSCreateWithoutRMQualityChecksInput, RAW_MATERIALSUncheckedCreateWithoutRMQualityChecksInput>
  }

  export type RM_TRANSACTIONSCreateWithoutRMQualityChecksInput = {
    quantity: number
    transactionType: $Enums.TransactionType
    reason: string
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    rawMaterial: RAW_MATERIALSCreateNestedOneWithoutRMTransactionsInput
    initiatedBy: EmployeeCreateNestedOneWithoutRMTransactionsInput
    RMWastageLogs?: RM_WASTAGE_LOGSCreateNestedManyWithoutTransactionInput
  }

  export type RM_TRANSACTIONSUncheckedCreateWithoutRMQualityChecksInput = {
    id?: number
    rawMaterialId: bigint | number
    quantity: number
    transactionType: $Enums.TransactionType
    reason: string
    status: string
    initiatedById: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    RMWastageLogs?: RM_WASTAGE_LOGSUncheckedCreateNestedManyWithoutTransactionInput
  }

  export type RM_TRANSACTIONSCreateOrConnectWithoutRMQualityChecksInput = {
    where: RM_TRANSACTIONSWhereUniqueInput
    create: XOR<RM_TRANSACTIONSCreateWithoutRMQualityChecksInput, RM_TRANSACTIONSUncheckedCreateWithoutRMQualityChecksInput>
  }

  export type EmployeeCreateWithoutRM_QCInput = {
    name: string
    role: $Enums.Roles
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    RM_QC2?: RM_QCCreateNestedManyWithoutDoneByInput
    RMTransactions?: RM_TRANSACTIONSCreateNestedManyWithoutInitiatedByInput
    WIPTransactions?: WIP_TRANSACTIONSCreateNestedManyWithoutInitiatedByInput
    FGTransactions?: FG_TRANSACTIONSCreateNestedManyWithoutInitiatedByInput
    AuditLogs?: AuditLogsCreateNestedManyWithoutChangedByInput
  }

  export type EmployeeUncheckedCreateWithoutRM_QCInput = {
    id?: number
    name: string
    role: $Enums.Roles
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    RM_QC2?: RM_QCUncheckedCreateNestedManyWithoutDoneByInput
    RMTransactions?: RM_TRANSACTIONSUncheckedCreateNestedManyWithoutInitiatedByInput
    WIPTransactions?: WIP_TRANSACTIONSUncheckedCreateNestedManyWithoutInitiatedByInput
    FGTransactions?: FG_TRANSACTIONSUncheckedCreateNestedManyWithoutInitiatedByInput
    AuditLogs?: AuditLogsUncheckedCreateNestedManyWithoutChangedByInput
  }

  export type EmployeeCreateOrConnectWithoutRM_QCInput = {
    where: EmployeeWhereUniqueInput
    create: XOR<EmployeeCreateWithoutRM_QCInput, EmployeeUncheckedCreateWithoutRM_QCInput>
  }

  export type EmployeeCreateWithoutRM_QC2Input = {
    name: string
    role: $Enums.Roles
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    RM_QC?: RM_QCCreateNestedManyWithoutCheckedByInput
    RMTransactions?: RM_TRANSACTIONSCreateNestedManyWithoutInitiatedByInput
    WIPTransactions?: WIP_TRANSACTIONSCreateNestedManyWithoutInitiatedByInput
    FGTransactions?: FG_TRANSACTIONSCreateNestedManyWithoutInitiatedByInput
    AuditLogs?: AuditLogsCreateNestedManyWithoutChangedByInput
  }

  export type EmployeeUncheckedCreateWithoutRM_QC2Input = {
    id?: number
    name: string
    role: $Enums.Roles
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    RM_QC?: RM_QCUncheckedCreateNestedManyWithoutCheckedByInput
    RMTransactions?: RM_TRANSACTIONSUncheckedCreateNestedManyWithoutInitiatedByInput
    WIPTransactions?: WIP_TRANSACTIONSUncheckedCreateNestedManyWithoutInitiatedByInput
    FGTransactions?: FG_TRANSACTIONSUncheckedCreateNestedManyWithoutInitiatedByInput
    AuditLogs?: AuditLogsUncheckedCreateNestedManyWithoutChangedByInput
  }

  export type EmployeeCreateOrConnectWithoutRM_QC2Input = {
    where: EmployeeWhereUniqueInput
    create: XOR<EmployeeCreateWithoutRM_QC2Input, EmployeeUncheckedCreateWithoutRM_QC2Input>
  }

  export type RAW_MATERIALSUpsertWithoutRMQualityChecksInput = {
    update: XOR<RAW_MATERIALSUpdateWithoutRMQualityChecksInput, RAW_MATERIALSUncheckedUpdateWithoutRMQualityChecksInput>
    create: XOR<RAW_MATERIALSCreateWithoutRMQualityChecksInput, RAW_MATERIALSUncheckedCreateWithoutRMQualityChecksInput>
    where?: RAW_MATERIALSWhereInput
  }

  export type RAW_MATERIALSUpdateToOneWithWhereWithoutRMQualityChecksInput = {
    where?: RAW_MATERIALSWhereInput
    data: XOR<RAW_MATERIALSUpdateWithoutRMQualityChecksInput, RAW_MATERIALSUncheckedUpdateWithoutRMQualityChecksInput>
  }

  export type RAW_MATERIALSUpdateWithoutRMQualityChecksInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    SKU?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    expiry_date?: DateTimeFieldUpdateOperationsInput | Date | string
    quality_status?: EnumQualityStatusFieldUpdateOperationsInput | $Enums.QualityStatus
    storage_location?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    VariantMaterials?: VARIANT_RAW_MATERIALS_TRACKERUpdateManyWithoutRawMaterialNestedInput
    RMTransactions?: RM_TRANSACTIONSUpdateManyWithoutRawMaterialNestedInput
    RMWastageLogs?: RM_WASTAGE_LOGSUpdateManyWithoutRawMaterialNestedInput
    WIPMaterials?: WIPRawMaterialUpdateManyWithoutRawMaterialNestedInput
  }

  export type RAW_MATERIALSUncheckedUpdateWithoutRMQualityChecksInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    SKU?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    expiry_date?: DateTimeFieldUpdateOperationsInput | Date | string
    quality_status?: EnumQualityStatusFieldUpdateOperationsInput | $Enums.QualityStatus
    storage_location?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    VariantMaterials?: VARIANT_RAW_MATERIALS_TRACKERUncheckedUpdateManyWithoutRawMaterialNestedInput
    RMTransactions?: RM_TRANSACTIONSUncheckedUpdateManyWithoutRawMaterialNestedInput
    RMWastageLogs?: RM_WASTAGE_LOGSUncheckedUpdateManyWithoutRawMaterialNestedInput
    WIPMaterials?: WIPRawMaterialUncheckedUpdateManyWithoutRawMaterialNestedInput
  }

  export type RM_TRANSACTIONSUpsertWithoutRMQualityChecksInput = {
    update: XOR<RM_TRANSACTIONSUpdateWithoutRMQualityChecksInput, RM_TRANSACTIONSUncheckedUpdateWithoutRMQualityChecksInput>
    create: XOR<RM_TRANSACTIONSCreateWithoutRMQualityChecksInput, RM_TRANSACTIONSUncheckedCreateWithoutRMQualityChecksInput>
    where?: RM_TRANSACTIONSWhereInput
  }

  export type RM_TRANSACTIONSUpdateToOneWithWhereWithoutRMQualityChecksInput = {
    where?: RM_TRANSACTIONSWhereInput
    data: XOR<RM_TRANSACTIONSUpdateWithoutRMQualityChecksInput, RM_TRANSACTIONSUncheckedUpdateWithoutRMQualityChecksInput>
  }

  export type RM_TRANSACTIONSUpdateWithoutRMQualityChecksInput = {
    quantity?: IntFieldUpdateOperationsInput | number
    transactionType?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    reason?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rawMaterial?: RAW_MATERIALSUpdateOneRequiredWithoutRMTransactionsNestedInput
    initiatedBy?: EmployeeUpdateOneRequiredWithoutRMTransactionsNestedInput
    RMWastageLogs?: RM_WASTAGE_LOGSUpdateManyWithoutTransactionNestedInput
  }

  export type RM_TRANSACTIONSUncheckedUpdateWithoutRMQualityChecksInput = {
    id?: IntFieldUpdateOperationsInput | number
    rawMaterialId?: BigIntFieldUpdateOperationsInput | bigint | number
    quantity?: IntFieldUpdateOperationsInput | number
    transactionType?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    reason?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    initiatedById?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    RMWastageLogs?: RM_WASTAGE_LOGSUncheckedUpdateManyWithoutTransactionNestedInput
  }

  export type EmployeeUpsertWithoutRM_QCInput = {
    update: XOR<EmployeeUpdateWithoutRM_QCInput, EmployeeUncheckedUpdateWithoutRM_QCInput>
    create: XOR<EmployeeCreateWithoutRM_QCInput, EmployeeUncheckedCreateWithoutRM_QCInput>
    where?: EmployeeWhereInput
  }

  export type EmployeeUpdateToOneWithWhereWithoutRM_QCInput = {
    where?: EmployeeWhereInput
    data: XOR<EmployeeUpdateWithoutRM_QCInput, EmployeeUncheckedUpdateWithoutRM_QCInput>
  }

  export type EmployeeUpdateWithoutRM_QCInput = {
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumRolesFieldUpdateOperationsInput | $Enums.Roles
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    RM_QC2?: RM_QCUpdateManyWithoutDoneByNestedInput
    RMTransactions?: RM_TRANSACTIONSUpdateManyWithoutInitiatedByNestedInput
    WIPTransactions?: WIP_TRANSACTIONSUpdateManyWithoutInitiatedByNestedInput
    FGTransactions?: FG_TRANSACTIONSUpdateManyWithoutInitiatedByNestedInput
    AuditLogs?: AuditLogsUpdateManyWithoutChangedByNestedInput
  }

  export type EmployeeUncheckedUpdateWithoutRM_QCInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumRolesFieldUpdateOperationsInput | $Enums.Roles
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    RM_QC2?: RM_QCUncheckedUpdateManyWithoutDoneByNestedInput
    RMTransactions?: RM_TRANSACTIONSUncheckedUpdateManyWithoutInitiatedByNestedInput
    WIPTransactions?: WIP_TRANSACTIONSUncheckedUpdateManyWithoutInitiatedByNestedInput
    FGTransactions?: FG_TRANSACTIONSUncheckedUpdateManyWithoutInitiatedByNestedInput
    AuditLogs?: AuditLogsUncheckedUpdateManyWithoutChangedByNestedInput
  }

  export type EmployeeUpsertWithoutRM_QC2Input = {
    update: XOR<EmployeeUpdateWithoutRM_QC2Input, EmployeeUncheckedUpdateWithoutRM_QC2Input>
    create: XOR<EmployeeCreateWithoutRM_QC2Input, EmployeeUncheckedCreateWithoutRM_QC2Input>
    where?: EmployeeWhereInput
  }

  export type EmployeeUpdateToOneWithWhereWithoutRM_QC2Input = {
    where?: EmployeeWhereInput
    data: XOR<EmployeeUpdateWithoutRM_QC2Input, EmployeeUncheckedUpdateWithoutRM_QC2Input>
  }

  export type EmployeeUpdateWithoutRM_QC2Input = {
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumRolesFieldUpdateOperationsInput | $Enums.Roles
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    RM_QC?: RM_QCUpdateManyWithoutCheckedByNestedInput
    RMTransactions?: RM_TRANSACTIONSUpdateManyWithoutInitiatedByNestedInput
    WIPTransactions?: WIP_TRANSACTIONSUpdateManyWithoutInitiatedByNestedInput
    FGTransactions?: FG_TRANSACTIONSUpdateManyWithoutInitiatedByNestedInput
    AuditLogs?: AuditLogsUpdateManyWithoutChangedByNestedInput
  }

  export type EmployeeUncheckedUpdateWithoutRM_QC2Input = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumRolesFieldUpdateOperationsInput | $Enums.Roles
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    RM_QC?: RM_QCUncheckedUpdateManyWithoutCheckedByNestedInput
    RMTransactions?: RM_TRANSACTIONSUncheckedUpdateManyWithoutInitiatedByNestedInput
    WIPTransactions?: WIP_TRANSACTIONSUncheckedUpdateManyWithoutInitiatedByNestedInput
    FGTransactions?: FG_TRANSACTIONSUncheckedUpdateManyWithoutInitiatedByNestedInput
    AuditLogs?: AuditLogsUncheckedUpdateManyWithoutChangedByNestedInput
  }

  export type RAW_MATERIALSCreateWithoutRMWastageLogsInput = {
    id: bigint | number
    name: string
    SKU: string
    quantity: number
    price: Decimal | DecimalJsLike | number | string
    image?: string | null
    description?: string | null
    expiry_date: Date | string
    quality_status: $Enums.QualityStatus
    storage_location: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    VariantMaterials?: VARIANT_RAW_MATERIALS_TRACKERCreateNestedManyWithoutRawMaterialInput
    RMTransactions?: RM_TRANSACTIONSCreateNestedManyWithoutRawMaterialInput
    RMQualityChecks?: RM_QCCreateNestedManyWithoutRawMaterialInput
    WIPMaterials?: WIPRawMaterialCreateNestedManyWithoutRawMaterialInput
  }

  export type RAW_MATERIALSUncheckedCreateWithoutRMWastageLogsInput = {
    id: bigint | number
    name: string
    SKU: string
    quantity: number
    price: Decimal | DecimalJsLike | number | string
    image?: string | null
    description?: string | null
    expiry_date: Date | string
    quality_status: $Enums.QualityStatus
    storage_location: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    VariantMaterials?: VARIANT_RAW_MATERIALS_TRACKERUncheckedCreateNestedManyWithoutRawMaterialInput
    RMTransactions?: RM_TRANSACTIONSUncheckedCreateNestedManyWithoutRawMaterialInput
    RMQualityChecks?: RM_QCUncheckedCreateNestedManyWithoutRawMaterialInput
    WIPMaterials?: WIPRawMaterialUncheckedCreateNestedManyWithoutRawMaterialInput
  }

  export type RAW_MATERIALSCreateOrConnectWithoutRMWastageLogsInput = {
    where: RAW_MATERIALSWhereUniqueInput
    create: XOR<RAW_MATERIALSCreateWithoutRMWastageLogsInput, RAW_MATERIALSUncheckedCreateWithoutRMWastageLogsInput>
  }

  export type RM_TRANSACTIONSCreateWithoutRMWastageLogsInput = {
    quantity: number
    transactionType: $Enums.TransactionType
    reason: string
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    rawMaterial: RAW_MATERIALSCreateNestedOneWithoutRMTransactionsInput
    initiatedBy: EmployeeCreateNestedOneWithoutRMTransactionsInput
    RMQualityChecks?: RM_QCCreateNestedManyWithoutTransactionInput
  }

  export type RM_TRANSACTIONSUncheckedCreateWithoutRMWastageLogsInput = {
    id?: number
    rawMaterialId: bigint | number
    quantity: number
    transactionType: $Enums.TransactionType
    reason: string
    status: string
    initiatedById: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    RMQualityChecks?: RM_QCUncheckedCreateNestedManyWithoutTransactionInput
  }

  export type RM_TRANSACTIONSCreateOrConnectWithoutRMWastageLogsInput = {
    where: RM_TRANSACTIONSWhereUniqueInput
    create: XOR<RM_TRANSACTIONSCreateWithoutRMWastageLogsInput, RM_TRANSACTIONSUncheckedCreateWithoutRMWastageLogsInput>
  }

  export type RAW_MATERIALSUpsertWithoutRMWastageLogsInput = {
    update: XOR<RAW_MATERIALSUpdateWithoutRMWastageLogsInput, RAW_MATERIALSUncheckedUpdateWithoutRMWastageLogsInput>
    create: XOR<RAW_MATERIALSCreateWithoutRMWastageLogsInput, RAW_MATERIALSUncheckedCreateWithoutRMWastageLogsInput>
    where?: RAW_MATERIALSWhereInput
  }

  export type RAW_MATERIALSUpdateToOneWithWhereWithoutRMWastageLogsInput = {
    where?: RAW_MATERIALSWhereInput
    data: XOR<RAW_MATERIALSUpdateWithoutRMWastageLogsInput, RAW_MATERIALSUncheckedUpdateWithoutRMWastageLogsInput>
  }

  export type RAW_MATERIALSUpdateWithoutRMWastageLogsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    SKU?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    expiry_date?: DateTimeFieldUpdateOperationsInput | Date | string
    quality_status?: EnumQualityStatusFieldUpdateOperationsInput | $Enums.QualityStatus
    storage_location?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    VariantMaterials?: VARIANT_RAW_MATERIALS_TRACKERUpdateManyWithoutRawMaterialNestedInput
    RMTransactions?: RM_TRANSACTIONSUpdateManyWithoutRawMaterialNestedInput
    RMQualityChecks?: RM_QCUpdateManyWithoutRawMaterialNestedInput
    WIPMaterials?: WIPRawMaterialUpdateManyWithoutRawMaterialNestedInput
  }

  export type RAW_MATERIALSUncheckedUpdateWithoutRMWastageLogsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    SKU?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    expiry_date?: DateTimeFieldUpdateOperationsInput | Date | string
    quality_status?: EnumQualityStatusFieldUpdateOperationsInput | $Enums.QualityStatus
    storage_location?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    VariantMaterials?: VARIANT_RAW_MATERIALS_TRACKERUncheckedUpdateManyWithoutRawMaterialNestedInput
    RMTransactions?: RM_TRANSACTIONSUncheckedUpdateManyWithoutRawMaterialNestedInput
    RMQualityChecks?: RM_QCUncheckedUpdateManyWithoutRawMaterialNestedInput
    WIPMaterials?: WIPRawMaterialUncheckedUpdateManyWithoutRawMaterialNestedInput
  }

  export type RM_TRANSACTIONSUpsertWithoutRMWastageLogsInput = {
    update: XOR<RM_TRANSACTIONSUpdateWithoutRMWastageLogsInput, RM_TRANSACTIONSUncheckedUpdateWithoutRMWastageLogsInput>
    create: XOR<RM_TRANSACTIONSCreateWithoutRMWastageLogsInput, RM_TRANSACTIONSUncheckedCreateWithoutRMWastageLogsInput>
    where?: RM_TRANSACTIONSWhereInput
  }

  export type RM_TRANSACTIONSUpdateToOneWithWhereWithoutRMWastageLogsInput = {
    where?: RM_TRANSACTIONSWhereInput
    data: XOR<RM_TRANSACTIONSUpdateWithoutRMWastageLogsInput, RM_TRANSACTIONSUncheckedUpdateWithoutRMWastageLogsInput>
  }

  export type RM_TRANSACTIONSUpdateWithoutRMWastageLogsInput = {
    quantity?: IntFieldUpdateOperationsInput | number
    transactionType?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    reason?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rawMaterial?: RAW_MATERIALSUpdateOneRequiredWithoutRMTransactionsNestedInput
    initiatedBy?: EmployeeUpdateOneRequiredWithoutRMTransactionsNestedInput
    RMQualityChecks?: RM_QCUpdateManyWithoutTransactionNestedInput
  }

  export type RM_TRANSACTIONSUncheckedUpdateWithoutRMWastageLogsInput = {
    id?: IntFieldUpdateOperationsInput | number
    rawMaterialId?: BigIntFieldUpdateOperationsInput | bigint | number
    quantity?: IntFieldUpdateOperationsInput | number
    transactionType?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    reason?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    initiatedById?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    RMQualityChecks?: RM_QCUncheckedUpdateManyWithoutTransactionNestedInput
  }

  export type RM_QCCreateWithoutCheckedByInput = {
    quality_status: $Enums.QualityStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    rawMaterial: RAW_MATERIALSCreateNestedOneWithoutRMQualityChecksInput
    transaction: RM_TRANSACTIONSCreateNestedOneWithoutRMQualityChecksInput
    doneBy: EmployeeCreateNestedOneWithoutRM_QC2Input
  }

  export type RM_QCUncheckedCreateWithoutCheckedByInput = {
    id?: number
    transactionId: number
    rawMaterialId: bigint | number
    quality_status: $Enums.QualityStatus
    doneById: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type RM_QCCreateOrConnectWithoutCheckedByInput = {
    where: RM_QCWhereUniqueInput
    create: XOR<RM_QCCreateWithoutCheckedByInput, RM_QCUncheckedCreateWithoutCheckedByInput>
  }

  export type RM_QCCreateManyCheckedByInputEnvelope = {
    data: RM_QCCreateManyCheckedByInput | RM_QCCreateManyCheckedByInput[]
    skipDuplicates?: boolean
  }

  export type RM_QCCreateWithoutDoneByInput = {
    quality_status: $Enums.QualityStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    rawMaterial: RAW_MATERIALSCreateNestedOneWithoutRMQualityChecksInput
    transaction: RM_TRANSACTIONSCreateNestedOneWithoutRMQualityChecksInput
    checkedBy: EmployeeCreateNestedOneWithoutRM_QCInput
  }

  export type RM_QCUncheckedCreateWithoutDoneByInput = {
    id?: number
    transactionId: number
    rawMaterialId: bigint | number
    quality_status: $Enums.QualityStatus
    checkedById: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type RM_QCCreateOrConnectWithoutDoneByInput = {
    where: RM_QCWhereUniqueInput
    create: XOR<RM_QCCreateWithoutDoneByInput, RM_QCUncheckedCreateWithoutDoneByInput>
  }

  export type RM_QCCreateManyDoneByInputEnvelope = {
    data: RM_QCCreateManyDoneByInput | RM_QCCreateManyDoneByInput[]
    skipDuplicates?: boolean
  }

  export type RM_TRANSACTIONSCreateWithoutInitiatedByInput = {
    quantity: number
    transactionType: $Enums.TransactionType
    reason: string
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    rawMaterial: RAW_MATERIALSCreateNestedOneWithoutRMTransactionsInput
    RMQualityChecks?: RM_QCCreateNestedManyWithoutTransactionInput
    RMWastageLogs?: RM_WASTAGE_LOGSCreateNestedManyWithoutTransactionInput
  }

  export type RM_TRANSACTIONSUncheckedCreateWithoutInitiatedByInput = {
    id?: number
    rawMaterialId: bigint | number
    quantity: number
    transactionType: $Enums.TransactionType
    reason: string
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    RMQualityChecks?: RM_QCUncheckedCreateNestedManyWithoutTransactionInput
    RMWastageLogs?: RM_WASTAGE_LOGSUncheckedCreateNestedManyWithoutTransactionInput
  }

  export type RM_TRANSACTIONSCreateOrConnectWithoutInitiatedByInput = {
    where: RM_TRANSACTIONSWhereUniqueInput
    create: XOR<RM_TRANSACTIONSCreateWithoutInitiatedByInput, RM_TRANSACTIONSUncheckedCreateWithoutInitiatedByInput>
  }

  export type RM_TRANSACTIONSCreateManyInitiatedByInputEnvelope = {
    data: RM_TRANSACTIONSCreateManyInitiatedByInput | RM_TRANSACTIONSCreateManyInitiatedByInput[]
    skipDuplicates?: boolean
  }

  export type WIP_TRANSACTIONSCreateWithoutInitiatedByInput = {
    quantity: number
    transactionType: $Enums.TransactionType
    reason: string
    status: $Enums.Status
    createdAt?: Date | string
    updatedAt?: Date | string
    wip: WIPCreateNestedOneWithoutWIPTransactionsInput
    wipQC?: WIP_QCCreateNestedManyWithoutWIPTransactionsInput
    wipWasteLogs?: WIP_WASTAGE_LOGSCreateNestedManyWithoutWIPTransactionsInput
  }

  export type WIP_TRANSACTIONSUncheckedCreateWithoutInitiatedByInput = {
    id?: number
    wipId: number
    quantity: number
    transactionType: $Enums.TransactionType
    reason: string
    status: $Enums.Status
    createdAt?: Date | string
    updatedAt?: Date | string
    wipQC?: WIP_QCUncheckedCreateNestedManyWithoutWIPTransactionsInput
    wipWasteLogs?: WIP_WASTAGE_LOGSUncheckedCreateNestedManyWithoutWIPTransactionsInput
  }

  export type WIP_TRANSACTIONSCreateOrConnectWithoutInitiatedByInput = {
    where: WIP_TRANSACTIONSWhereUniqueInput
    create: XOR<WIP_TRANSACTIONSCreateWithoutInitiatedByInput, WIP_TRANSACTIONSUncheckedCreateWithoutInitiatedByInput>
  }

  export type WIP_TRANSACTIONSCreateManyInitiatedByInputEnvelope = {
    data: WIP_TRANSACTIONSCreateManyInitiatedByInput | WIP_TRANSACTIONSCreateManyInitiatedByInput[]
    skipDuplicates?: boolean
  }

  export type FG_TRANSACTIONSCreateWithoutInitiatedByInput = {
    quantity: number
    transactionType: $Enums.TransactionType
    status: $Enums.Status
    reason: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    fg: FGCreateNestedOneWithoutFGTransactionsInput
    fgQC?: FG_QCCreateNestedManyWithoutFGTransactionsInput
    fgWasteLogs?: FG_WASTAGE_LOGSCreateNestedManyWithoutFGTransactionsInput
  }

  export type FG_TRANSACTIONSUncheckedCreateWithoutInitiatedByInput = {
    id?: number
    fgId: number
    quantity: number
    transactionType: $Enums.TransactionType
    status: $Enums.Status
    reason: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    fgQC?: FG_QCUncheckedCreateNestedManyWithoutFGTransactionsInput
    fgWasteLogs?: FG_WASTAGE_LOGSUncheckedCreateNestedManyWithoutFGTransactionsInput
  }

  export type FG_TRANSACTIONSCreateOrConnectWithoutInitiatedByInput = {
    where: FG_TRANSACTIONSWhereUniqueInput
    create: XOR<FG_TRANSACTIONSCreateWithoutInitiatedByInput, FG_TRANSACTIONSUncheckedCreateWithoutInitiatedByInput>
  }

  export type FG_TRANSACTIONSCreateManyInitiatedByInputEnvelope = {
    data: FG_TRANSACTIONSCreateManyInitiatedByInput | FG_TRANSACTIONSCreateManyInitiatedByInput[]
    skipDuplicates?: boolean
  }

  export type AuditLogsCreateWithoutChangedByInput = {
    tableName: string
    action: $Enums.Actions
    oldValue?: NullableJsonNullValueInput | InputJsonValue
    newValue?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type AuditLogsUncheckedCreateWithoutChangedByInput = {
    id?: number
    tableName: string
    action: $Enums.Actions
    oldValue?: NullableJsonNullValueInput | InputJsonValue
    newValue?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type AuditLogsCreateOrConnectWithoutChangedByInput = {
    where: AuditLogsWhereUniqueInput
    create: XOR<AuditLogsCreateWithoutChangedByInput, AuditLogsUncheckedCreateWithoutChangedByInput>
  }

  export type AuditLogsCreateManyChangedByInputEnvelope = {
    data: AuditLogsCreateManyChangedByInput | AuditLogsCreateManyChangedByInput[]
    skipDuplicates?: boolean
  }

  export type RM_QCUpsertWithWhereUniqueWithoutCheckedByInput = {
    where: RM_QCWhereUniqueInput
    update: XOR<RM_QCUpdateWithoutCheckedByInput, RM_QCUncheckedUpdateWithoutCheckedByInput>
    create: XOR<RM_QCCreateWithoutCheckedByInput, RM_QCUncheckedCreateWithoutCheckedByInput>
  }

  export type RM_QCUpdateWithWhereUniqueWithoutCheckedByInput = {
    where: RM_QCWhereUniqueInput
    data: XOR<RM_QCUpdateWithoutCheckedByInput, RM_QCUncheckedUpdateWithoutCheckedByInput>
  }

  export type RM_QCUpdateManyWithWhereWithoutCheckedByInput = {
    where: RM_QCScalarWhereInput
    data: XOR<RM_QCUpdateManyMutationInput, RM_QCUncheckedUpdateManyWithoutCheckedByInput>
  }

  export type RM_QCUpsertWithWhereUniqueWithoutDoneByInput = {
    where: RM_QCWhereUniqueInput
    update: XOR<RM_QCUpdateWithoutDoneByInput, RM_QCUncheckedUpdateWithoutDoneByInput>
    create: XOR<RM_QCCreateWithoutDoneByInput, RM_QCUncheckedCreateWithoutDoneByInput>
  }

  export type RM_QCUpdateWithWhereUniqueWithoutDoneByInput = {
    where: RM_QCWhereUniqueInput
    data: XOR<RM_QCUpdateWithoutDoneByInput, RM_QCUncheckedUpdateWithoutDoneByInput>
  }

  export type RM_QCUpdateManyWithWhereWithoutDoneByInput = {
    where: RM_QCScalarWhereInput
    data: XOR<RM_QCUpdateManyMutationInput, RM_QCUncheckedUpdateManyWithoutDoneByInput>
  }

  export type RM_TRANSACTIONSUpsertWithWhereUniqueWithoutInitiatedByInput = {
    where: RM_TRANSACTIONSWhereUniqueInput
    update: XOR<RM_TRANSACTIONSUpdateWithoutInitiatedByInput, RM_TRANSACTIONSUncheckedUpdateWithoutInitiatedByInput>
    create: XOR<RM_TRANSACTIONSCreateWithoutInitiatedByInput, RM_TRANSACTIONSUncheckedCreateWithoutInitiatedByInput>
  }

  export type RM_TRANSACTIONSUpdateWithWhereUniqueWithoutInitiatedByInput = {
    where: RM_TRANSACTIONSWhereUniqueInput
    data: XOR<RM_TRANSACTIONSUpdateWithoutInitiatedByInput, RM_TRANSACTIONSUncheckedUpdateWithoutInitiatedByInput>
  }

  export type RM_TRANSACTIONSUpdateManyWithWhereWithoutInitiatedByInput = {
    where: RM_TRANSACTIONSScalarWhereInput
    data: XOR<RM_TRANSACTIONSUpdateManyMutationInput, RM_TRANSACTIONSUncheckedUpdateManyWithoutInitiatedByInput>
  }

  export type WIP_TRANSACTIONSUpsertWithWhereUniqueWithoutInitiatedByInput = {
    where: WIP_TRANSACTIONSWhereUniqueInput
    update: XOR<WIP_TRANSACTIONSUpdateWithoutInitiatedByInput, WIP_TRANSACTIONSUncheckedUpdateWithoutInitiatedByInput>
    create: XOR<WIP_TRANSACTIONSCreateWithoutInitiatedByInput, WIP_TRANSACTIONSUncheckedCreateWithoutInitiatedByInput>
  }

  export type WIP_TRANSACTIONSUpdateWithWhereUniqueWithoutInitiatedByInput = {
    where: WIP_TRANSACTIONSWhereUniqueInput
    data: XOR<WIP_TRANSACTIONSUpdateWithoutInitiatedByInput, WIP_TRANSACTIONSUncheckedUpdateWithoutInitiatedByInput>
  }

  export type WIP_TRANSACTIONSUpdateManyWithWhereWithoutInitiatedByInput = {
    where: WIP_TRANSACTIONSScalarWhereInput
    data: XOR<WIP_TRANSACTIONSUpdateManyMutationInput, WIP_TRANSACTIONSUncheckedUpdateManyWithoutInitiatedByInput>
  }

  export type WIP_TRANSACTIONSScalarWhereInput = {
    AND?: WIP_TRANSACTIONSScalarWhereInput | WIP_TRANSACTIONSScalarWhereInput[]
    OR?: WIP_TRANSACTIONSScalarWhereInput[]
    NOT?: WIP_TRANSACTIONSScalarWhereInput | WIP_TRANSACTIONSScalarWhereInput[]
    id?: IntFilter<"WIP_TRANSACTIONS"> | number
    wipId?: IntFilter<"WIP_TRANSACTIONS"> | number
    quantity?: IntFilter<"WIP_TRANSACTIONS"> | number
    transactionType?: EnumTransactionTypeFilter<"WIP_TRANSACTIONS"> | $Enums.TransactionType
    reason?: StringFilter<"WIP_TRANSACTIONS"> | string
    status?: EnumStatusFilter<"WIP_TRANSACTIONS"> | $Enums.Status
    initiatedById?: IntFilter<"WIP_TRANSACTIONS"> | number
    createdAt?: DateTimeFilter<"WIP_TRANSACTIONS"> | Date | string
    updatedAt?: DateTimeFilter<"WIP_TRANSACTIONS"> | Date | string
  }

  export type FG_TRANSACTIONSUpsertWithWhereUniqueWithoutInitiatedByInput = {
    where: FG_TRANSACTIONSWhereUniqueInput
    update: XOR<FG_TRANSACTIONSUpdateWithoutInitiatedByInput, FG_TRANSACTIONSUncheckedUpdateWithoutInitiatedByInput>
    create: XOR<FG_TRANSACTIONSCreateWithoutInitiatedByInput, FG_TRANSACTIONSUncheckedCreateWithoutInitiatedByInput>
  }

  export type FG_TRANSACTIONSUpdateWithWhereUniqueWithoutInitiatedByInput = {
    where: FG_TRANSACTIONSWhereUniqueInput
    data: XOR<FG_TRANSACTIONSUpdateWithoutInitiatedByInput, FG_TRANSACTIONSUncheckedUpdateWithoutInitiatedByInput>
  }

  export type FG_TRANSACTIONSUpdateManyWithWhereWithoutInitiatedByInput = {
    where: FG_TRANSACTIONSScalarWhereInput
    data: XOR<FG_TRANSACTIONSUpdateManyMutationInput, FG_TRANSACTIONSUncheckedUpdateManyWithoutInitiatedByInput>
  }

  export type FG_TRANSACTIONSScalarWhereInput = {
    AND?: FG_TRANSACTIONSScalarWhereInput | FG_TRANSACTIONSScalarWhereInput[]
    OR?: FG_TRANSACTIONSScalarWhereInput[]
    NOT?: FG_TRANSACTIONSScalarWhereInput | FG_TRANSACTIONSScalarWhereInput[]
    id?: IntFilter<"FG_TRANSACTIONS"> | number
    fgId?: IntFilter<"FG_TRANSACTIONS"> | number
    quantity?: IntFilter<"FG_TRANSACTIONS"> | number
    transactionType?: EnumTransactionTypeFilter<"FG_TRANSACTIONS"> | $Enums.TransactionType
    status?: EnumStatusFilter<"FG_TRANSACTIONS"> | $Enums.Status
    reason?: StringFilter<"FG_TRANSACTIONS"> | string
    IntiatedById?: IntFilter<"FG_TRANSACTIONS"> | number
    createdAt?: DateTimeFilter<"FG_TRANSACTIONS"> | Date | string
    updatedAt?: DateTimeFilter<"FG_TRANSACTIONS"> | Date | string
    deletedAt?: DateTimeNullableFilter<"FG_TRANSACTIONS"> | Date | string | null
  }

  export type AuditLogsUpsertWithWhereUniqueWithoutChangedByInput = {
    where: AuditLogsWhereUniqueInput
    update: XOR<AuditLogsUpdateWithoutChangedByInput, AuditLogsUncheckedUpdateWithoutChangedByInput>
    create: XOR<AuditLogsCreateWithoutChangedByInput, AuditLogsUncheckedCreateWithoutChangedByInput>
  }

  export type AuditLogsUpdateWithWhereUniqueWithoutChangedByInput = {
    where: AuditLogsWhereUniqueInput
    data: XOR<AuditLogsUpdateWithoutChangedByInput, AuditLogsUncheckedUpdateWithoutChangedByInput>
  }

  export type AuditLogsUpdateManyWithWhereWithoutChangedByInput = {
    where: AuditLogsScalarWhereInput
    data: XOR<AuditLogsUpdateManyMutationInput, AuditLogsUncheckedUpdateManyWithoutChangedByInput>
  }

  export type AuditLogsScalarWhereInput = {
    AND?: AuditLogsScalarWhereInput | AuditLogsScalarWhereInput[]
    OR?: AuditLogsScalarWhereInput[]
    NOT?: AuditLogsScalarWhereInput | AuditLogsScalarWhereInput[]
    id?: IntFilter<"AuditLogs"> | number
    tableName?: StringFilter<"AuditLogs"> | string
    action?: EnumActionsFilter<"AuditLogs"> | $Enums.Actions
    oldValue?: JsonNullableFilter<"AuditLogs">
    newValue?: JsonNullableFilter<"AuditLogs">
    changedById?: IntFilter<"AuditLogs"> | number
    createdAt?: DateTimeFilter<"AuditLogs"> | Date | string
  }

  export type WIP_TRANSACTIONSCreateWithoutWipInput = {
    quantity: number
    transactionType: $Enums.TransactionType
    reason: string
    status: $Enums.Status
    createdAt?: Date | string
    updatedAt?: Date | string
    initiatedBy: EmployeeCreateNestedOneWithoutWIPTransactionsInput
    wipQC?: WIP_QCCreateNestedManyWithoutWIPTransactionsInput
    wipWasteLogs?: WIP_WASTAGE_LOGSCreateNestedManyWithoutWIPTransactionsInput
  }

  export type WIP_TRANSACTIONSUncheckedCreateWithoutWipInput = {
    id?: number
    quantity: number
    transactionType: $Enums.TransactionType
    reason: string
    status: $Enums.Status
    initiatedById: number
    createdAt?: Date | string
    updatedAt?: Date | string
    wipQC?: WIP_QCUncheckedCreateNestedManyWithoutWIPTransactionsInput
    wipWasteLogs?: WIP_WASTAGE_LOGSUncheckedCreateNestedManyWithoutWIPTransactionsInput
  }

  export type WIP_TRANSACTIONSCreateOrConnectWithoutWipInput = {
    where: WIP_TRANSACTIONSWhereUniqueInput
    create: XOR<WIP_TRANSACTIONSCreateWithoutWipInput, WIP_TRANSACTIONSUncheckedCreateWithoutWipInput>
  }

  export type WIP_TRANSACTIONSCreateManyWipInputEnvelope = {
    data: WIP_TRANSACTIONSCreateManyWipInput | WIP_TRANSACTIONSCreateManyWipInput[]
    skipDuplicates?: boolean
  }

  export type WIP_QCCreateWithoutWipInput = {
    transactionType: $Enums.TransactionType
    quality_status: $Enums.QualityStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    WIPTransactions: WIP_TRANSACTIONSCreateNestedOneWithoutWipQCInput
  }

  export type WIP_QCUncheckedCreateWithoutWipInput = {
    id?: number
    transactionId: number
    transactionType: $Enums.TransactionType
    quality_status: $Enums.QualityStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WIP_QCCreateOrConnectWithoutWipInput = {
    where: WIP_QCWhereUniqueInput
    create: XOR<WIP_QCCreateWithoutWipInput, WIP_QCUncheckedCreateWithoutWipInput>
  }

  export type WIP_QCCreateManyWipInputEnvelope = {
    data: WIP_QCCreateManyWipInput | WIP_QCCreateManyWipInput[]
    skipDuplicates?: boolean
  }

  export type WIP_WASTAGE_LOGSCreateWithoutWipInput = {
    transactionType: $Enums.TransactionType
    quantity: number
    reason: string
    createdAt?: Date | string
    updatedAt?: Date | string
    WIPTransactions: WIP_TRANSACTIONSCreateNestedOneWithoutWipWasteLogsInput
  }

  export type WIP_WASTAGE_LOGSUncheckedCreateWithoutWipInput = {
    id?: number
    transactionId: number
    transactionType: $Enums.TransactionType
    quantity: number
    reason: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WIP_WASTAGE_LOGSCreateOrConnectWithoutWipInput = {
    where: WIP_WASTAGE_LOGSWhereUniqueInput
    create: XOR<WIP_WASTAGE_LOGSCreateWithoutWipInput, WIP_WASTAGE_LOGSUncheckedCreateWithoutWipInput>
  }

  export type WIP_WASTAGE_LOGSCreateManyWipInputEnvelope = {
    data: WIP_WASTAGE_LOGSCreateManyWipInput | WIP_WASTAGE_LOGSCreateManyWipInput[]
    skipDuplicates?: boolean
  }

  export type WIP_PRODUCTSCreateWithoutWipInput = {
    quantity: number
    product: SHOPIFY_PRODUCTSCreateNestedOneWithoutWIPProductsInput
  }

  export type WIP_PRODUCTSUncheckedCreateWithoutWipInput = {
    id?: number
    productId: bigint | number
    quantity: number
  }

  export type WIP_PRODUCTSCreateOrConnectWithoutWipInput = {
    where: WIP_PRODUCTSWhereUniqueInput
    create: XOR<WIP_PRODUCTSCreateWithoutWipInput, WIP_PRODUCTSUncheckedCreateWithoutWipInput>
  }

  export type WIP_PRODUCTSCreateManyWipInputEnvelope = {
    data: WIP_PRODUCTSCreateManyWipInput | WIP_PRODUCTSCreateManyWipInput[]
    skipDuplicates?: boolean
  }

  export type WIPRawMaterialCreateWithoutWipInput = {
    quantity: number
    rawMaterial: RAW_MATERIALSCreateNestedOneWithoutWIPMaterialsInput
  }

  export type WIPRawMaterialUncheckedCreateWithoutWipInput = {
    id?: number
    rawMaterialId: bigint | number
    quantity: number
  }

  export type WIPRawMaterialCreateOrConnectWithoutWipInput = {
    where: WIPRawMaterialWhereUniqueInput
    create: XOR<WIPRawMaterialCreateWithoutWipInput, WIPRawMaterialUncheckedCreateWithoutWipInput>
  }

  export type WIPRawMaterialCreateManyWipInputEnvelope = {
    data: WIPRawMaterialCreateManyWipInput | WIPRawMaterialCreateManyWipInput[]
    skipDuplicates?: boolean
  }

  export type WIP_TRANSACTIONSUpsertWithWhereUniqueWithoutWipInput = {
    where: WIP_TRANSACTIONSWhereUniqueInput
    update: XOR<WIP_TRANSACTIONSUpdateWithoutWipInput, WIP_TRANSACTIONSUncheckedUpdateWithoutWipInput>
    create: XOR<WIP_TRANSACTIONSCreateWithoutWipInput, WIP_TRANSACTIONSUncheckedCreateWithoutWipInput>
  }

  export type WIP_TRANSACTIONSUpdateWithWhereUniqueWithoutWipInput = {
    where: WIP_TRANSACTIONSWhereUniqueInput
    data: XOR<WIP_TRANSACTIONSUpdateWithoutWipInput, WIP_TRANSACTIONSUncheckedUpdateWithoutWipInput>
  }

  export type WIP_TRANSACTIONSUpdateManyWithWhereWithoutWipInput = {
    where: WIP_TRANSACTIONSScalarWhereInput
    data: XOR<WIP_TRANSACTIONSUpdateManyMutationInput, WIP_TRANSACTIONSUncheckedUpdateManyWithoutWipInput>
  }

  export type WIP_QCUpsertWithWhereUniqueWithoutWipInput = {
    where: WIP_QCWhereUniqueInput
    update: XOR<WIP_QCUpdateWithoutWipInput, WIP_QCUncheckedUpdateWithoutWipInput>
    create: XOR<WIP_QCCreateWithoutWipInput, WIP_QCUncheckedCreateWithoutWipInput>
  }

  export type WIP_QCUpdateWithWhereUniqueWithoutWipInput = {
    where: WIP_QCWhereUniqueInput
    data: XOR<WIP_QCUpdateWithoutWipInput, WIP_QCUncheckedUpdateWithoutWipInput>
  }

  export type WIP_QCUpdateManyWithWhereWithoutWipInput = {
    where: WIP_QCScalarWhereInput
    data: XOR<WIP_QCUpdateManyMutationInput, WIP_QCUncheckedUpdateManyWithoutWipInput>
  }

  export type WIP_QCScalarWhereInput = {
    AND?: WIP_QCScalarWhereInput | WIP_QCScalarWhereInput[]
    OR?: WIP_QCScalarWhereInput[]
    NOT?: WIP_QCScalarWhereInput | WIP_QCScalarWhereInput[]
    id?: IntFilter<"WIP_QC"> | number
    transactionId?: IntFilter<"WIP_QC"> | number
    transactionType?: EnumTransactionTypeFilter<"WIP_QC"> | $Enums.TransactionType
    wipId?: IntFilter<"WIP_QC"> | number
    quality_status?: EnumQualityStatusFilter<"WIP_QC"> | $Enums.QualityStatus
    createdAt?: DateTimeFilter<"WIP_QC"> | Date | string
    updatedAt?: DateTimeFilter<"WIP_QC"> | Date | string
  }

  export type WIP_WASTAGE_LOGSUpsertWithWhereUniqueWithoutWipInput = {
    where: WIP_WASTAGE_LOGSWhereUniqueInput
    update: XOR<WIP_WASTAGE_LOGSUpdateWithoutWipInput, WIP_WASTAGE_LOGSUncheckedUpdateWithoutWipInput>
    create: XOR<WIP_WASTAGE_LOGSCreateWithoutWipInput, WIP_WASTAGE_LOGSUncheckedCreateWithoutWipInput>
  }

  export type WIP_WASTAGE_LOGSUpdateWithWhereUniqueWithoutWipInput = {
    where: WIP_WASTAGE_LOGSWhereUniqueInput
    data: XOR<WIP_WASTAGE_LOGSUpdateWithoutWipInput, WIP_WASTAGE_LOGSUncheckedUpdateWithoutWipInput>
  }

  export type WIP_WASTAGE_LOGSUpdateManyWithWhereWithoutWipInput = {
    where: WIP_WASTAGE_LOGSScalarWhereInput
    data: XOR<WIP_WASTAGE_LOGSUpdateManyMutationInput, WIP_WASTAGE_LOGSUncheckedUpdateManyWithoutWipInput>
  }

  export type WIP_WASTAGE_LOGSScalarWhereInput = {
    AND?: WIP_WASTAGE_LOGSScalarWhereInput | WIP_WASTAGE_LOGSScalarWhereInput[]
    OR?: WIP_WASTAGE_LOGSScalarWhereInput[]
    NOT?: WIP_WASTAGE_LOGSScalarWhereInput | WIP_WASTAGE_LOGSScalarWhereInput[]
    id?: IntFilter<"WIP_WASTAGE_LOGS"> | number
    transactionId?: IntFilter<"WIP_WASTAGE_LOGS"> | number
    transactionType?: EnumTransactionTypeFilter<"WIP_WASTAGE_LOGS"> | $Enums.TransactionType
    wipId?: IntFilter<"WIP_WASTAGE_LOGS"> | number
    quantity?: IntFilter<"WIP_WASTAGE_LOGS"> | number
    reason?: StringFilter<"WIP_WASTAGE_LOGS"> | string
    createdAt?: DateTimeFilter<"WIP_WASTAGE_LOGS"> | Date | string
    updatedAt?: DateTimeFilter<"WIP_WASTAGE_LOGS"> | Date | string
  }

  export type WIP_PRODUCTSUpsertWithWhereUniqueWithoutWipInput = {
    where: WIP_PRODUCTSWhereUniqueInput
    update: XOR<WIP_PRODUCTSUpdateWithoutWipInput, WIP_PRODUCTSUncheckedUpdateWithoutWipInput>
    create: XOR<WIP_PRODUCTSCreateWithoutWipInput, WIP_PRODUCTSUncheckedCreateWithoutWipInput>
  }

  export type WIP_PRODUCTSUpdateWithWhereUniqueWithoutWipInput = {
    where: WIP_PRODUCTSWhereUniqueInput
    data: XOR<WIP_PRODUCTSUpdateWithoutWipInput, WIP_PRODUCTSUncheckedUpdateWithoutWipInput>
  }

  export type WIP_PRODUCTSUpdateManyWithWhereWithoutWipInput = {
    where: WIP_PRODUCTSScalarWhereInput
    data: XOR<WIP_PRODUCTSUpdateManyMutationInput, WIP_PRODUCTSUncheckedUpdateManyWithoutWipInput>
  }

  export type WIPRawMaterialUpsertWithWhereUniqueWithoutWipInput = {
    where: WIPRawMaterialWhereUniqueInput
    update: XOR<WIPRawMaterialUpdateWithoutWipInput, WIPRawMaterialUncheckedUpdateWithoutWipInput>
    create: XOR<WIPRawMaterialCreateWithoutWipInput, WIPRawMaterialUncheckedCreateWithoutWipInput>
  }

  export type WIPRawMaterialUpdateWithWhereUniqueWithoutWipInput = {
    where: WIPRawMaterialWhereUniqueInput
    data: XOR<WIPRawMaterialUpdateWithoutWipInput, WIPRawMaterialUncheckedUpdateWithoutWipInput>
  }

  export type WIPRawMaterialUpdateManyWithWhereWithoutWipInput = {
    where: WIPRawMaterialScalarWhereInput
    data: XOR<WIPRawMaterialUpdateManyMutationInput, WIPRawMaterialUncheckedUpdateManyWithoutWipInput>
  }

  export type WIPCreateWithoutWipProductsInput = {
    orderId: number
    status: $Enums.Status
    createdAt?: Date | string
    updatedAt?: Date | string
    WIPTransactions?: WIP_TRANSACTIONSCreateNestedManyWithoutWipInput
    WIPQCs?: WIP_QCCreateNestedManyWithoutWipInput
    WIPWastageLogs?: WIP_WASTAGE_LOGSCreateNestedManyWithoutWipInput
    WIPMaterials?: WIPRawMaterialCreateNestedManyWithoutWipInput
  }

  export type WIPUncheckedCreateWithoutWipProductsInput = {
    id?: number
    orderId: number
    status: $Enums.Status
    createdAt?: Date | string
    updatedAt?: Date | string
    WIPTransactions?: WIP_TRANSACTIONSUncheckedCreateNestedManyWithoutWipInput
    WIPQCs?: WIP_QCUncheckedCreateNestedManyWithoutWipInput
    WIPWastageLogs?: WIP_WASTAGE_LOGSUncheckedCreateNestedManyWithoutWipInput
    WIPMaterials?: WIPRawMaterialUncheckedCreateNestedManyWithoutWipInput
  }

  export type WIPCreateOrConnectWithoutWipProductsInput = {
    where: WIPWhereUniqueInput
    create: XOR<WIPCreateWithoutWipProductsInput, WIPUncheckedCreateWithoutWipProductsInput>
  }

  export type SHOPIFY_PRODUCTSCreateWithoutWIPProductsInput = {
    id: bigint | number
    name: string
    price: Decimal | DecimalJsLike | number | string
    status?: string | null
    img?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    category: CATEGORIESCreateNestedOneWithoutShopifyProductsInput
    ShopifyVariants?: SHOPIFY_VARIANTSCreateNestedManyWithoutProductInput
  }

  export type SHOPIFY_PRODUCTSUncheckedCreateWithoutWIPProductsInput = {
    id: bigint | number
    name: string
    categoryId: number
    price: Decimal | DecimalJsLike | number | string
    status?: string | null
    img?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    ShopifyVariants?: SHOPIFY_VARIANTSUncheckedCreateNestedManyWithoutProductInput
  }

  export type SHOPIFY_PRODUCTSCreateOrConnectWithoutWIPProductsInput = {
    where: SHOPIFY_PRODUCTSWhereUniqueInput
    create: XOR<SHOPIFY_PRODUCTSCreateWithoutWIPProductsInput, SHOPIFY_PRODUCTSUncheckedCreateWithoutWIPProductsInput>
  }

  export type WIPUpsertWithoutWipProductsInput = {
    update: XOR<WIPUpdateWithoutWipProductsInput, WIPUncheckedUpdateWithoutWipProductsInput>
    create: XOR<WIPCreateWithoutWipProductsInput, WIPUncheckedCreateWithoutWipProductsInput>
    where?: WIPWhereInput
  }

  export type WIPUpdateToOneWithWhereWithoutWipProductsInput = {
    where?: WIPWhereInput
    data: XOR<WIPUpdateWithoutWipProductsInput, WIPUncheckedUpdateWithoutWipProductsInput>
  }

  export type WIPUpdateWithoutWipProductsInput = {
    orderId?: IntFieldUpdateOperationsInput | number
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    WIPTransactions?: WIP_TRANSACTIONSUpdateManyWithoutWipNestedInput
    WIPQCs?: WIP_QCUpdateManyWithoutWipNestedInput
    WIPWastageLogs?: WIP_WASTAGE_LOGSUpdateManyWithoutWipNestedInput
    WIPMaterials?: WIPRawMaterialUpdateManyWithoutWipNestedInput
  }

  export type WIPUncheckedUpdateWithoutWipProductsInput = {
    id?: IntFieldUpdateOperationsInput | number
    orderId?: IntFieldUpdateOperationsInput | number
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    WIPTransactions?: WIP_TRANSACTIONSUncheckedUpdateManyWithoutWipNestedInput
    WIPQCs?: WIP_QCUncheckedUpdateManyWithoutWipNestedInput
    WIPWastageLogs?: WIP_WASTAGE_LOGSUncheckedUpdateManyWithoutWipNestedInput
    WIPMaterials?: WIPRawMaterialUncheckedUpdateManyWithoutWipNestedInput
  }

  export type SHOPIFY_PRODUCTSUpsertWithoutWIPProductsInput = {
    update: XOR<SHOPIFY_PRODUCTSUpdateWithoutWIPProductsInput, SHOPIFY_PRODUCTSUncheckedUpdateWithoutWIPProductsInput>
    create: XOR<SHOPIFY_PRODUCTSCreateWithoutWIPProductsInput, SHOPIFY_PRODUCTSUncheckedCreateWithoutWIPProductsInput>
    where?: SHOPIFY_PRODUCTSWhereInput
  }

  export type SHOPIFY_PRODUCTSUpdateToOneWithWhereWithoutWIPProductsInput = {
    where?: SHOPIFY_PRODUCTSWhereInput
    data: XOR<SHOPIFY_PRODUCTSUpdateWithoutWIPProductsInput, SHOPIFY_PRODUCTSUncheckedUpdateWithoutWIPProductsInput>
  }

  export type SHOPIFY_PRODUCTSUpdateWithoutWIPProductsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
    img?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: CATEGORIESUpdateOneRequiredWithoutShopifyProductsNestedInput
    ShopifyVariants?: SHOPIFY_VARIANTSUpdateManyWithoutProductNestedInput
  }

  export type SHOPIFY_PRODUCTSUncheckedUpdateWithoutWIPProductsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    categoryId?: IntFieldUpdateOperationsInput | number
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
    img?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ShopifyVariants?: SHOPIFY_VARIANTSUncheckedUpdateManyWithoutProductNestedInput
  }

  export type WIPCreateWithoutWIPMaterialsInput = {
    orderId: number
    status: $Enums.Status
    createdAt?: Date | string
    updatedAt?: Date | string
    WIPTransactions?: WIP_TRANSACTIONSCreateNestedManyWithoutWipInput
    WIPQCs?: WIP_QCCreateNestedManyWithoutWipInput
    WIPWastageLogs?: WIP_WASTAGE_LOGSCreateNestedManyWithoutWipInput
    wipProducts?: WIP_PRODUCTSCreateNestedManyWithoutWipInput
  }

  export type WIPUncheckedCreateWithoutWIPMaterialsInput = {
    id?: number
    orderId: number
    status: $Enums.Status
    createdAt?: Date | string
    updatedAt?: Date | string
    WIPTransactions?: WIP_TRANSACTIONSUncheckedCreateNestedManyWithoutWipInput
    WIPQCs?: WIP_QCUncheckedCreateNestedManyWithoutWipInput
    WIPWastageLogs?: WIP_WASTAGE_LOGSUncheckedCreateNestedManyWithoutWipInput
    wipProducts?: WIP_PRODUCTSUncheckedCreateNestedManyWithoutWipInput
  }

  export type WIPCreateOrConnectWithoutWIPMaterialsInput = {
    where: WIPWhereUniqueInput
    create: XOR<WIPCreateWithoutWIPMaterialsInput, WIPUncheckedCreateWithoutWIPMaterialsInput>
  }

  export type RAW_MATERIALSCreateWithoutWIPMaterialsInput = {
    id: bigint | number
    name: string
    SKU: string
    quantity: number
    price: Decimal | DecimalJsLike | number | string
    image?: string | null
    description?: string | null
    expiry_date: Date | string
    quality_status: $Enums.QualityStatus
    storage_location: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    VariantMaterials?: VARIANT_RAW_MATERIALS_TRACKERCreateNestedManyWithoutRawMaterialInput
    RMTransactions?: RM_TRANSACTIONSCreateNestedManyWithoutRawMaterialInput
    RMQualityChecks?: RM_QCCreateNestedManyWithoutRawMaterialInput
    RMWastageLogs?: RM_WASTAGE_LOGSCreateNestedManyWithoutRawMaterialInput
  }

  export type RAW_MATERIALSUncheckedCreateWithoutWIPMaterialsInput = {
    id: bigint | number
    name: string
    SKU: string
    quantity: number
    price: Decimal | DecimalJsLike | number | string
    image?: string | null
    description?: string | null
    expiry_date: Date | string
    quality_status: $Enums.QualityStatus
    storage_location: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    VariantMaterials?: VARIANT_RAW_MATERIALS_TRACKERUncheckedCreateNestedManyWithoutRawMaterialInput
    RMTransactions?: RM_TRANSACTIONSUncheckedCreateNestedManyWithoutRawMaterialInput
    RMQualityChecks?: RM_QCUncheckedCreateNestedManyWithoutRawMaterialInput
    RMWastageLogs?: RM_WASTAGE_LOGSUncheckedCreateNestedManyWithoutRawMaterialInput
  }

  export type RAW_MATERIALSCreateOrConnectWithoutWIPMaterialsInput = {
    where: RAW_MATERIALSWhereUniqueInput
    create: XOR<RAW_MATERIALSCreateWithoutWIPMaterialsInput, RAW_MATERIALSUncheckedCreateWithoutWIPMaterialsInput>
  }

  export type WIPUpsertWithoutWIPMaterialsInput = {
    update: XOR<WIPUpdateWithoutWIPMaterialsInput, WIPUncheckedUpdateWithoutWIPMaterialsInput>
    create: XOR<WIPCreateWithoutWIPMaterialsInput, WIPUncheckedCreateWithoutWIPMaterialsInput>
    where?: WIPWhereInput
  }

  export type WIPUpdateToOneWithWhereWithoutWIPMaterialsInput = {
    where?: WIPWhereInput
    data: XOR<WIPUpdateWithoutWIPMaterialsInput, WIPUncheckedUpdateWithoutWIPMaterialsInput>
  }

  export type WIPUpdateWithoutWIPMaterialsInput = {
    orderId?: IntFieldUpdateOperationsInput | number
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    WIPTransactions?: WIP_TRANSACTIONSUpdateManyWithoutWipNestedInput
    WIPQCs?: WIP_QCUpdateManyWithoutWipNestedInput
    WIPWastageLogs?: WIP_WASTAGE_LOGSUpdateManyWithoutWipNestedInput
    wipProducts?: WIP_PRODUCTSUpdateManyWithoutWipNestedInput
  }

  export type WIPUncheckedUpdateWithoutWIPMaterialsInput = {
    id?: IntFieldUpdateOperationsInput | number
    orderId?: IntFieldUpdateOperationsInput | number
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    WIPTransactions?: WIP_TRANSACTIONSUncheckedUpdateManyWithoutWipNestedInput
    WIPQCs?: WIP_QCUncheckedUpdateManyWithoutWipNestedInput
    WIPWastageLogs?: WIP_WASTAGE_LOGSUncheckedUpdateManyWithoutWipNestedInput
    wipProducts?: WIP_PRODUCTSUncheckedUpdateManyWithoutWipNestedInput
  }

  export type RAW_MATERIALSUpsertWithoutWIPMaterialsInput = {
    update: XOR<RAW_MATERIALSUpdateWithoutWIPMaterialsInput, RAW_MATERIALSUncheckedUpdateWithoutWIPMaterialsInput>
    create: XOR<RAW_MATERIALSCreateWithoutWIPMaterialsInput, RAW_MATERIALSUncheckedCreateWithoutWIPMaterialsInput>
    where?: RAW_MATERIALSWhereInput
  }

  export type RAW_MATERIALSUpdateToOneWithWhereWithoutWIPMaterialsInput = {
    where?: RAW_MATERIALSWhereInput
    data: XOR<RAW_MATERIALSUpdateWithoutWIPMaterialsInput, RAW_MATERIALSUncheckedUpdateWithoutWIPMaterialsInput>
  }

  export type RAW_MATERIALSUpdateWithoutWIPMaterialsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    SKU?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    expiry_date?: DateTimeFieldUpdateOperationsInput | Date | string
    quality_status?: EnumQualityStatusFieldUpdateOperationsInput | $Enums.QualityStatus
    storage_location?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    VariantMaterials?: VARIANT_RAW_MATERIALS_TRACKERUpdateManyWithoutRawMaterialNestedInput
    RMTransactions?: RM_TRANSACTIONSUpdateManyWithoutRawMaterialNestedInput
    RMQualityChecks?: RM_QCUpdateManyWithoutRawMaterialNestedInput
    RMWastageLogs?: RM_WASTAGE_LOGSUpdateManyWithoutRawMaterialNestedInput
  }

  export type RAW_MATERIALSUncheckedUpdateWithoutWIPMaterialsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    SKU?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    expiry_date?: DateTimeFieldUpdateOperationsInput | Date | string
    quality_status?: EnumQualityStatusFieldUpdateOperationsInput | $Enums.QualityStatus
    storage_location?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    VariantMaterials?: VARIANT_RAW_MATERIALS_TRACKERUncheckedUpdateManyWithoutRawMaterialNestedInput
    RMTransactions?: RM_TRANSACTIONSUncheckedUpdateManyWithoutRawMaterialNestedInput
    RMQualityChecks?: RM_QCUncheckedUpdateManyWithoutRawMaterialNestedInput
    RMWastageLogs?: RM_WASTAGE_LOGSUncheckedUpdateManyWithoutRawMaterialNestedInput
  }

  export type FG_TRANSACTIONSCreateWithoutFgInput = {
    quantity: number
    transactionType: $Enums.TransactionType
    status: $Enums.Status
    reason: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    initiatedBy: EmployeeCreateNestedOneWithoutFGTransactionsInput
    fgQC?: FG_QCCreateNestedManyWithoutFGTransactionsInput
    fgWasteLogs?: FG_WASTAGE_LOGSCreateNestedManyWithoutFGTransactionsInput
  }

  export type FG_TRANSACTIONSUncheckedCreateWithoutFgInput = {
    id?: number
    quantity: number
    transactionType: $Enums.TransactionType
    status: $Enums.Status
    reason: string
    IntiatedById: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    fgQC?: FG_QCUncheckedCreateNestedManyWithoutFGTransactionsInput
    fgWasteLogs?: FG_WASTAGE_LOGSUncheckedCreateNestedManyWithoutFGTransactionsInput
  }

  export type FG_TRANSACTIONSCreateOrConnectWithoutFgInput = {
    where: FG_TRANSACTIONSWhereUniqueInput
    create: XOR<FG_TRANSACTIONSCreateWithoutFgInput, FG_TRANSACTIONSUncheckedCreateWithoutFgInput>
  }

  export type FG_TRANSACTIONSCreateManyFgInputEnvelope = {
    data: FG_TRANSACTIONSCreateManyFgInput | FG_TRANSACTIONSCreateManyFgInput[]
    skipDuplicates?: boolean
  }

  export type FG_QCCreateWithoutFgInput = {
    transactionType: $Enums.TransactionType
    quality_status: $Enums.QualityStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    FGTransactions: FG_TRANSACTIONSCreateNestedOneWithoutFgQCInput
  }

  export type FG_QCUncheckedCreateWithoutFgInput = {
    id?: number
    transactionId: number
    transactionType: $Enums.TransactionType
    quality_status: $Enums.QualityStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FG_QCCreateOrConnectWithoutFgInput = {
    where: FG_QCWhereUniqueInput
    create: XOR<FG_QCCreateWithoutFgInput, FG_QCUncheckedCreateWithoutFgInput>
  }

  export type FG_QCCreateManyFgInputEnvelope = {
    data: FG_QCCreateManyFgInput | FG_QCCreateManyFgInput[]
    skipDuplicates?: boolean
  }

  export type FG_WASTAGE_LOGSCreateWithoutFgInput = {
    transactionType: $Enums.TransactionType
    quantity: number
    reason: string
    createdAt?: Date | string
    updatedAt?: Date | string
    FGTransactions: FG_TRANSACTIONSCreateNestedOneWithoutFgWasteLogsInput
  }

  export type FG_WASTAGE_LOGSUncheckedCreateWithoutFgInput = {
    id?: number
    transactionId: number
    transactionType: $Enums.TransactionType
    quantity: number
    reason: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FG_WASTAGE_LOGSCreateOrConnectWithoutFgInput = {
    where: FG_WASTAGE_LOGSWhereUniqueInput
    create: XOR<FG_WASTAGE_LOGSCreateWithoutFgInput, FG_WASTAGE_LOGSUncheckedCreateWithoutFgInput>
  }

  export type FG_WASTAGE_LOGSCreateManyFgInputEnvelope = {
    data: FG_WASTAGE_LOGSCreateManyFgInput | FG_WASTAGE_LOGSCreateManyFgInput[]
    skipDuplicates?: boolean
  }

  export type FG_PRODUCTSCreateWithoutFgInput = {
    productId: number
    quantity: number
  }

  export type FG_PRODUCTSUncheckedCreateWithoutFgInput = {
    id?: number
    productId: number
    quantity: number
  }

  export type FG_PRODUCTSCreateOrConnectWithoutFgInput = {
    where: FG_PRODUCTSWhereUniqueInput
    create: XOR<FG_PRODUCTSCreateWithoutFgInput, FG_PRODUCTSUncheckedCreateWithoutFgInput>
  }

  export type FG_PRODUCTSCreateManyFgInputEnvelope = {
    data: FG_PRODUCTSCreateManyFgInput | FG_PRODUCTSCreateManyFgInput[]
    skipDuplicates?: boolean
  }

  export type FG_TRANSACTIONSUpsertWithWhereUniqueWithoutFgInput = {
    where: FG_TRANSACTIONSWhereUniqueInput
    update: XOR<FG_TRANSACTIONSUpdateWithoutFgInput, FG_TRANSACTIONSUncheckedUpdateWithoutFgInput>
    create: XOR<FG_TRANSACTIONSCreateWithoutFgInput, FG_TRANSACTIONSUncheckedCreateWithoutFgInput>
  }

  export type FG_TRANSACTIONSUpdateWithWhereUniqueWithoutFgInput = {
    where: FG_TRANSACTIONSWhereUniqueInput
    data: XOR<FG_TRANSACTIONSUpdateWithoutFgInput, FG_TRANSACTIONSUncheckedUpdateWithoutFgInput>
  }

  export type FG_TRANSACTIONSUpdateManyWithWhereWithoutFgInput = {
    where: FG_TRANSACTIONSScalarWhereInput
    data: XOR<FG_TRANSACTIONSUpdateManyMutationInput, FG_TRANSACTIONSUncheckedUpdateManyWithoutFgInput>
  }

  export type FG_QCUpsertWithWhereUniqueWithoutFgInput = {
    where: FG_QCWhereUniqueInput
    update: XOR<FG_QCUpdateWithoutFgInput, FG_QCUncheckedUpdateWithoutFgInput>
    create: XOR<FG_QCCreateWithoutFgInput, FG_QCUncheckedCreateWithoutFgInput>
  }

  export type FG_QCUpdateWithWhereUniqueWithoutFgInput = {
    where: FG_QCWhereUniqueInput
    data: XOR<FG_QCUpdateWithoutFgInput, FG_QCUncheckedUpdateWithoutFgInput>
  }

  export type FG_QCUpdateManyWithWhereWithoutFgInput = {
    where: FG_QCScalarWhereInput
    data: XOR<FG_QCUpdateManyMutationInput, FG_QCUncheckedUpdateManyWithoutFgInput>
  }

  export type FG_QCScalarWhereInput = {
    AND?: FG_QCScalarWhereInput | FG_QCScalarWhereInput[]
    OR?: FG_QCScalarWhereInput[]
    NOT?: FG_QCScalarWhereInput | FG_QCScalarWhereInput[]
    id?: IntFilter<"FG_QC"> | number
    transactionId?: IntFilter<"FG_QC"> | number
    transactionType?: EnumTransactionTypeFilter<"FG_QC"> | $Enums.TransactionType
    fgId?: IntFilter<"FG_QC"> | number
    quality_status?: EnumQualityStatusFilter<"FG_QC"> | $Enums.QualityStatus
    createdAt?: DateTimeFilter<"FG_QC"> | Date | string
    updatedAt?: DateTimeFilter<"FG_QC"> | Date | string
  }

  export type FG_WASTAGE_LOGSUpsertWithWhereUniqueWithoutFgInput = {
    where: FG_WASTAGE_LOGSWhereUniqueInput
    update: XOR<FG_WASTAGE_LOGSUpdateWithoutFgInput, FG_WASTAGE_LOGSUncheckedUpdateWithoutFgInput>
    create: XOR<FG_WASTAGE_LOGSCreateWithoutFgInput, FG_WASTAGE_LOGSUncheckedCreateWithoutFgInput>
  }

  export type FG_WASTAGE_LOGSUpdateWithWhereUniqueWithoutFgInput = {
    where: FG_WASTAGE_LOGSWhereUniqueInput
    data: XOR<FG_WASTAGE_LOGSUpdateWithoutFgInput, FG_WASTAGE_LOGSUncheckedUpdateWithoutFgInput>
  }

  export type FG_WASTAGE_LOGSUpdateManyWithWhereWithoutFgInput = {
    where: FG_WASTAGE_LOGSScalarWhereInput
    data: XOR<FG_WASTAGE_LOGSUpdateManyMutationInput, FG_WASTAGE_LOGSUncheckedUpdateManyWithoutFgInput>
  }

  export type FG_WASTAGE_LOGSScalarWhereInput = {
    AND?: FG_WASTAGE_LOGSScalarWhereInput | FG_WASTAGE_LOGSScalarWhereInput[]
    OR?: FG_WASTAGE_LOGSScalarWhereInput[]
    NOT?: FG_WASTAGE_LOGSScalarWhereInput | FG_WASTAGE_LOGSScalarWhereInput[]
    id?: IntFilter<"FG_WASTAGE_LOGS"> | number
    transactionId?: IntFilter<"FG_WASTAGE_LOGS"> | number
    transactionType?: EnumTransactionTypeFilter<"FG_WASTAGE_LOGS"> | $Enums.TransactionType
    fgId?: IntFilter<"FG_WASTAGE_LOGS"> | number
    quantity?: IntFilter<"FG_WASTAGE_LOGS"> | number
    reason?: StringFilter<"FG_WASTAGE_LOGS"> | string
    createdAt?: DateTimeFilter<"FG_WASTAGE_LOGS"> | Date | string
    updatedAt?: DateTimeFilter<"FG_WASTAGE_LOGS"> | Date | string
  }

  export type FG_PRODUCTSUpsertWithWhereUniqueWithoutFgInput = {
    where: FG_PRODUCTSWhereUniqueInput
    update: XOR<FG_PRODUCTSUpdateWithoutFgInput, FG_PRODUCTSUncheckedUpdateWithoutFgInput>
    create: XOR<FG_PRODUCTSCreateWithoutFgInput, FG_PRODUCTSUncheckedCreateWithoutFgInput>
  }

  export type FG_PRODUCTSUpdateWithWhereUniqueWithoutFgInput = {
    where: FG_PRODUCTSWhereUniqueInput
    data: XOR<FG_PRODUCTSUpdateWithoutFgInput, FG_PRODUCTSUncheckedUpdateWithoutFgInput>
  }

  export type FG_PRODUCTSUpdateManyWithWhereWithoutFgInput = {
    where: FG_PRODUCTSScalarWhereInput
    data: XOR<FG_PRODUCTSUpdateManyMutationInput, FG_PRODUCTSUncheckedUpdateManyWithoutFgInput>
  }

  export type FG_PRODUCTSScalarWhereInput = {
    AND?: FG_PRODUCTSScalarWhereInput | FG_PRODUCTSScalarWhereInput[]
    OR?: FG_PRODUCTSScalarWhereInput[]
    NOT?: FG_PRODUCTSScalarWhereInput | FG_PRODUCTSScalarWhereInput[]
    id?: IntFilter<"FG_PRODUCTS"> | number
    fgId?: IntFilter<"FG_PRODUCTS"> | number
    productId?: IntFilter<"FG_PRODUCTS"> | number
    quantity?: IntFilter<"FG_PRODUCTS"> | number
  }

  export type FGCreateWithoutFgProductsInput = {
    orderId: number
    customerName: string
    price: Decimal | DecimalJsLike | number | string
    status: $Enums.Status
    createdAt?: Date | string
    deliveryDate: Date | string
    FGTransactions?: FG_TRANSACTIONSCreateNestedManyWithoutFgInput
    FGQCs?: FG_QCCreateNestedManyWithoutFgInput
    FGWastageLogs?: FG_WASTAGE_LOGSCreateNestedManyWithoutFgInput
  }

  export type FGUncheckedCreateWithoutFgProductsInput = {
    id?: number
    orderId: number
    customerName: string
    price: Decimal | DecimalJsLike | number | string
    status: $Enums.Status
    createdAt?: Date | string
    deliveryDate: Date | string
    FGTransactions?: FG_TRANSACTIONSUncheckedCreateNestedManyWithoutFgInput
    FGQCs?: FG_QCUncheckedCreateNestedManyWithoutFgInput
    FGWastageLogs?: FG_WASTAGE_LOGSUncheckedCreateNestedManyWithoutFgInput
  }

  export type FGCreateOrConnectWithoutFgProductsInput = {
    where: FGWhereUniqueInput
    create: XOR<FGCreateWithoutFgProductsInput, FGUncheckedCreateWithoutFgProductsInput>
  }

  export type FGUpsertWithoutFgProductsInput = {
    update: XOR<FGUpdateWithoutFgProductsInput, FGUncheckedUpdateWithoutFgProductsInput>
    create: XOR<FGCreateWithoutFgProductsInput, FGUncheckedCreateWithoutFgProductsInput>
    where?: FGWhereInput
  }

  export type FGUpdateToOneWithWhereWithoutFgProductsInput = {
    where?: FGWhereInput
    data: XOR<FGUpdateWithoutFgProductsInput, FGUncheckedUpdateWithoutFgProductsInput>
  }

  export type FGUpdateWithoutFgProductsInput = {
    orderId?: IntFieldUpdateOperationsInput | number
    customerName?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deliveryDate?: DateTimeFieldUpdateOperationsInput | Date | string
    FGTransactions?: FG_TRANSACTIONSUpdateManyWithoutFgNestedInput
    FGQCs?: FG_QCUpdateManyWithoutFgNestedInput
    FGWastageLogs?: FG_WASTAGE_LOGSUpdateManyWithoutFgNestedInput
  }

  export type FGUncheckedUpdateWithoutFgProductsInput = {
    id?: IntFieldUpdateOperationsInput | number
    orderId?: IntFieldUpdateOperationsInput | number
    customerName?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deliveryDate?: DateTimeFieldUpdateOperationsInput | Date | string
    FGTransactions?: FG_TRANSACTIONSUncheckedUpdateManyWithoutFgNestedInput
    FGQCs?: FG_QCUncheckedUpdateManyWithoutFgNestedInput
    FGWastageLogs?: FG_WASTAGE_LOGSUncheckedUpdateManyWithoutFgNestedInput
  }

  export type WIPCreateWithoutWIPTransactionsInput = {
    orderId: number
    status: $Enums.Status
    createdAt?: Date | string
    updatedAt?: Date | string
    WIPQCs?: WIP_QCCreateNestedManyWithoutWipInput
    WIPWastageLogs?: WIP_WASTAGE_LOGSCreateNestedManyWithoutWipInput
    wipProducts?: WIP_PRODUCTSCreateNestedManyWithoutWipInput
    WIPMaterials?: WIPRawMaterialCreateNestedManyWithoutWipInput
  }

  export type WIPUncheckedCreateWithoutWIPTransactionsInput = {
    id?: number
    orderId: number
    status: $Enums.Status
    createdAt?: Date | string
    updatedAt?: Date | string
    WIPQCs?: WIP_QCUncheckedCreateNestedManyWithoutWipInput
    WIPWastageLogs?: WIP_WASTAGE_LOGSUncheckedCreateNestedManyWithoutWipInput
    wipProducts?: WIP_PRODUCTSUncheckedCreateNestedManyWithoutWipInput
    WIPMaterials?: WIPRawMaterialUncheckedCreateNestedManyWithoutWipInput
  }

  export type WIPCreateOrConnectWithoutWIPTransactionsInput = {
    where: WIPWhereUniqueInput
    create: XOR<WIPCreateWithoutWIPTransactionsInput, WIPUncheckedCreateWithoutWIPTransactionsInput>
  }

  export type EmployeeCreateWithoutWIPTransactionsInput = {
    name: string
    role: $Enums.Roles
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    RM_QC?: RM_QCCreateNestedManyWithoutCheckedByInput
    RM_QC2?: RM_QCCreateNestedManyWithoutDoneByInput
    RMTransactions?: RM_TRANSACTIONSCreateNestedManyWithoutInitiatedByInput
    FGTransactions?: FG_TRANSACTIONSCreateNestedManyWithoutInitiatedByInput
    AuditLogs?: AuditLogsCreateNestedManyWithoutChangedByInput
  }

  export type EmployeeUncheckedCreateWithoutWIPTransactionsInput = {
    id?: number
    name: string
    role: $Enums.Roles
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    RM_QC?: RM_QCUncheckedCreateNestedManyWithoutCheckedByInput
    RM_QC2?: RM_QCUncheckedCreateNestedManyWithoutDoneByInput
    RMTransactions?: RM_TRANSACTIONSUncheckedCreateNestedManyWithoutInitiatedByInput
    FGTransactions?: FG_TRANSACTIONSUncheckedCreateNestedManyWithoutInitiatedByInput
    AuditLogs?: AuditLogsUncheckedCreateNestedManyWithoutChangedByInput
  }

  export type EmployeeCreateOrConnectWithoutWIPTransactionsInput = {
    where: EmployeeWhereUniqueInput
    create: XOR<EmployeeCreateWithoutWIPTransactionsInput, EmployeeUncheckedCreateWithoutWIPTransactionsInput>
  }

  export type WIP_QCCreateWithoutWIPTransactionsInput = {
    transactionType: $Enums.TransactionType
    quality_status: $Enums.QualityStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    wip: WIPCreateNestedOneWithoutWIPQCsInput
  }

  export type WIP_QCUncheckedCreateWithoutWIPTransactionsInput = {
    id?: number
    transactionType: $Enums.TransactionType
    wipId: number
    quality_status: $Enums.QualityStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WIP_QCCreateOrConnectWithoutWIPTransactionsInput = {
    where: WIP_QCWhereUniqueInput
    create: XOR<WIP_QCCreateWithoutWIPTransactionsInput, WIP_QCUncheckedCreateWithoutWIPTransactionsInput>
  }

  export type WIP_QCCreateManyWIPTransactionsInputEnvelope = {
    data: WIP_QCCreateManyWIPTransactionsInput | WIP_QCCreateManyWIPTransactionsInput[]
    skipDuplicates?: boolean
  }

  export type WIP_WASTAGE_LOGSCreateWithoutWIPTransactionsInput = {
    transactionType: $Enums.TransactionType
    quantity: number
    reason: string
    createdAt?: Date | string
    updatedAt?: Date | string
    wip: WIPCreateNestedOneWithoutWIPWastageLogsInput
  }

  export type WIP_WASTAGE_LOGSUncheckedCreateWithoutWIPTransactionsInput = {
    id?: number
    transactionType: $Enums.TransactionType
    wipId: number
    quantity: number
    reason: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WIP_WASTAGE_LOGSCreateOrConnectWithoutWIPTransactionsInput = {
    where: WIP_WASTAGE_LOGSWhereUniqueInput
    create: XOR<WIP_WASTAGE_LOGSCreateWithoutWIPTransactionsInput, WIP_WASTAGE_LOGSUncheckedCreateWithoutWIPTransactionsInput>
  }

  export type WIP_WASTAGE_LOGSCreateManyWIPTransactionsInputEnvelope = {
    data: WIP_WASTAGE_LOGSCreateManyWIPTransactionsInput | WIP_WASTAGE_LOGSCreateManyWIPTransactionsInput[]
    skipDuplicates?: boolean
  }

  export type WIPUpsertWithoutWIPTransactionsInput = {
    update: XOR<WIPUpdateWithoutWIPTransactionsInput, WIPUncheckedUpdateWithoutWIPTransactionsInput>
    create: XOR<WIPCreateWithoutWIPTransactionsInput, WIPUncheckedCreateWithoutWIPTransactionsInput>
    where?: WIPWhereInput
  }

  export type WIPUpdateToOneWithWhereWithoutWIPTransactionsInput = {
    where?: WIPWhereInput
    data: XOR<WIPUpdateWithoutWIPTransactionsInput, WIPUncheckedUpdateWithoutWIPTransactionsInput>
  }

  export type WIPUpdateWithoutWIPTransactionsInput = {
    orderId?: IntFieldUpdateOperationsInput | number
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    WIPQCs?: WIP_QCUpdateManyWithoutWipNestedInput
    WIPWastageLogs?: WIP_WASTAGE_LOGSUpdateManyWithoutWipNestedInput
    wipProducts?: WIP_PRODUCTSUpdateManyWithoutWipNestedInput
    WIPMaterials?: WIPRawMaterialUpdateManyWithoutWipNestedInput
  }

  export type WIPUncheckedUpdateWithoutWIPTransactionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    orderId?: IntFieldUpdateOperationsInput | number
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    WIPQCs?: WIP_QCUncheckedUpdateManyWithoutWipNestedInput
    WIPWastageLogs?: WIP_WASTAGE_LOGSUncheckedUpdateManyWithoutWipNestedInput
    wipProducts?: WIP_PRODUCTSUncheckedUpdateManyWithoutWipNestedInput
    WIPMaterials?: WIPRawMaterialUncheckedUpdateManyWithoutWipNestedInput
  }

  export type EmployeeUpsertWithoutWIPTransactionsInput = {
    update: XOR<EmployeeUpdateWithoutWIPTransactionsInput, EmployeeUncheckedUpdateWithoutWIPTransactionsInput>
    create: XOR<EmployeeCreateWithoutWIPTransactionsInput, EmployeeUncheckedCreateWithoutWIPTransactionsInput>
    where?: EmployeeWhereInput
  }

  export type EmployeeUpdateToOneWithWhereWithoutWIPTransactionsInput = {
    where?: EmployeeWhereInput
    data: XOR<EmployeeUpdateWithoutWIPTransactionsInput, EmployeeUncheckedUpdateWithoutWIPTransactionsInput>
  }

  export type EmployeeUpdateWithoutWIPTransactionsInput = {
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumRolesFieldUpdateOperationsInput | $Enums.Roles
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    RM_QC?: RM_QCUpdateManyWithoutCheckedByNestedInput
    RM_QC2?: RM_QCUpdateManyWithoutDoneByNestedInput
    RMTransactions?: RM_TRANSACTIONSUpdateManyWithoutInitiatedByNestedInput
    FGTransactions?: FG_TRANSACTIONSUpdateManyWithoutInitiatedByNestedInput
    AuditLogs?: AuditLogsUpdateManyWithoutChangedByNestedInput
  }

  export type EmployeeUncheckedUpdateWithoutWIPTransactionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumRolesFieldUpdateOperationsInput | $Enums.Roles
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    RM_QC?: RM_QCUncheckedUpdateManyWithoutCheckedByNestedInput
    RM_QC2?: RM_QCUncheckedUpdateManyWithoutDoneByNestedInput
    RMTransactions?: RM_TRANSACTIONSUncheckedUpdateManyWithoutInitiatedByNestedInput
    FGTransactions?: FG_TRANSACTIONSUncheckedUpdateManyWithoutInitiatedByNestedInput
    AuditLogs?: AuditLogsUncheckedUpdateManyWithoutChangedByNestedInput
  }

  export type WIP_QCUpsertWithWhereUniqueWithoutWIPTransactionsInput = {
    where: WIP_QCWhereUniqueInput
    update: XOR<WIP_QCUpdateWithoutWIPTransactionsInput, WIP_QCUncheckedUpdateWithoutWIPTransactionsInput>
    create: XOR<WIP_QCCreateWithoutWIPTransactionsInput, WIP_QCUncheckedCreateWithoutWIPTransactionsInput>
  }

  export type WIP_QCUpdateWithWhereUniqueWithoutWIPTransactionsInput = {
    where: WIP_QCWhereUniqueInput
    data: XOR<WIP_QCUpdateWithoutWIPTransactionsInput, WIP_QCUncheckedUpdateWithoutWIPTransactionsInput>
  }

  export type WIP_QCUpdateManyWithWhereWithoutWIPTransactionsInput = {
    where: WIP_QCScalarWhereInput
    data: XOR<WIP_QCUpdateManyMutationInput, WIP_QCUncheckedUpdateManyWithoutWIPTransactionsInput>
  }

  export type WIP_WASTAGE_LOGSUpsertWithWhereUniqueWithoutWIPTransactionsInput = {
    where: WIP_WASTAGE_LOGSWhereUniqueInput
    update: XOR<WIP_WASTAGE_LOGSUpdateWithoutWIPTransactionsInput, WIP_WASTAGE_LOGSUncheckedUpdateWithoutWIPTransactionsInput>
    create: XOR<WIP_WASTAGE_LOGSCreateWithoutWIPTransactionsInput, WIP_WASTAGE_LOGSUncheckedCreateWithoutWIPTransactionsInput>
  }

  export type WIP_WASTAGE_LOGSUpdateWithWhereUniqueWithoutWIPTransactionsInput = {
    where: WIP_WASTAGE_LOGSWhereUniqueInput
    data: XOR<WIP_WASTAGE_LOGSUpdateWithoutWIPTransactionsInput, WIP_WASTAGE_LOGSUncheckedUpdateWithoutWIPTransactionsInput>
  }

  export type WIP_WASTAGE_LOGSUpdateManyWithWhereWithoutWIPTransactionsInput = {
    where: WIP_WASTAGE_LOGSScalarWhereInput
    data: XOR<WIP_WASTAGE_LOGSUpdateManyMutationInput, WIP_WASTAGE_LOGSUncheckedUpdateManyWithoutWIPTransactionsInput>
  }

  export type FGCreateWithoutFGTransactionsInput = {
    orderId: number
    customerName: string
    price: Decimal | DecimalJsLike | number | string
    status: $Enums.Status
    createdAt?: Date | string
    deliveryDate: Date | string
    FGQCs?: FG_QCCreateNestedManyWithoutFgInput
    FGWastageLogs?: FG_WASTAGE_LOGSCreateNestedManyWithoutFgInput
    fgProducts?: FG_PRODUCTSCreateNestedManyWithoutFgInput
  }

  export type FGUncheckedCreateWithoutFGTransactionsInput = {
    id?: number
    orderId: number
    customerName: string
    price: Decimal | DecimalJsLike | number | string
    status: $Enums.Status
    createdAt?: Date | string
    deliveryDate: Date | string
    FGQCs?: FG_QCUncheckedCreateNestedManyWithoutFgInput
    FGWastageLogs?: FG_WASTAGE_LOGSUncheckedCreateNestedManyWithoutFgInput
    fgProducts?: FG_PRODUCTSUncheckedCreateNestedManyWithoutFgInput
  }

  export type FGCreateOrConnectWithoutFGTransactionsInput = {
    where: FGWhereUniqueInput
    create: XOR<FGCreateWithoutFGTransactionsInput, FGUncheckedCreateWithoutFGTransactionsInput>
  }

  export type EmployeeCreateWithoutFGTransactionsInput = {
    name: string
    role: $Enums.Roles
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    RM_QC?: RM_QCCreateNestedManyWithoutCheckedByInput
    RM_QC2?: RM_QCCreateNestedManyWithoutDoneByInput
    RMTransactions?: RM_TRANSACTIONSCreateNestedManyWithoutInitiatedByInput
    WIPTransactions?: WIP_TRANSACTIONSCreateNestedManyWithoutInitiatedByInput
    AuditLogs?: AuditLogsCreateNestedManyWithoutChangedByInput
  }

  export type EmployeeUncheckedCreateWithoutFGTransactionsInput = {
    id?: number
    name: string
    role: $Enums.Roles
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    RM_QC?: RM_QCUncheckedCreateNestedManyWithoutCheckedByInput
    RM_QC2?: RM_QCUncheckedCreateNestedManyWithoutDoneByInput
    RMTransactions?: RM_TRANSACTIONSUncheckedCreateNestedManyWithoutInitiatedByInput
    WIPTransactions?: WIP_TRANSACTIONSUncheckedCreateNestedManyWithoutInitiatedByInput
    AuditLogs?: AuditLogsUncheckedCreateNestedManyWithoutChangedByInput
  }

  export type EmployeeCreateOrConnectWithoutFGTransactionsInput = {
    where: EmployeeWhereUniqueInput
    create: XOR<EmployeeCreateWithoutFGTransactionsInput, EmployeeUncheckedCreateWithoutFGTransactionsInput>
  }

  export type FG_QCCreateWithoutFGTransactionsInput = {
    transactionType: $Enums.TransactionType
    quality_status: $Enums.QualityStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    fg: FGCreateNestedOneWithoutFGQCsInput
  }

  export type FG_QCUncheckedCreateWithoutFGTransactionsInput = {
    id?: number
    transactionType: $Enums.TransactionType
    fgId: number
    quality_status: $Enums.QualityStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FG_QCCreateOrConnectWithoutFGTransactionsInput = {
    where: FG_QCWhereUniqueInput
    create: XOR<FG_QCCreateWithoutFGTransactionsInput, FG_QCUncheckedCreateWithoutFGTransactionsInput>
  }

  export type FG_QCCreateManyFGTransactionsInputEnvelope = {
    data: FG_QCCreateManyFGTransactionsInput | FG_QCCreateManyFGTransactionsInput[]
    skipDuplicates?: boolean
  }

  export type FG_WASTAGE_LOGSCreateWithoutFGTransactionsInput = {
    transactionType: $Enums.TransactionType
    quantity: number
    reason: string
    createdAt?: Date | string
    updatedAt?: Date | string
    fg: FGCreateNestedOneWithoutFGWastageLogsInput
  }

  export type FG_WASTAGE_LOGSUncheckedCreateWithoutFGTransactionsInput = {
    id?: number
    transactionType: $Enums.TransactionType
    fgId: number
    quantity: number
    reason: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FG_WASTAGE_LOGSCreateOrConnectWithoutFGTransactionsInput = {
    where: FG_WASTAGE_LOGSWhereUniqueInput
    create: XOR<FG_WASTAGE_LOGSCreateWithoutFGTransactionsInput, FG_WASTAGE_LOGSUncheckedCreateWithoutFGTransactionsInput>
  }

  export type FG_WASTAGE_LOGSCreateManyFGTransactionsInputEnvelope = {
    data: FG_WASTAGE_LOGSCreateManyFGTransactionsInput | FG_WASTAGE_LOGSCreateManyFGTransactionsInput[]
    skipDuplicates?: boolean
  }

  export type FGUpsertWithoutFGTransactionsInput = {
    update: XOR<FGUpdateWithoutFGTransactionsInput, FGUncheckedUpdateWithoutFGTransactionsInput>
    create: XOR<FGCreateWithoutFGTransactionsInput, FGUncheckedCreateWithoutFGTransactionsInput>
    where?: FGWhereInput
  }

  export type FGUpdateToOneWithWhereWithoutFGTransactionsInput = {
    where?: FGWhereInput
    data: XOR<FGUpdateWithoutFGTransactionsInput, FGUncheckedUpdateWithoutFGTransactionsInput>
  }

  export type FGUpdateWithoutFGTransactionsInput = {
    orderId?: IntFieldUpdateOperationsInput | number
    customerName?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deliveryDate?: DateTimeFieldUpdateOperationsInput | Date | string
    FGQCs?: FG_QCUpdateManyWithoutFgNestedInput
    FGWastageLogs?: FG_WASTAGE_LOGSUpdateManyWithoutFgNestedInput
    fgProducts?: FG_PRODUCTSUpdateManyWithoutFgNestedInput
  }

  export type FGUncheckedUpdateWithoutFGTransactionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    orderId?: IntFieldUpdateOperationsInput | number
    customerName?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deliveryDate?: DateTimeFieldUpdateOperationsInput | Date | string
    FGQCs?: FG_QCUncheckedUpdateManyWithoutFgNestedInput
    FGWastageLogs?: FG_WASTAGE_LOGSUncheckedUpdateManyWithoutFgNestedInput
    fgProducts?: FG_PRODUCTSUncheckedUpdateManyWithoutFgNestedInput
  }

  export type EmployeeUpsertWithoutFGTransactionsInput = {
    update: XOR<EmployeeUpdateWithoutFGTransactionsInput, EmployeeUncheckedUpdateWithoutFGTransactionsInput>
    create: XOR<EmployeeCreateWithoutFGTransactionsInput, EmployeeUncheckedCreateWithoutFGTransactionsInput>
    where?: EmployeeWhereInput
  }

  export type EmployeeUpdateToOneWithWhereWithoutFGTransactionsInput = {
    where?: EmployeeWhereInput
    data: XOR<EmployeeUpdateWithoutFGTransactionsInput, EmployeeUncheckedUpdateWithoutFGTransactionsInput>
  }

  export type EmployeeUpdateWithoutFGTransactionsInput = {
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumRolesFieldUpdateOperationsInput | $Enums.Roles
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    RM_QC?: RM_QCUpdateManyWithoutCheckedByNestedInput
    RM_QC2?: RM_QCUpdateManyWithoutDoneByNestedInput
    RMTransactions?: RM_TRANSACTIONSUpdateManyWithoutInitiatedByNestedInput
    WIPTransactions?: WIP_TRANSACTIONSUpdateManyWithoutInitiatedByNestedInput
    AuditLogs?: AuditLogsUpdateManyWithoutChangedByNestedInput
  }

  export type EmployeeUncheckedUpdateWithoutFGTransactionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumRolesFieldUpdateOperationsInput | $Enums.Roles
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    RM_QC?: RM_QCUncheckedUpdateManyWithoutCheckedByNestedInput
    RM_QC2?: RM_QCUncheckedUpdateManyWithoutDoneByNestedInput
    RMTransactions?: RM_TRANSACTIONSUncheckedUpdateManyWithoutInitiatedByNestedInput
    WIPTransactions?: WIP_TRANSACTIONSUncheckedUpdateManyWithoutInitiatedByNestedInput
    AuditLogs?: AuditLogsUncheckedUpdateManyWithoutChangedByNestedInput
  }

  export type FG_QCUpsertWithWhereUniqueWithoutFGTransactionsInput = {
    where: FG_QCWhereUniqueInput
    update: XOR<FG_QCUpdateWithoutFGTransactionsInput, FG_QCUncheckedUpdateWithoutFGTransactionsInput>
    create: XOR<FG_QCCreateWithoutFGTransactionsInput, FG_QCUncheckedCreateWithoutFGTransactionsInput>
  }

  export type FG_QCUpdateWithWhereUniqueWithoutFGTransactionsInput = {
    where: FG_QCWhereUniqueInput
    data: XOR<FG_QCUpdateWithoutFGTransactionsInput, FG_QCUncheckedUpdateWithoutFGTransactionsInput>
  }

  export type FG_QCUpdateManyWithWhereWithoutFGTransactionsInput = {
    where: FG_QCScalarWhereInput
    data: XOR<FG_QCUpdateManyMutationInput, FG_QCUncheckedUpdateManyWithoutFGTransactionsInput>
  }

  export type FG_WASTAGE_LOGSUpsertWithWhereUniqueWithoutFGTransactionsInput = {
    where: FG_WASTAGE_LOGSWhereUniqueInput
    update: XOR<FG_WASTAGE_LOGSUpdateWithoutFGTransactionsInput, FG_WASTAGE_LOGSUncheckedUpdateWithoutFGTransactionsInput>
    create: XOR<FG_WASTAGE_LOGSCreateWithoutFGTransactionsInput, FG_WASTAGE_LOGSUncheckedCreateWithoutFGTransactionsInput>
  }

  export type FG_WASTAGE_LOGSUpdateWithWhereUniqueWithoutFGTransactionsInput = {
    where: FG_WASTAGE_LOGSWhereUniqueInput
    data: XOR<FG_WASTAGE_LOGSUpdateWithoutFGTransactionsInput, FG_WASTAGE_LOGSUncheckedUpdateWithoutFGTransactionsInput>
  }

  export type FG_WASTAGE_LOGSUpdateManyWithWhereWithoutFGTransactionsInput = {
    where: FG_WASTAGE_LOGSScalarWhereInput
    data: XOR<FG_WASTAGE_LOGSUpdateManyMutationInput, FG_WASTAGE_LOGSUncheckedUpdateManyWithoutFGTransactionsInput>
  }

  export type WIPCreateWithoutWIPQCsInput = {
    orderId: number
    status: $Enums.Status
    createdAt?: Date | string
    updatedAt?: Date | string
    WIPTransactions?: WIP_TRANSACTIONSCreateNestedManyWithoutWipInput
    WIPWastageLogs?: WIP_WASTAGE_LOGSCreateNestedManyWithoutWipInput
    wipProducts?: WIP_PRODUCTSCreateNestedManyWithoutWipInput
    WIPMaterials?: WIPRawMaterialCreateNestedManyWithoutWipInput
  }

  export type WIPUncheckedCreateWithoutWIPQCsInput = {
    id?: number
    orderId: number
    status: $Enums.Status
    createdAt?: Date | string
    updatedAt?: Date | string
    WIPTransactions?: WIP_TRANSACTIONSUncheckedCreateNestedManyWithoutWipInput
    WIPWastageLogs?: WIP_WASTAGE_LOGSUncheckedCreateNestedManyWithoutWipInput
    wipProducts?: WIP_PRODUCTSUncheckedCreateNestedManyWithoutWipInput
    WIPMaterials?: WIPRawMaterialUncheckedCreateNestedManyWithoutWipInput
  }

  export type WIPCreateOrConnectWithoutWIPQCsInput = {
    where: WIPWhereUniqueInput
    create: XOR<WIPCreateWithoutWIPQCsInput, WIPUncheckedCreateWithoutWIPQCsInput>
  }

  export type WIP_TRANSACTIONSCreateWithoutWipQCInput = {
    quantity: number
    transactionType: $Enums.TransactionType
    reason: string
    status: $Enums.Status
    createdAt?: Date | string
    updatedAt?: Date | string
    wip: WIPCreateNestedOneWithoutWIPTransactionsInput
    initiatedBy: EmployeeCreateNestedOneWithoutWIPTransactionsInput
    wipWasteLogs?: WIP_WASTAGE_LOGSCreateNestedManyWithoutWIPTransactionsInput
  }

  export type WIP_TRANSACTIONSUncheckedCreateWithoutWipQCInput = {
    id?: number
    wipId: number
    quantity: number
    transactionType: $Enums.TransactionType
    reason: string
    status: $Enums.Status
    initiatedById: number
    createdAt?: Date | string
    updatedAt?: Date | string
    wipWasteLogs?: WIP_WASTAGE_LOGSUncheckedCreateNestedManyWithoutWIPTransactionsInput
  }

  export type WIP_TRANSACTIONSCreateOrConnectWithoutWipQCInput = {
    where: WIP_TRANSACTIONSWhereUniqueInput
    create: XOR<WIP_TRANSACTIONSCreateWithoutWipQCInput, WIP_TRANSACTIONSUncheckedCreateWithoutWipQCInput>
  }

  export type WIPUpsertWithoutWIPQCsInput = {
    update: XOR<WIPUpdateWithoutWIPQCsInput, WIPUncheckedUpdateWithoutWIPQCsInput>
    create: XOR<WIPCreateWithoutWIPQCsInput, WIPUncheckedCreateWithoutWIPQCsInput>
    where?: WIPWhereInput
  }

  export type WIPUpdateToOneWithWhereWithoutWIPQCsInput = {
    where?: WIPWhereInput
    data: XOR<WIPUpdateWithoutWIPQCsInput, WIPUncheckedUpdateWithoutWIPQCsInput>
  }

  export type WIPUpdateWithoutWIPQCsInput = {
    orderId?: IntFieldUpdateOperationsInput | number
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    WIPTransactions?: WIP_TRANSACTIONSUpdateManyWithoutWipNestedInput
    WIPWastageLogs?: WIP_WASTAGE_LOGSUpdateManyWithoutWipNestedInput
    wipProducts?: WIP_PRODUCTSUpdateManyWithoutWipNestedInput
    WIPMaterials?: WIPRawMaterialUpdateManyWithoutWipNestedInput
  }

  export type WIPUncheckedUpdateWithoutWIPQCsInput = {
    id?: IntFieldUpdateOperationsInput | number
    orderId?: IntFieldUpdateOperationsInput | number
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    WIPTransactions?: WIP_TRANSACTIONSUncheckedUpdateManyWithoutWipNestedInput
    WIPWastageLogs?: WIP_WASTAGE_LOGSUncheckedUpdateManyWithoutWipNestedInput
    wipProducts?: WIP_PRODUCTSUncheckedUpdateManyWithoutWipNestedInput
    WIPMaterials?: WIPRawMaterialUncheckedUpdateManyWithoutWipNestedInput
  }

  export type WIP_TRANSACTIONSUpsertWithoutWipQCInput = {
    update: XOR<WIP_TRANSACTIONSUpdateWithoutWipQCInput, WIP_TRANSACTIONSUncheckedUpdateWithoutWipQCInput>
    create: XOR<WIP_TRANSACTIONSCreateWithoutWipQCInput, WIP_TRANSACTIONSUncheckedCreateWithoutWipQCInput>
    where?: WIP_TRANSACTIONSWhereInput
  }

  export type WIP_TRANSACTIONSUpdateToOneWithWhereWithoutWipQCInput = {
    where?: WIP_TRANSACTIONSWhereInput
    data: XOR<WIP_TRANSACTIONSUpdateWithoutWipQCInput, WIP_TRANSACTIONSUncheckedUpdateWithoutWipQCInput>
  }

  export type WIP_TRANSACTIONSUpdateWithoutWipQCInput = {
    quantity?: IntFieldUpdateOperationsInput | number
    transactionType?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    reason?: StringFieldUpdateOperationsInput | string
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    wip?: WIPUpdateOneRequiredWithoutWIPTransactionsNestedInput
    initiatedBy?: EmployeeUpdateOneRequiredWithoutWIPTransactionsNestedInput
    wipWasteLogs?: WIP_WASTAGE_LOGSUpdateManyWithoutWIPTransactionsNestedInput
  }

  export type WIP_TRANSACTIONSUncheckedUpdateWithoutWipQCInput = {
    id?: IntFieldUpdateOperationsInput | number
    wipId?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    transactionType?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    reason?: StringFieldUpdateOperationsInput | string
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    initiatedById?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    wipWasteLogs?: WIP_WASTAGE_LOGSUncheckedUpdateManyWithoutWIPTransactionsNestedInput
  }

  export type FGCreateWithoutFGQCsInput = {
    orderId: number
    customerName: string
    price: Decimal | DecimalJsLike | number | string
    status: $Enums.Status
    createdAt?: Date | string
    deliveryDate: Date | string
    FGTransactions?: FG_TRANSACTIONSCreateNestedManyWithoutFgInput
    FGWastageLogs?: FG_WASTAGE_LOGSCreateNestedManyWithoutFgInput
    fgProducts?: FG_PRODUCTSCreateNestedManyWithoutFgInput
  }

  export type FGUncheckedCreateWithoutFGQCsInput = {
    id?: number
    orderId: number
    customerName: string
    price: Decimal | DecimalJsLike | number | string
    status: $Enums.Status
    createdAt?: Date | string
    deliveryDate: Date | string
    FGTransactions?: FG_TRANSACTIONSUncheckedCreateNestedManyWithoutFgInput
    FGWastageLogs?: FG_WASTAGE_LOGSUncheckedCreateNestedManyWithoutFgInput
    fgProducts?: FG_PRODUCTSUncheckedCreateNestedManyWithoutFgInput
  }

  export type FGCreateOrConnectWithoutFGQCsInput = {
    where: FGWhereUniqueInput
    create: XOR<FGCreateWithoutFGQCsInput, FGUncheckedCreateWithoutFGQCsInput>
  }

  export type FG_TRANSACTIONSCreateWithoutFgQCInput = {
    quantity: number
    transactionType: $Enums.TransactionType
    status: $Enums.Status
    reason: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    fg: FGCreateNestedOneWithoutFGTransactionsInput
    initiatedBy: EmployeeCreateNestedOneWithoutFGTransactionsInput
    fgWasteLogs?: FG_WASTAGE_LOGSCreateNestedManyWithoutFGTransactionsInput
  }

  export type FG_TRANSACTIONSUncheckedCreateWithoutFgQCInput = {
    id?: number
    fgId: number
    quantity: number
    transactionType: $Enums.TransactionType
    status: $Enums.Status
    reason: string
    IntiatedById: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    fgWasteLogs?: FG_WASTAGE_LOGSUncheckedCreateNestedManyWithoutFGTransactionsInput
  }

  export type FG_TRANSACTIONSCreateOrConnectWithoutFgQCInput = {
    where: FG_TRANSACTIONSWhereUniqueInput
    create: XOR<FG_TRANSACTIONSCreateWithoutFgQCInput, FG_TRANSACTIONSUncheckedCreateWithoutFgQCInput>
  }

  export type FGUpsertWithoutFGQCsInput = {
    update: XOR<FGUpdateWithoutFGQCsInput, FGUncheckedUpdateWithoutFGQCsInput>
    create: XOR<FGCreateWithoutFGQCsInput, FGUncheckedCreateWithoutFGQCsInput>
    where?: FGWhereInput
  }

  export type FGUpdateToOneWithWhereWithoutFGQCsInput = {
    where?: FGWhereInput
    data: XOR<FGUpdateWithoutFGQCsInput, FGUncheckedUpdateWithoutFGQCsInput>
  }

  export type FGUpdateWithoutFGQCsInput = {
    orderId?: IntFieldUpdateOperationsInput | number
    customerName?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deliveryDate?: DateTimeFieldUpdateOperationsInput | Date | string
    FGTransactions?: FG_TRANSACTIONSUpdateManyWithoutFgNestedInput
    FGWastageLogs?: FG_WASTAGE_LOGSUpdateManyWithoutFgNestedInput
    fgProducts?: FG_PRODUCTSUpdateManyWithoutFgNestedInput
  }

  export type FGUncheckedUpdateWithoutFGQCsInput = {
    id?: IntFieldUpdateOperationsInput | number
    orderId?: IntFieldUpdateOperationsInput | number
    customerName?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deliveryDate?: DateTimeFieldUpdateOperationsInput | Date | string
    FGTransactions?: FG_TRANSACTIONSUncheckedUpdateManyWithoutFgNestedInput
    FGWastageLogs?: FG_WASTAGE_LOGSUncheckedUpdateManyWithoutFgNestedInput
    fgProducts?: FG_PRODUCTSUncheckedUpdateManyWithoutFgNestedInput
  }

  export type FG_TRANSACTIONSUpsertWithoutFgQCInput = {
    update: XOR<FG_TRANSACTIONSUpdateWithoutFgQCInput, FG_TRANSACTIONSUncheckedUpdateWithoutFgQCInput>
    create: XOR<FG_TRANSACTIONSCreateWithoutFgQCInput, FG_TRANSACTIONSUncheckedCreateWithoutFgQCInput>
    where?: FG_TRANSACTIONSWhereInput
  }

  export type FG_TRANSACTIONSUpdateToOneWithWhereWithoutFgQCInput = {
    where?: FG_TRANSACTIONSWhereInput
    data: XOR<FG_TRANSACTIONSUpdateWithoutFgQCInput, FG_TRANSACTIONSUncheckedUpdateWithoutFgQCInput>
  }

  export type FG_TRANSACTIONSUpdateWithoutFgQCInput = {
    quantity?: IntFieldUpdateOperationsInput | number
    transactionType?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    reason?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fg?: FGUpdateOneRequiredWithoutFGTransactionsNestedInput
    initiatedBy?: EmployeeUpdateOneRequiredWithoutFGTransactionsNestedInput
    fgWasteLogs?: FG_WASTAGE_LOGSUpdateManyWithoutFGTransactionsNestedInput
  }

  export type FG_TRANSACTIONSUncheckedUpdateWithoutFgQCInput = {
    id?: IntFieldUpdateOperationsInput | number
    fgId?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    transactionType?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    reason?: StringFieldUpdateOperationsInput | string
    IntiatedById?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fgWasteLogs?: FG_WASTAGE_LOGSUncheckedUpdateManyWithoutFGTransactionsNestedInput
  }

  export type WIPCreateWithoutWIPWastageLogsInput = {
    orderId: number
    status: $Enums.Status
    createdAt?: Date | string
    updatedAt?: Date | string
    WIPTransactions?: WIP_TRANSACTIONSCreateNestedManyWithoutWipInput
    WIPQCs?: WIP_QCCreateNestedManyWithoutWipInput
    wipProducts?: WIP_PRODUCTSCreateNestedManyWithoutWipInput
    WIPMaterials?: WIPRawMaterialCreateNestedManyWithoutWipInput
  }

  export type WIPUncheckedCreateWithoutWIPWastageLogsInput = {
    id?: number
    orderId: number
    status: $Enums.Status
    createdAt?: Date | string
    updatedAt?: Date | string
    WIPTransactions?: WIP_TRANSACTIONSUncheckedCreateNestedManyWithoutWipInput
    WIPQCs?: WIP_QCUncheckedCreateNestedManyWithoutWipInput
    wipProducts?: WIP_PRODUCTSUncheckedCreateNestedManyWithoutWipInput
    WIPMaterials?: WIPRawMaterialUncheckedCreateNestedManyWithoutWipInput
  }

  export type WIPCreateOrConnectWithoutWIPWastageLogsInput = {
    where: WIPWhereUniqueInput
    create: XOR<WIPCreateWithoutWIPWastageLogsInput, WIPUncheckedCreateWithoutWIPWastageLogsInput>
  }

  export type WIP_TRANSACTIONSCreateWithoutWipWasteLogsInput = {
    quantity: number
    transactionType: $Enums.TransactionType
    reason: string
    status: $Enums.Status
    createdAt?: Date | string
    updatedAt?: Date | string
    wip: WIPCreateNestedOneWithoutWIPTransactionsInput
    initiatedBy: EmployeeCreateNestedOneWithoutWIPTransactionsInput
    wipQC?: WIP_QCCreateNestedManyWithoutWIPTransactionsInput
  }

  export type WIP_TRANSACTIONSUncheckedCreateWithoutWipWasteLogsInput = {
    id?: number
    wipId: number
    quantity: number
    transactionType: $Enums.TransactionType
    reason: string
    status: $Enums.Status
    initiatedById: number
    createdAt?: Date | string
    updatedAt?: Date | string
    wipQC?: WIP_QCUncheckedCreateNestedManyWithoutWIPTransactionsInput
  }

  export type WIP_TRANSACTIONSCreateOrConnectWithoutWipWasteLogsInput = {
    where: WIP_TRANSACTIONSWhereUniqueInput
    create: XOR<WIP_TRANSACTIONSCreateWithoutWipWasteLogsInput, WIP_TRANSACTIONSUncheckedCreateWithoutWipWasteLogsInput>
  }

  export type WIPUpsertWithoutWIPWastageLogsInput = {
    update: XOR<WIPUpdateWithoutWIPWastageLogsInput, WIPUncheckedUpdateWithoutWIPWastageLogsInput>
    create: XOR<WIPCreateWithoutWIPWastageLogsInput, WIPUncheckedCreateWithoutWIPWastageLogsInput>
    where?: WIPWhereInput
  }

  export type WIPUpdateToOneWithWhereWithoutWIPWastageLogsInput = {
    where?: WIPWhereInput
    data: XOR<WIPUpdateWithoutWIPWastageLogsInput, WIPUncheckedUpdateWithoutWIPWastageLogsInput>
  }

  export type WIPUpdateWithoutWIPWastageLogsInput = {
    orderId?: IntFieldUpdateOperationsInput | number
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    WIPTransactions?: WIP_TRANSACTIONSUpdateManyWithoutWipNestedInput
    WIPQCs?: WIP_QCUpdateManyWithoutWipNestedInput
    wipProducts?: WIP_PRODUCTSUpdateManyWithoutWipNestedInput
    WIPMaterials?: WIPRawMaterialUpdateManyWithoutWipNestedInput
  }

  export type WIPUncheckedUpdateWithoutWIPWastageLogsInput = {
    id?: IntFieldUpdateOperationsInput | number
    orderId?: IntFieldUpdateOperationsInput | number
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    WIPTransactions?: WIP_TRANSACTIONSUncheckedUpdateManyWithoutWipNestedInput
    WIPQCs?: WIP_QCUncheckedUpdateManyWithoutWipNestedInput
    wipProducts?: WIP_PRODUCTSUncheckedUpdateManyWithoutWipNestedInput
    WIPMaterials?: WIPRawMaterialUncheckedUpdateManyWithoutWipNestedInput
  }

  export type WIP_TRANSACTIONSUpsertWithoutWipWasteLogsInput = {
    update: XOR<WIP_TRANSACTIONSUpdateWithoutWipWasteLogsInput, WIP_TRANSACTIONSUncheckedUpdateWithoutWipWasteLogsInput>
    create: XOR<WIP_TRANSACTIONSCreateWithoutWipWasteLogsInput, WIP_TRANSACTIONSUncheckedCreateWithoutWipWasteLogsInput>
    where?: WIP_TRANSACTIONSWhereInput
  }

  export type WIP_TRANSACTIONSUpdateToOneWithWhereWithoutWipWasteLogsInput = {
    where?: WIP_TRANSACTIONSWhereInput
    data: XOR<WIP_TRANSACTIONSUpdateWithoutWipWasteLogsInput, WIP_TRANSACTIONSUncheckedUpdateWithoutWipWasteLogsInput>
  }

  export type WIP_TRANSACTIONSUpdateWithoutWipWasteLogsInput = {
    quantity?: IntFieldUpdateOperationsInput | number
    transactionType?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    reason?: StringFieldUpdateOperationsInput | string
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    wip?: WIPUpdateOneRequiredWithoutWIPTransactionsNestedInput
    initiatedBy?: EmployeeUpdateOneRequiredWithoutWIPTransactionsNestedInput
    wipQC?: WIP_QCUpdateManyWithoutWIPTransactionsNestedInput
  }

  export type WIP_TRANSACTIONSUncheckedUpdateWithoutWipWasteLogsInput = {
    id?: IntFieldUpdateOperationsInput | number
    wipId?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    transactionType?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    reason?: StringFieldUpdateOperationsInput | string
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    initiatedById?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    wipQC?: WIP_QCUncheckedUpdateManyWithoutWIPTransactionsNestedInput
  }

  export type FGCreateWithoutFGWastageLogsInput = {
    orderId: number
    customerName: string
    price: Decimal | DecimalJsLike | number | string
    status: $Enums.Status
    createdAt?: Date | string
    deliveryDate: Date | string
    FGTransactions?: FG_TRANSACTIONSCreateNestedManyWithoutFgInput
    FGQCs?: FG_QCCreateNestedManyWithoutFgInput
    fgProducts?: FG_PRODUCTSCreateNestedManyWithoutFgInput
  }

  export type FGUncheckedCreateWithoutFGWastageLogsInput = {
    id?: number
    orderId: number
    customerName: string
    price: Decimal | DecimalJsLike | number | string
    status: $Enums.Status
    createdAt?: Date | string
    deliveryDate: Date | string
    FGTransactions?: FG_TRANSACTIONSUncheckedCreateNestedManyWithoutFgInput
    FGQCs?: FG_QCUncheckedCreateNestedManyWithoutFgInput
    fgProducts?: FG_PRODUCTSUncheckedCreateNestedManyWithoutFgInput
  }

  export type FGCreateOrConnectWithoutFGWastageLogsInput = {
    where: FGWhereUniqueInput
    create: XOR<FGCreateWithoutFGWastageLogsInput, FGUncheckedCreateWithoutFGWastageLogsInput>
  }

  export type FG_TRANSACTIONSCreateWithoutFgWasteLogsInput = {
    quantity: number
    transactionType: $Enums.TransactionType
    status: $Enums.Status
    reason: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    fg: FGCreateNestedOneWithoutFGTransactionsInput
    initiatedBy: EmployeeCreateNestedOneWithoutFGTransactionsInput
    fgQC?: FG_QCCreateNestedManyWithoutFGTransactionsInput
  }

  export type FG_TRANSACTIONSUncheckedCreateWithoutFgWasteLogsInput = {
    id?: number
    fgId: number
    quantity: number
    transactionType: $Enums.TransactionType
    status: $Enums.Status
    reason: string
    IntiatedById: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    fgQC?: FG_QCUncheckedCreateNestedManyWithoutFGTransactionsInput
  }

  export type FG_TRANSACTIONSCreateOrConnectWithoutFgWasteLogsInput = {
    where: FG_TRANSACTIONSWhereUniqueInput
    create: XOR<FG_TRANSACTIONSCreateWithoutFgWasteLogsInput, FG_TRANSACTIONSUncheckedCreateWithoutFgWasteLogsInput>
  }

  export type FGUpsertWithoutFGWastageLogsInput = {
    update: XOR<FGUpdateWithoutFGWastageLogsInput, FGUncheckedUpdateWithoutFGWastageLogsInput>
    create: XOR<FGCreateWithoutFGWastageLogsInput, FGUncheckedCreateWithoutFGWastageLogsInput>
    where?: FGWhereInput
  }

  export type FGUpdateToOneWithWhereWithoutFGWastageLogsInput = {
    where?: FGWhereInput
    data: XOR<FGUpdateWithoutFGWastageLogsInput, FGUncheckedUpdateWithoutFGWastageLogsInput>
  }

  export type FGUpdateWithoutFGWastageLogsInput = {
    orderId?: IntFieldUpdateOperationsInput | number
    customerName?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deliveryDate?: DateTimeFieldUpdateOperationsInput | Date | string
    FGTransactions?: FG_TRANSACTIONSUpdateManyWithoutFgNestedInput
    FGQCs?: FG_QCUpdateManyWithoutFgNestedInput
    fgProducts?: FG_PRODUCTSUpdateManyWithoutFgNestedInput
  }

  export type FGUncheckedUpdateWithoutFGWastageLogsInput = {
    id?: IntFieldUpdateOperationsInput | number
    orderId?: IntFieldUpdateOperationsInput | number
    customerName?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deliveryDate?: DateTimeFieldUpdateOperationsInput | Date | string
    FGTransactions?: FG_TRANSACTIONSUncheckedUpdateManyWithoutFgNestedInput
    FGQCs?: FG_QCUncheckedUpdateManyWithoutFgNestedInput
    fgProducts?: FG_PRODUCTSUncheckedUpdateManyWithoutFgNestedInput
  }

  export type FG_TRANSACTIONSUpsertWithoutFgWasteLogsInput = {
    update: XOR<FG_TRANSACTIONSUpdateWithoutFgWasteLogsInput, FG_TRANSACTIONSUncheckedUpdateWithoutFgWasteLogsInput>
    create: XOR<FG_TRANSACTIONSCreateWithoutFgWasteLogsInput, FG_TRANSACTIONSUncheckedCreateWithoutFgWasteLogsInput>
    where?: FG_TRANSACTIONSWhereInput
  }

  export type FG_TRANSACTIONSUpdateToOneWithWhereWithoutFgWasteLogsInput = {
    where?: FG_TRANSACTIONSWhereInput
    data: XOR<FG_TRANSACTIONSUpdateWithoutFgWasteLogsInput, FG_TRANSACTIONSUncheckedUpdateWithoutFgWasteLogsInput>
  }

  export type FG_TRANSACTIONSUpdateWithoutFgWasteLogsInput = {
    quantity?: IntFieldUpdateOperationsInput | number
    transactionType?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    reason?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fg?: FGUpdateOneRequiredWithoutFGTransactionsNestedInput
    initiatedBy?: EmployeeUpdateOneRequiredWithoutFGTransactionsNestedInput
    fgQC?: FG_QCUpdateManyWithoutFGTransactionsNestedInput
  }

  export type FG_TRANSACTIONSUncheckedUpdateWithoutFgWasteLogsInput = {
    id?: IntFieldUpdateOperationsInput | number
    fgId?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    transactionType?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    reason?: StringFieldUpdateOperationsInput | string
    IntiatedById?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fgQC?: FG_QCUncheckedUpdateManyWithoutFGTransactionsNestedInput
  }

  export type EmployeeCreateWithoutAuditLogsInput = {
    name: string
    role: $Enums.Roles
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    RM_QC?: RM_QCCreateNestedManyWithoutCheckedByInput
    RM_QC2?: RM_QCCreateNestedManyWithoutDoneByInput
    RMTransactions?: RM_TRANSACTIONSCreateNestedManyWithoutInitiatedByInput
    WIPTransactions?: WIP_TRANSACTIONSCreateNestedManyWithoutInitiatedByInput
    FGTransactions?: FG_TRANSACTIONSCreateNestedManyWithoutInitiatedByInput
  }

  export type EmployeeUncheckedCreateWithoutAuditLogsInput = {
    id?: number
    name: string
    role: $Enums.Roles
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    RM_QC?: RM_QCUncheckedCreateNestedManyWithoutCheckedByInput
    RM_QC2?: RM_QCUncheckedCreateNestedManyWithoutDoneByInput
    RMTransactions?: RM_TRANSACTIONSUncheckedCreateNestedManyWithoutInitiatedByInput
    WIPTransactions?: WIP_TRANSACTIONSUncheckedCreateNestedManyWithoutInitiatedByInput
    FGTransactions?: FG_TRANSACTIONSUncheckedCreateNestedManyWithoutInitiatedByInput
  }

  export type EmployeeCreateOrConnectWithoutAuditLogsInput = {
    where: EmployeeWhereUniqueInput
    create: XOR<EmployeeCreateWithoutAuditLogsInput, EmployeeUncheckedCreateWithoutAuditLogsInput>
  }

  export type EmployeeUpsertWithoutAuditLogsInput = {
    update: XOR<EmployeeUpdateWithoutAuditLogsInput, EmployeeUncheckedUpdateWithoutAuditLogsInput>
    create: XOR<EmployeeCreateWithoutAuditLogsInput, EmployeeUncheckedCreateWithoutAuditLogsInput>
    where?: EmployeeWhereInput
  }

  export type EmployeeUpdateToOneWithWhereWithoutAuditLogsInput = {
    where?: EmployeeWhereInput
    data: XOR<EmployeeUpdateWithoutAuditLogsInput, EmployeeUncheckedUpdateWithoutAuditLogsInput>
  }

  export type EmployeeUpdateWithoutAuditLogsInput = {
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumRolesFieldUpdateOperationsInput | $Enums.Roles
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    RM_QC?: RM_QCUpdateManyWithoutCheckedByNestedInput
    RM_QC2?: RM_QCUpdateManyWithoutDoneByNestedInput
    RMTransactions?: RM_TRANSACTIONSUpdateManyWithoutInitiatedByNestedInput
    WIPTransactions?: WIP_TRANSACTIONSUpdateManyWithoutInitiatedByNestedInput
    FGTransactions?: FG_TRANSACTIONSUpdateManyWithoutInitiatedByNestedInput
  }

  export type EmployeeUncheckedUpdateWithoutAuditLogsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumRolesFieldUpdateOperationsInput | $Enums.Roles
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    RM_QC?: RM_QCUncheckedUpdateManyWithoutCheckedByNestedInput
    RM_QC2?: RM_QCUncheckedUpdateManyWithoutDoneByNestedInput
    RMTransactions?: RM_TRANSACTIONSUncheckedUpdateManyWithoutInitiatedByNestedInput
    WIPTransactions?: WIP_TRANSACTIONSUncheckedUpdateManyWithoutInitiatedByNestedInput
    FGTransactions?: FG_TRANSACTIONSUncheckedUpdateManyWithoutInitiatedByNestedInput
  }

  export type VARIANT_RAW_MATERIALS_TRACKERCreateManyRawMaterialInput = {
    variantId: bigint | number
    avgQuantity: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type RM_TRANSACTIONSCreateManyRawMaterialInput = {
    id?: number
    quantity: number
    transactionType: $Enums.TransactionType
    reason: string
    status: string
    initiatedById: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type RM_QCCreateManyRawMaterialInput = {
    id?: number
    transactionId: number
    quality_status: $Enums.QualityStatus
    checkedById: number
    doneById: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type RM_WASTAGE_LOGSCreateManyRawMaterialInput = {
    id?: number
    transactionId: number
    quantity: number
    reason: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type WIPRawMaterialCreateManyRawMaterialInput = {
    id?: number
    wipId: number
    quantity: number
  }

  export type VARIANT_RAW_MATERIALS_TRACKERUpdateWithoutRawMaterialInput = {
    avgQuantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    variant?: SHOPIFY_VARIANTSUpdateOneRequiredWithoutVariantMaterialsNestedInput
  }

  export type VARIANT_RAW_MATERIALS_TRACKERUncheckedUpdateWithoutRawMaterialInput = {
    variantId?: BigIntFieldUpdateOperationsInput | bigint | number
    avgQuantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type VARIANT_RAW_MATERIALS_TRACKERUncheckedUpdateManyWithoutRawMaterialInput = {
    variantId?: BigIntFieldUpdateOperationsInput | bigint | number
    avgQuantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type RM_TRANSACTIONSUpdateWithoutRawMaterialInput = {
    quantity?: IntFieldUpdateOperationsInput | number
    transactionType?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    reason?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    initiatedBy?: EmployeeUpdateOneRequiredWithoutRMTransactionsNestedInput
    RMQualityChecks?: RM_QCUpdateManyWithoutTransactionNestedInput
    RMWastageLogs?: RM_WASTAGE_LOGSUpdateManyWithoutTransactionNestedInput
  }

  export type RM_TRANSACTIONSUncheckedUpdateWithoutRawMaterialInput = {
    id?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    transactionType?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    reason?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    initiatedById?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    RMQualityChecks?: RM_QCUncheckedUpdateManyWithoutTransactionNestedInput
    RMWastageLogs?: RM_WASTAGE_LOGSUncheckedUpdateManyWithoutTransactionNestedInput
  }

  export type RM_TRANSACTIONSUncheckedUpdateManyWithoutRawMaterialInput = {
    id?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    transactionType?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    reason?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    initiatedById?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type RM_QCUpdateWithoutRawMaterialInput = {
    quality_status?: EnumQualityStatusFieldUpdateOperationsInput | $Enums.QualityStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    transaction?: RM_TRANSACTIONSUpdateOneRequiredWithoutRMQualityChecksNestedInput
    checkedBy?: EmployeeUpdateOneRequiredWithoutRM_QCNestedInput
    doneBy?: EmployeeUpdateOneRequiredWithoutRM_QC2NestedInput
  }

  export type RM_QCUncheckedUpdateWithoutRawMaterialInput = {
    id?: IntFieldUpdateOperationsInput | number
    transactionId?: IntFieldUpdateOperationsInput | number
    quality_status?: EnumQualityStatusFieldUpdateOperationsInput | $Enums.QualityStatus
    checkedById?: IntFieldUpdateOperationsInput | number
    doneById?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type RM_QCUncheckedUpdateManyWithoutRawMaterialInput = {
    id?: IntFieldUpdateOperationsInput | number
    transactionId?: IntFieldUpdateOperationsInput | number
    quality_status?: EnumQualityStatusFieldUpdateOperationsInput | $Enums.QualityStatus
    checkedById?: IntFieldUpdateOperationsInput | number
    doneById?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type RM_WASTAGE_LOGSUpdateWithoutRawMaterialInput = {
    quantity?: IntFieldUpdateOperationsInput | number
    reason?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    transaction?: RM_TRANSACTIONSUpdateOneRequiredWithoutRMWastageLogsNestedInput
  }

  export type RM_WASTAGE_LOGSUncheckedUpdateWithoutRawMaterialInput = {
    id?: IntFieldUpdateOperationsInput | number
    transactionId?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    reason?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type RM_WASTAGE_LOGSUncheckedUpdateManyWithoutRawMaterialInput = {
    id?: IntFieldUpdateOperationsInput | number
    transactionId?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    reason?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type WIPRawMaterialUpdateWithoutRawMaterialInput = {
    quantity?: IntFieldUpdateOperationsInput | number
    wip?: WIPUpdateOneRequiredWithoutWIPMaterialsNestedInput
  }

  export type WIPRawMaterialUncheckedUpdateWithoutRawMaterialInput = {
    id?: IntFieldUpdateOperationsInput | number
    wipId?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
  }

  export type WIPRawMaterialUncheckedUpdateManyWithoutRawMaterialInput = {
    id?: IntFieldUpdateOperationsInput | number
    wipId?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
  }

  export type VARIANT_RAW_MATERIALS_TRACKERCreateManyVariantInput = {
    rawMaterialId: bigint | number
    avgQuantity: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type VARIANT_RAW_MATERIALS_TRACKERUpdateWithoutVariantInput = {
    avgQuantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rawMaterial?: RAW_MATERIALSUpdateOneRequiredWithoutVariantMaterialsNestedInput
  }

  export type VARIANT_RAW_MATERIALS_TRACKERUncheckedUpdateWithoutVariantInput = {
    rawMaterialId?: BigIntFieldUpdateOperationsInput | bigint | number
    avgQuantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type VARIANT_RAW_MATERIALS_TRACKERUncheckedUpdateManyWithoutVariantInput = {
    rawMaterialId?: BigIntFieldUpdateOperationsInput | bigint | number
    avgQuantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SHOPIFY_PRODUCTSCreateManyCategoryInput = {
    id: bigint | number
    name: string
    price: Decimal | DecimalJsLike | number | string
    status?: string | null
    img?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SHOPIFY_PRODUCTSUpdateWithoutCategoryInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
    img?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ShopifyVariants?: SHOPIFY_VARIANTSUpdateManyWithoutProductNestedInput
    WIPProducts?: WIP_PRODUCTSUpdateManyWithoutProductNestedInput
  }

  export type SHOPIFY_PRODUCTSUncheckedUpdateWithoutCategoryInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
    img?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ShopifyVariants?: SHOPIFY_VARIANTSUncheckedUpdateManyWithoutProductNestedInput
    WIPProducts?: WIP_PRODUCTSUncheckedUpdateManyWithoutProductNestedInput
  }

  export type SHOPIFY_PRODUCTSUncheckedUpdateManyWithoutCategoryInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
    img?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SHOPIFY_VARIANTSCreateManyProductInput = {
    id: bigint | number
    name: string
    AvailableQty: number
    img?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    variantName?: string | null
    variantOption?: string | null
  }

  export type WIP_PRODUCTSCreateManyProductInput = {
    id?: number
    wipId: number
    quantity: number
  }

  export type SHOPIFY_VARIANTSUpdateWithoutProductInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    AvailableQty?: IntFieldUpdateOperationsInput | number
    img?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    variantName?: NullableStringFieldUpdateOperationsInput | string | null
    variantOption?: NullableStringFieldUpdateOperationsInput | string | null
    VariantMaterials?: VARIANT_RAW_MATERIALS_TRACKERUpdateManyWithoutVariantNestedInput
  }

  export type SHOPIFY_VARIANTSUncheckedUpdateWithoutProductInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    AvailableQty?: IntFieldUpdateOperationsInput | number
    img?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    variantName?: NullableStringFieldUpdateOperationsInput | string | null
    variantOption?: NullableStringFieldUpdateOperationsInput | string | null
    VariantMaterials?: VARIANT_RAW_MATERIALS_TRACKERUncheckedUpdateManyWithoutVariantNestedInput
  }

  export type SHOPIFY_VARIANTSUncheckedUpdateManyWithoutProductInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    AvailableQty?: IntFieldUpdateOperationsInput | number
    img?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    variantName?: NullableStringFieldUpdateOperationsInput | string | null
    variantOption?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type WIP_PRODUCTSUpdateWithoutProductInput = {
    quantity?: IntFieldUpdateOperationsInput | number
    wip?: WIPUpdateOneRequiredWithoutWipProductsNestedInput
  }

  export type WIP_PRODUCTSUncheckedUpdateWithoutProductInput = {
    id?: IntFieldUpdateOperationsInput | number
    wipId?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
  }

  export type WIP_PRODUCTSUncheckedUpdateManyWithoutProductInput = {
    id?: IntFieldUpdateOperationsInput | number
    wipId?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
  }

  export type RM_QCCreateManyTransactionInput = {
    id?: number
    rawMaterialId: bigint | number
    quality_status: $Enums.QualityStatus
    checkedById: number
    doneById: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type RM_WASTAGE_LOGSCreateManyTransactionInput = {
    id?: number
    rawMaterialId: bigint | number
    quantity: number
    reason: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type RM_QCUpdateWithoutTransactionInput = {
    quality_status?: EnumQualityStatusFieldUpdateOperationsInput | $Enums.QualityStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rawMaterial?: RAW_MATERIALSUpdateOneRequiredWithoutRMQualityChecksNestedInput
    checkedBy?: EmployeeUpdateOneRequiredWithoutRM_QCNestedInput
    doneBy?: EmployeeUpdateOneRequiredWithoutRM_QC2NestedInput
  }

  export type RM_QCUncheckedUpdateWithoutTransactionInput = {
    id?: IntFieldUpdateOperationsInput | number
    rawMaterialId?: BigIntFieldUpdateOperationsInput | bigint | number
    quality_status?: EnumQualityStatusFieldUpdateOperationsInput | $Enums.QualityStatus
    checkedById?: IntFieldUpdateOperationsInput | number
    doneById?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type RM_QCUncheckedUpdateManyWithoutTransactionInput = {
    id?: IntFieldUpdateOperationsInput | number
    rawMaterialId?: BigIntFieldUpdateOperationsInput | bigint | number
    quality_status?: EnumQualityStatusFieldUpdateOperationsInput | $Enums.QualityStatus
    checkedById?: IntFieldUpdateOperationsInput | number
    doneById?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type RM_WASTAGE_LOGSUpdateWithoutTransactionInput = {
    quantity?: IntFieldUpdateOperationsInput | number
    reason?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rawMaterial?: RAW_MATERIALSUpdateOneRequiredWithoutRMWastageLogsNestedInput
  }

  export type RM_WASTAGE_LOGSUncheckedUpdateWithoutTransactionInput = {
    id?: IntFieldUpdateOperationsInput | number
    rawMaterialId?: BigIntFieldUpdateOperationsInput | bigint | number
    quantity?: IntFieldUpdateOperationsInput | number
    reason?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type RM_WASTAGE_LOGSUncheckedUpdateManyWithoutTransactionInput = {
    id?: IntFieldUpdateOperationsInput | number
    rawMaterialId?: BigIntFieldUpdateOperationsInput | bigint | number
    quantity?: IntFieldUpdateOperationsInput | number
    reason?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type RM_QCCreateManyCheckedByInput = {
    id?: number
    transactionId: number
    rawMaterialId: bigint | number
    quality_status: $Enums.QualityStatus
    doneById: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type RM_QCCreateManyDoneByInput = {
    id?: number
    transactionId: number
    rawMaterialId: bigint | number
    quality_status: $Enums.QualityStatus
    checkedById: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type RM_TRANSACTIONSCreateManyInitiatedByInput = {
    id?: number
    rawMaterialId: bigint | number
    quantity: number
    transactionType: $Enums.TransactionType
    reason: string
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type WIP_TRANSACTIONSCreateManyInitiatedByInput = {
    id?: number
    wipId: number
    quantity: number
    transactionType: $Enums.TransactionType
    reason: string
    status: $Enums.Status
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FG_TRANSACTIONSCreateManyInitiatedByInput = {
    id?: number
    fgId: number
    quantity: number
    transactionType: $Enums.TransactionType
    status: $Enums.Status
    reason: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type AuditLogsCreateManyChangedByInput = {
    id?: number
    tableName: string
    action: $Enums.Actions
    oldValue?: NullableJsonNullValueInput | InputJsonValue
    newValue?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type RM_QCUpdateWithoutCheckedByInput = {
    quality_status?: EnumQualityStatusFieldUpdateOperationsInput | $Enums.QualityStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rawMaterial?: RAW_MATERIALSUpdateOneRequiredWithoutRMQualityChecksNestedInput
    transaction?: RM_TRANSACTIONSUpdateOneRequiredWithoutRMQualityChecksNestedInput
    doneBy?: EmployeeUpdateOneRequiredWithoutRM_QC2NestedInput
  }

  export type RM_QCUncheckedUpdateWithoutCheckedByInput = {
    id?: IntFieldUpdateOperationsInput | number
    transactionId?: IntFieldUpdateOperationsInput | number
    rawMaterialId?: BigIntFieldUpdateOperationsInput | bigint | number
    quality_status?: EnumQualityStatusFieldUpdateOperationsInput | $Enums.QualityStatus
    doneById?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type RM_QCUncheckedUpdateManyWithoutCheckedByInput = {
    id?: IntFieldUpdateOperationsInput | number
    transactionId?: IntFieldUpdateOperationsInput | number
    rawMaterialId?: BigIntFieldUpdateOperationsInput | bigint | number
    quality_status?: EnumQualityStatusFieldUpdateOperationsInput | $Enums.QualityStatus
    doneById?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type RM_QCUpdateWithoutDoneByInput = {
    quality_status?: EnumQualityStatusFieldUpdateOperationsInput | $Enums.QualityStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rawMaterial?: RAW_MATERIALSUpdateOneRequiredWithoutRMQualityChecksNestedInput
    transaction?: RM_TRANSACTIONSUpdateOneRequiredWithoutRMQualityChecksNestedInput
    checkedBy?: EmployeeUpdateOneRequiredWithoutRM_QCNestedInput
  }

  export type RM_QCUncheckedUpdateWithoutDoneByInput = {
    id?: IntFieldUpdateOperationsInput | number
    transactionId?: IntFieldUpdateOperationsInput | number
    rawMaterialId?: BigIntFieldUpdateOperationsInput | bigint | number
    quality_status?: EnumQualityStatusFieldUpdateOperationsInput | $Enums.QualityStatus
    checkedById?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type RM_QCUncheckedUpdateManyWithoutDoneByInput = {
    id?: IntFieldUpdateOperationsInput | number
    transactionId?: IntFieldUpdateOperationsInput | number
    rawMaterialId?: BigIntFieldUpdateOperationsInput | bigint | number
    quality_status?: EnumQualityStatusFieldUpdateOperationsInput | $Enums.QualityStatus
    checkedById?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type RM_TRANSACTIONSUpdateWithoutInitiatedByInput = {
    quantity?: IntFieldUpdateOperationsInput | number
    transactionType?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    reason?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rawMaterial?: RAW_MATERIALSUpdateOneRequiredWithoutRMTransactionsNestedInput
    RMQualityChecks?: RM_QCUpdateManyWithoutTransactionNestedInput
    RMWastageLogs?: RM_WASTAGE_LOGSUpdateManyWithoutTransactionNestedInput
  }

  export type RM_TRANSACTIONSUncheckedUpdateWithoutInitiatedByInput = {
    id?: IntFieldUpdateOperationsInput | number
    rawMaterialId?: BigIntFieldUpdateOperationsInput | bigint | number
    quantity?: IntFieldUpdateOperationsInput | number
    transactionType?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    reason?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    RMQualityChecks?: RM_QCUncheckedUpdateManyWithoutTransactionNestedInput
    RMWastageLogs?: RM_WASTAGE_LOGSUncheckedUpdateManyWithoutTransactionNestedInput
  }

  export type RM_TRANSACTIONSUncheckedUpdateManyWithoutInitiatedByInput = {
    id?: IntFieldUpdateOperationsInput | number
    rawMaterialId?: BigIntFieldUpdateOperationsInput | bigint | number
    quantity?: IntFieldUpdateOperationsInput | number
    transactionType?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    reason?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type WIP_TRANSACTIONSUpdateWithoutInitiatedByInput = {
    quantity?: IntFieldUpdateOperationsInput | number
    transactionType?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    reason?: StringFieldUpdateOperationsInput | string
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    wip?: WIPUpdateOneRequiredWithoutWIPTransactionsNestedInput
    wipQC?: WIP_QCUpdateManyWithoutWIPTransactionsNestedInput
    wipWasteLogs?: WIP_WASTAGE_LOGSUpdateManyWithoutWIPTransactionsNestedInput
  }

  export type WIP_TRANSACTIONSUncheckedUpdateWithoutInitiatedByInput = {
    id?: IntFieldUpdateOperationsInput | number
    wipId?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    transactionType?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    reason?: StringFieldUpdateOperationsInput | string
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    wipQC?: WIP_QCUncheckedUpdateManyWithoutWIPTransactionsNestedInput
    wipWasteLogs?: WIP_WASTAGE_LOGSUncheckedUpdateManyWithoutWIPTransactionsNestedInput
  }

  export type WIP_TRANSACTIONSUncheckedUpdateManyWithoutInitiatedByInput = {
    id?: IntFieldUpdateOperationsInput | number
    wipId?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    transactionType?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    reason?: StringFieldUpdateOperationsInput | string
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FG_TRANSACTIONSUpdateWithoutInitiatedByInput = {
    quantity?: IntFieldUpdateOperationsInput | number
    transactionType?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    reason?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fg?: FGUpdateOneRequiredWithoutFGTransactionsNestedInput
    fgQC?: FG_QCUpdateManyWithoutFGTransactionsNestedInput
    fgWasteLogs?: FG_WASTAGE_LOGSUpdateManyWithoutFGTransactionsNestedInput
  }

  export type FG_TRANSACTIONSUncheckedUpdateWithoutInitiatedByInput = {
    id?: IntFieldUpdateOperationsInput | number
    fgId?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    transactionType?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    reason?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fgQC?: FG_QCUncheckedUpdateManyWithoutFGTransactionsNestedInput
    fgWasteLogs?: FG_WASTAGE_LOGSUncheckedUpdateManyWithoutFGTransactionsNestedInput
  }

  export type FG_TRANSACTIONSUncheckedUpdateManyWithoutInitiatedByInput = {
    id?: IntFieldUpdateOperationsInput | number
    fgId?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    transactionType?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    reason?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AuditLogsUpdateWithoutChangedByInput = {
    tableName?: StringFieldUpdateOperationsInput | string
    action?: EnumActionsFieldUpdateOperationsInput | $Enums.Actions
    oldValue?: NullableJsonNullValueInput | InputJsonValue
    newValue?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogsUncheckedUpdateWithoutChangedByInput = {
    id?: IntFieldUpdateOperationsInput | number
    tableName?: StringFieldUpdateOperationsInput | string
    action?: EnumActionsFieldUpdateOperationsInput | $Enums.Actions
    oldValue?: NullableJsonNullValueInput | InputJsonValue
    newValue?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogsUncheckedUpdateManyWithoutChangedByInput = {
    id?: IntFieldUpdateOperationsInput | number
    tableName?: StringFieldUpdateOperationsInput | string
    action?: EnumActionsFieldUpdateOperationsInput | $Enums.Actions
    oldValue?: NullableJsonNullValueInput | InputJsonValue
    newValue?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WIP_TRANSACTIONSCreateManyWipInput = {
    id?: number
    quantity: number
    transactionType: $Enums.TransactionType
    reason: string
    status: $Enums.Status
    initiatedById: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WIP_QCCreateManyWipInput = {
    id?: number
    transactionId: number
    transactionType: $Enums.TransactionType
    quality_status: $Enums.QualityStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WIP_WASTAGE_LOGSCreateManyWipInput = {
    id?: number
    transactionId: number
    transactionType: $Enums.TransactionType
    quantity: number
    reason: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WIP_PRODUCTSCreateManyWipInput = {
    id?: number
    productId: bigint | number
    quantity: number
  }

  export type WIPRawMaterialCreateManyWipInput = {
    id?: number
    rawMaterialId: bigint | number
    quantity: number
  }

  export type WIP_TRANSACTIONSUpdateWithoutWipInput = {
    quantity?: IntFieldUpdateOperationsInput | number
    transactionType?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    reason?: StringFieldUpdateOperationsInput | string
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    initiatedBy?: EmployeeUpdateOneRequiredWithoutWIPTransactionsNestedInput
    wipQC?: WIP_QCUpdateManyWithoutWIPTransactionsNestedInput
    wipWasteLogs?: WIP_WASTAGE_LOGSUpdateManyWithoutWIPTransactionsNestedInput
  }

  export type WIP_TRANSACTIONSUncheckedUpdateWithoutWipInput = {
    id?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    transactionType?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    reason?: StringFieldUpdateOperationsInput | string
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    initiatedById?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    wipQC?: WIP_QCUncheckedUpdateManyWithoutWIPTransactionsNestedInput
    wipWasteLogs?: WIP_WASTAGE_LOGSUncheckedUpdateManyWithoutWIPTransactionsNestedInput
  }

  export type WIP_TRANSACTIONSUncheckedUpdateManyWithoutWipInput = {
    id?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    transactionType?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    reason?: StringFieldUpdateOperationsInput | string
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    initiatedById?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WIP_QCUpdateWithoutWipInput = {
    transactionType?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    quality_status?: EnumQualityStatusFieldUpdateOperationsInput | $Enums.QualityStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    WIPTransactions?: WIP_TRANSACTIONSUpdateOneRequiredWithoutWipQCNestedInput
  }

  export type WIP_QCUncheckedUpdateWithoutWipInput = {
    id?: IntFieldUpdateOperationsInput | number
    transactionId?: IntFieldUpdateOperationsInput | number
    transactionType?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    quality_status?: EnumQualityStatusFieldUpdateOperationsInput | $Enums.QualityStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WIP_QCUncheckedUpdateManyWithoutWipInput = {
    id?: IntFieldUpdateOperationsInput | number
    transactionId?: IntFieldUpdateOperationsInput | number
    transactionType?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    quality_status?: EnumQualityStatusFieldUpdateOperationsInput | $Enums.QualityStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WIP_WASTAGE_LOGSUpdateWithoutWipInput = {
    transactionType?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    quantity?: IntFieldUpdateOperationsInput | number
    reason?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    WIPTransactions?: WIP_TRANSACTIONSUpdateOneRequiredWithoutWipWasteLogsNestedInput
  }

  export type WIP_WASTAGE_LOGSUncheckedUpdateWithoutWipInput = {
    id?: IntFieldUpdateOperationsInput | number
    transactionId?: IntFieldUpdateOperationsInput | number
    transactionType?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    quantity?: IntFieldUpdateOperationsInput | number
    reason?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WIP_WASTAGE_LOGSUncheckedUpdateManyWithoutWipInput = {
    id?: IntFieldUpdateOperationsInput | number
    transactionId?: IntFieldUpdateOperationsInput | number
    transactionType?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    quantity?: IntFieldUpdateOperationsInput | number
    reason?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WIP_PRODUCTSUpdateWithoutWipInput = {
    quantity?: IntFieldUpdateOperationsInput | number
    product?: SHOPIFY_PRODUCTSUpdateOneRequiredWithoutWIPProductsNestedInput
  }

  export type WIP_PRODUCTSUncheckedUpdateWithoutWipInput = {
    id?: IntFieldUpdateOperationsInput | number
    productId?: BigIntFieldUpdateOperationsInput | bigint | number
    quantity?: IntFieldUpdateOperationsInput | number
  }

  export type WIP_PRODUCTSUncheckedUpdateManyWithoutWipInput = {
    id?: IntFieldUpdateOperationsInput | number
    productId?: BigIntFieldUpdateOperationsInput | bigint | number
    quantity?: IntFieldUpdateOperationsInput | number
  }

  export type WIPRawMaterialUpdateWithoutWipInput = {
    quantity?: IntFieldUpdateOperationsInput | number
    rawMaterial?: RAW_MATERIALSUpdateOneRequiredWithoutWIPMaterialsNestedInput
  }

  export type WIPRawMaterialUncheckedUpdateWithoutWipInput = {
    id?: IntFieldUpdateOperationsInput | number
    rawMaterialId?: BigIntFieldUpdateOperationsInput | bigint | number
    quantity?: IntFieldUpdateOperationsInput | number
  }

  export type WIPRawMaterialUncheckedUpdateManyWithoutWipInput = {
    id?: IntFieldUpdateOperationsInput | number
    rawMaterialId?: BigIntFieldUpdateOperationsInput | bigint | number
    quantity?: IntFieldUpdateOperationsInput | number
  }

  export type FG_TRANSACTIONSCreateManyFgInput = {
    id?: number
    quantity: number
    transactionType: $Enums.TransactionType
    status: $Enums.Status
    reason: string
    IntiatedById: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type FG_QCCreateManyFgInput = {
    id?: number
    transactionId: number
    transactionType: $Enums.TransactionType
    quality_status: $Enums.QualityStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FG_WASTAGE_LOGSCreateManyFgInput = {
    id?: number
    transactionId: number
    transactionType: $Enums.TransactionType
    quantity: number
    reason: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FG_PRODUCTSCreateManyFgInput = {
    id?: number
    productId: number
    quantity: number
  }

  export type FG_TRANSACTIONSUpdateWithoutFgInput = {
    quantity?: IntFieldUpdateOperationsInput | number
    transactionType?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    reason?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    initiatedBy?: EmployeeUpdateOneRequiredWithoutFGTransactionsNestedInput
    fgQC?: FG_QCUpdateManyWithoutFGTransactionsNestedInput
    fgWasteLogs?: FG_WASTAGE_LOGSUpdateManyWithoutFGTransactionsNestedInput
  }

  export type FG_TRANSACTIONSUncheckedUpdateWithoutFgInput = {
    id?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    transactionType?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    reason?: StringFieldUpdateOperationsInput | string
    IntiatedById?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fgQC?: FG_QCUncheckedUpdateManyWithoutFGTransactionsNestedInput
    fgWasteLogs?: FG_WASTAGE_LOGSUncheckedUpdateManyWithoutFGTransactionsNestedInput
  }

  export type FG_TRANSACTIONSUncheckedUpdateManyWithoutFgInput = {
    id?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    transactionType?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    reason?: StringFieldUpdateOperationsInput | string
    IntiatedById?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type FG_QCUpdateWithoutFgInput = {
    transactionType?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    quality_status?: EnumQualityStatusFieldUpdateOperationsInput | $Enums.QualityStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    FGTransactions?: FG_TRANSACTIONSUpdateOneRequiredWithoutFgQCNestedInput
  }

  export type FG_QCUncheckedUpdateWithoutFgInput = {
    id?: IntFieldUpdateOperationsInput | number
    transactionId?: IntFieldUpdateOperationsInput | number
    transactionType?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    quality_status?: EnumQualityStatusFieldUpdateOperationsInput | $Enums.QualityStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FG_QCUncheckedUpdateManyWithoutFgInput = {
    id?: IntFieldUpdateOperationsInput | number
    transactionId?: IntFieldUpdateOperationsInput | number
    transactionType?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    quality_status?: EnumQualityStatusFieldUpdateOperationsInput | $Enums.QualityStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FG_WASTAGE_LOGSUpdateWithoutFgInput = {
    transactionType?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    quantity?: IntFieldUpdateOperationsInput | number
    reason?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    FGTransactions?: FG_TRANSACTIONSUpdateOneRequiredWithoutFgWasteLogsNestedInput
  }

  export type FG_WASTAGE_LOGSUncheckedUpdateWithoutFgInput = {
    id?: IntFieldUpdateOperationsInput | number
    transactionId?: IntFieldUpdateOperationsInput | number
    transactionType?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    quantity?: IntFieldUpdateOperationsInput | number
    reason?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FG_WASTAGE_LOGSUncheckedUpdateManyWithoutFgInput = {
    id?: IntFieldUpdateOperationsInput | number
    transactionId?: IntFieldUpdateOperationsInput | number
    transactionType?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    quantity?: IntFieldUpdateOperationsInput | number
    reason?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FG_PRODUCTSUpdateWithoutFgInput = {
    productId?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
  }

  export type FG_PRODUCTSUncheckedUpdateWithoutFgInput = {
    id?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
  }

  export type FG_PRODUCTSUncheckedUpdateManyWithoutFgInput = {
    id?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
  }

  export type WIP_QCCreateManyWIPTransactionsInput = {
    id?: number
    transactionType: $Enums.TransactionType
    wipId: number
    quality_status: $Enums.QualityStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WIP_WASTAGE_LOGSCreateManyWIPTransactionsInput = {
    id?: number
    transactionType: $Enums.TransactionType
    wipId: number
    quantity: number
    reason: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WIP_QCUpdateWithoutWIPTransactionsInput = {
    transactionType?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    quality_status?: EnumQualityStatusFieldUpdateOperationsInput | $Enums.QualityStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    wip?: WIPUpdateOneRequiredWithoutWIPQCsNestedInput
  }

  export type WIP_QCUncheckedUpdateWithoutWIPTransactionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    transactionType?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    wipId?: IntFieldUpdateOperationsInput | number
    quality_status?: EnumQualityStatusFieldUpdateOperationsInput | $Enums.QualityStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WIP_QCUncheckedUpdateManyWithoutWIPTransactionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    transactionType?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    wipId?: IntFieldUpdateOperationsInput | number
    quality_status?: EnumQualityStatusFieldUpdateOperationsInput | $Enums.QualityStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WIP_WASTAGE_LOGSUpdateWithoutWIPTransactionsInput = {
    transactionType?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    quantity?: IntFieldUpdateOperationsInput | number
    reason?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    wip?: WIPUpdateOneRequiredWithoutWIPWastageLogsNestedInput
  }

  export type WIP_WASTAGE_LOGSUncheckedUpdateWithoutWIPTransactionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    transactionType?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    wipId?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    reason?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WIP_WASTAGE_LOGSUncheckedUpdateManyWithoutWIPTransactionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    transactionType?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    wipId?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    reason?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FG_QCCreateManyFGTransactionsInput = {
    id?: number
    transactionType: $Enums.TransactionType
    fgId: number
    quality_status: $Enums.QualityStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FG_WASTAGE_LOGSCreateManyFGTransactionsInput = {
    id?: number
    transactionType: $Enums.TransactionType
    fgId: number
    quantity: number
    reason: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FG_QCUpdateWithoutFGTransactionsInput = {
    transactionType?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    quality_status?: EnumQualityStatusFieldUpdateOperationsInput | $Enums.QualityStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fg?: FGUpdateOneRequiredWithoutFGQCsNestedInput
  }

  export type FG_QCUncheckedUpdateWithoutFGTransactionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    transactionType?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    fgId?: IntFieldUpdateOperationsInput | number
    quality_status?: EnumQualityStatusFieldUpdateOperationsInput | $Enums.QualityStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FG_QCUncheckedUpdateManyWithoutFGTransactionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    transactionType?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    fgId?: IntFieldUpdateOperationsInput | number
    quality_status?: EnumQualityStatusFieldUpdateOperationsInput | $Enums.QualityStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FG_WASTAGE_LOGSUpdateWithoutFGTransactionsInput = {
    transactionType?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    quantity?: IntFieldUpdateOperationsInput | number
    reason?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fg?: FGUpdateOneRequiredWithoutFGWastageLogsNestedInput
  }

  export type FG_WASTAGE_LOGSUncheckedUpdateWithoutFGTransactionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    transactionType?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    fgId?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    reason?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FG_WASTAGE_LOGSUncheckedUpdateManyWithoutFGTransactionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    transactionType?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    fgId?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    reason?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}